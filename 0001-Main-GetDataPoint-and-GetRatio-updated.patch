From 9d443f72e28df8a9518197d35e501e1e99d6a342 Mon Sep 17 00:00:00 2001
From: BrianP <phiribriannn@gmail.com>
Date: Mon, 28 Aug 2023 15:26:42 +0200
Subject: [PATCH] Main, GetDataPoint and GetRatio updated

---
 .vscode/launch.json                           |   16 +
 client3.py                                    |   12 +-
 .../__pycache__/six.cpython-39.pyc            |  Bin 0 -> 27517 bytes
 myvenv/Lib/site-packages/dateutil/__init__.py |    8 +
 .../__pycache__/__init__.cpython-39.pyc       |  Bin 0 -> 390 bytes
 .../__pycache__/_common.cpython-39.pyc        |  Bin 0 -> 1450 bytes
 .../__pycache__/_version.cpython-39.pyc       |  Bin 0 -> 256 bytes
 .../__pycache__/easter.cpython-39.pyc         |  Bin 0 -> 2220 bytes
 .../__pycache__/relativedelta.cpython-39.pyc  |  Bin 0 -> 14830 bytes
 .../dateutil/__pycache__/rrule.cpython-39.pyc |  Bin 0 -> 43412 bytes
 .../dateutil/__pycache__/tzwin.cpython-39.pyc |  Bin 0 -> 221 bytes
 .../dateutil/__pycache__/utils.cpython-39.pyc |  Bin 0 -> 2289 bytes
 myvenv/Lib/site-packages/dateutil/_common.py  |   43 +
 myvenv/Lib/site-packages/dateutil/_version.py |    5 +
 myvenv/Lib/site-packages/dateutil/easter.py   |   89 +
 .../site-packages/dateutil/parser/__init__.py |   61 +
 .../__pycache__/__init__.cpython-39.pyc       |  Bin 0 -> 2094 bytes
 .../parser/__pycache__/_parser.cpython-39.pyc |  Bin 0 -> 40589 bytes
 .../__pycache__/isoparser.cpython-39.pyc      |  Bin 0 -> 11339 bytes
 .../site-packages/dateutil/parser/_parser.py  | 1613 ++++++++++++++
 .../dateutil/parser/isoparser.py              |  416 ++++
 .../site-packages/dateutil/relativedelta.py   |  599 ++++++
 myvenv/Lib/site-packages/dateutil/rrule.py    | 1737 ++++++++++++++++
 .../Lib/site-packages/dateutil/tz/__init__.py |   12 +
 .../tz/__pycache__/__init__.cpython-39.pyc    |  Bin 0 -> 692 bytes
 .../tz/__pycache__/_common.cpython-39.pyc     |  Bin 0 -> 10788 bytes
 .../tz/__pycache__/_factories.cpython-39.pyc  |  Bin 0 -> 2941 bytes
 .../dateutil/tz/__pycache__/tz.cpython-39.pyc |  Bin 0 -> 44958 bytes
 .../tz/__pycache__/win.cpython-39.pyc         |  Bin 0 -> 11430 bytes
 .../Lib/site-packages/dateutil/tz/_common.py  |  419 ++++
 .../site-packages/dateutil/tz/_factories.py   |   80 +
 myvenv/Lib/site-packages/dateutil/tz/tz.py    | 1849 +++++++++++++++++
 myvenv/Lib/site-packages/dateutil/tz/win.py   |  370 ++++
 myvenv/Lib/site-packages/dateutil/tzwin.py    |    2 +
 myvenv/Lib/site-packages/dateutil/utils.py    |   71 +
 .../dateutil/zoneinfo/__init__.py             |  167 ++
 .../__pycache__/__init__.cpython-39.pyc       |  Bin 0 -> 5742 bytes
 .../__pycache__/rebuild.cpython-39.pyc        |  Bin 0 -> 2694 bytes
 .../zoneinfo/dateutil-zoneinfo.tar.gz         |  Bin 0 -> 174394 bytes
 .../dateutil/zoneinfo/rebuild.py              |   75 +
 .../python_dateutil-2.8.2.dist-info/INSTALLER |    1 +
 .../python_dateutil-2.8.2.dist-info/LICENSE   |   54 +
 .../python_dateutil-2.8.2.dist-info/METADATA  |  204 ++
 .../python_dateutil-2.8.2.dist-info/RECORD    |   45 +
 .../python_dateutil-2.8.2.dist-info/REQUESTED |    0
 .../python_dateutil-2.8.2.dist-info/WHEEL     |    6 +
 .../top_level.txt                             |    1 +
 .../python_dateutil-2.8.2.dist-info/zip-safe  |    1 +
 .../six-1.16.0.dist-info/INSTALLER            |    1 +
 .../six-1.16.0.dist-info/LICENSE              |   18 +
 .../six-1.16.0.dist-info/METADATA             |   49 +
 .../site-packages/six-1.16.0.dist-info/RECORD |    8 +
 .../site-packages/six-1.16.0.dist-info/WHEEL  |    6 +
 .../six-1.16.0.dist-info/top_level.txt        |    1 +
 myvenv/Lib/site-packages/six.py               |  998 +++++++++
 55 files changed, 9033 insertions(+), 4 deletions(-)
 create mode 100644 .vscode/launch.json
 create mode 100644 myvenv/Lib/site-packages/__pycache__/six.cpython-39.pyc
 create mode 100644 myvenv/Lib/site-packages/dateutil/__init__.py
 create mode 100644 myvenv/Lib/site-packages/dateutil/__pycache__/__init__.cpython-39.pyc
 create mode 100644 myvenv/Lib/site-packages/dateutil/__pycache__/_common.cpython-39.pyc
 create mode 100644 myvenv/Lib/site-packages/dateutil/__pycache__/_version.cpython-39.pyc
 create mode 100644 myvenv/Lib/site-packages/dateutil/__pycache__/easter.cpython-39.pyc
 create mode 100644 myvenv/Lib/site-packages/dateutil/__pycache__/relativedelta.cpython-39.pyc
 create mode 100644 myvenv/Lib/site-packages/dateutil/__pycache__/rrule.cpython-39.pyc
 create mode 100644 myvenv/Lib/site-packages/dateutil/__pycache__/tzwin.cpython-39.pyc
 create mode 100644 myvenv/Lib/site-packages/dateutil/__pycache__/utils.cpython-39.pyc
 create mode 100644 myvenv/Lib/site-packages/dateutil/_common.py
 create mode 100644 myvenv/Lib/site-packages/dateutil/_version.py
 create mode 100644 myvenv/Lib/site-packages/dateutil/easter.py
 create mode 100644 myvenv/Lib/site-packages/dateutil/parser/__init__.py
 create mode 100644 myvenv/Lib/site-packages/dateutil/parser/__pycache__/__init__.cpython-39.pyc
 create mode 100644 myvenv/Lib/site-packages/dateutil/parser/__pycache__/_parser.cpython-39.pyc
 create mode 100644 myvenv/Lib/site-packages/dateutil/parser/__pycache__/isoparser.cpython-39.pyc
 create mode 100644 myvenv/Lib/site-packages/dateutil/parser/_parser.py
 create mode 100644 myvenv/Lib/site-packages/dateutil/parser/isoparser.py
 create mode 100644 myvenv/Lib/site-packages/dateutil/relativedelta.py
 create mode 100644 myvenv/Lib/site-packages/dateutil/rrule.py
 create mode 100644 myvenv/Lib/site-packages/dateutil/tz/__init__.py
 create mode 100644 myvenv/Lib/site-packages/dateutil/tz/__pycache__/__init__.cpython-39.pyc
 create mode 100644 myvenv/Lib/site-packages/dateutil/tz/__pycache__/_common.cpython-39.pyc
 create mode 100644 myvenv/Lib/site-packages/dateutil/tz/__pycache__/_factories.cpython-39.pyc
 create mode 100644 myvenv/Lib/site-packages/dateutil/tz/__pycache__/tz.cpython-39.pyc
 create mode 100644 myvenv/Lib/site-packages/dateutil/tz/__pycache__/win.cpython-39.pyc
 create mode 100644 myvenv/Lib/site-packages/dateutil/tz/_common.py
 create mode 100644 myvenv/Lib/site-packages/dateutil/tz/_factories.py
 create mode 100644 myvenv/Lib/site-packages/dateutil/tz/tz.py
 create mode 100644 myvenv/Lib/site-packages/dateutil/tz/win.py
 create mode 100644 myvenv/Lib/site-packages/dateutil/tzwin.py
 create mode 100644 myvenv/Lib/site-packages/dateutil/utils.py
 create mode 100644 myvenv/Lib/site-packages/dateutil/zoneinfo/__init__.py
 create mode 100644 myvenv/Lib/site-packages/dateutil/zoneinfo/__pycache__/__init__.cpython-39.pyc
 create mode 100644 myvenv/Lib/site-packages/dateutil/zoneinfo/__pycache__/rebuild.cpython-39.pyc
 create mode 100644 myvenv/Lib/site-packages/dateutil/zoneinfo/dateutil-zoneinfo.tar.gz
 create mode 100644 myvenv/Lib/site-packages/dateutil/zoneinfo/rebuild.py
 create mode 100644 myvenv/Lib/site-packages/python_dateutil-2.8.2.dist-info/INSTALLER
 create mode 100644 myvenv/Lib/site-packages/python_dateutil-2.8.2.dist-info/LICENSE
 create mode 100644 myvenv/Lib/site-packages/python_dateutil-2.8.2.dist-info/METADATA
 create mode 100644 myvenv/Lib/site-packages/python_dateutil-2.8.2.dist-info/RECORD
 create mode 100644 myvenv/Lib/site-packages/python_dateutil-2.8.2.dist-info/REQUESTED
 create mode 100644 myvenv/Lib/site-packages/python_dateutil-2.8.2.dist-info/WHEEL
 create mode 100644 myvenv/Lib/site-packages/python_dateutil-2.8.2.dist-info/top_level.txt
 create mode 100644 myvenv/Lib/site-packages/python_dateutil-2.8.2.dist-info/zip-safe
 create mode 100644 myvenv/Lib/site-packages/six-1.16.0.dist-info/INSTALLER
 create mode 100644 myvenv/Lib/site-packages/six-1.16.0.dist-info/LICENSE
 create mode 100644 myvenv/Lib/site-packages/six-1.16.0.dist-info/METADATA
 create mode 100644 myvenv/Lib/site-packages/six-1.16.0.dist-info/RECORD
 create mode 100644 myvenv/Lib/site-packages/six-1.16.0.dist-info/WHEEL
 create mode 100644 myvenv/Lib/site-packages/six-1.16.0.dist-info/top_level.txt
 create mode 100644 myvenv/Lib/site-packages/six.py

diff --git a/.vscode/launch.json b/.vscode/launch.json
new file mode 100644
index 0000000..306f58e
--- /dev/null
+++ b/.vscode/launch.json
@@ -0,0 +1,16 @@
+{
+    // Use IntelliSense to learn about possible attributes.
+    // Hover to view descriptions of existing attributes.
+    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
+    "version": "0.2.0",
+    "configurations": [
+        {
+            "name": "Python: Current File",
+            "type": "python",
+            "request": "launch",
+            "program": "${file}",
+            "console": "integratedTerminal",
+            "justMyCode": true
+        }
+    ]
+}
\ No newline at end of file
diff --git a/client3.py b/client3.py
index 3fc09b7..edcf1e5 100644
--- a/client3.py
+++ b/client3.py
@@ -35,14 +35,16 @@ def getDataPoint(quote):
     stock = quote['stock']
     bid_price = float(quote['top_bid']['price'])
     ask_price = float(quote['top_ask']['price'])
-    price = bid_price
+    price = (bid_price+ ask_price)/2
     return stock, bid_price, ask_price, price
 
 
 def getRatio(price_a, price_b):
     """ Get ratio of price_a and price_b """
     """ ------------- Update this function ------------- """
-    return 1
+    if (price_b == 0):
+        return
+    return price_a/price_b
 
 
 # Main
@@ -52,8 +54,10 @@ if __name__ == "__main__":
         quotes = json.loads(urllib.request.urlopen(QUERY.format(random.random())).read())
 
         """ ----------- Update to get the ratio --------------- """
+        prices = {}
         for quote in quotes:
             stock, bid_price, ask_price, price = getDataPoint(quote)
+            prices[stock] = price
             print("Quoted %s at (bid:%s, ask:%s, price:%s)" % (stock, bid_price, ask_price, price))
-
-        print("Ratio %s" % getRatio(price, price))
+        
+        print("Ratio %s" % getRatio(prices["ABC"], prices["DEF"]))
diff --git a/myvenv/Lib/site-packages/__pycache__/six.cpython-39.pyc b/myvenv/Lib/site-packages/__pycache__/six.cpython-39.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..e909fc5adcd5100cee152a9d089ea76309747131
GIT binary patch
literal 27517
zcmc(H33wdGb>?)>iNOGbz)PYiX>=13IpU#P6vbPjBtjHPT_eh)!BhhrU@$YRZji(n
zkS#%$s5rLiGnO4Yq&F9x?B;Tu&AGeIVaGXl<7Bg)V~=E$)vmqSYz}+1v9$mHs=KEL
z0Oj-hc7U#aRrTt6^{VRCt5;ne7|18^`^x*itp4GpMB*>#iU0P&vlEYdcts+i66J)l
zl-;nV?XqnVPBxO|q`Xt*l)TgBw7fIrjJ&hutV)%0DqZe#GLv~_U6xRpDZAVs`Lgg8
zj8A3WWg|W}l`aoB1^ppsaNH`daE9Ps;ta!G=?s=vIjhTSfWNkUX>-oG%wRa{#%<y_
z*~!ZRt#sA{Z&2{AICrJ$J8$VPIzuYIU?J81`xB~P6<$oJf^*eEvRv#8I#)Zzg~Wno
zC7wt$*QXNBHD|5al$GFLnC_`WGryU>0p{{_(HS^v>FdzS!N#@I*Ojlc63vuKmakJQ
z)X<BG^7ZNxHH`NSC~c)$h0<0@X*a^ZTCIV9jdLSP-vIwwbt(LpqV^*Qxd|bcsdWfh
zCm1)wf4N!@|9Z(`qqEW3ggTTEeucUc;a560A>A#`&FU)r71h-XDZtmLYt?n?dUef0
z8onFgyH?$(ZV=xFHG;UC)CTe04By6uB(OF~nv&Wi;kT&G_}ijx5#Ltv-J-UNZ=1SR
z-6m;nm%Q#!w@dh)Y6O(A^{wizrmgN)_efo~1Lt1B-l6VOJJl`;y;@zZiW0h8?N)mP
z+N<^k&_1;<fbQriVZYSzezjl9dqCQCKs^B82DE8p!N&VR^^m+DR(piE4o;;}r!S~c
z)QRP6P>-lXg7K(2td2;?QT3R5T%ae^lalJGsRUBJp`Jjhvcx>Cj;Ut^dYh`KX9cRN
zF;x>tDMyV9G@*{Gx<Hd^N;L$UR!!9ssI5*YEs(1`H6zeTbxNHUXjaXtjzDi$Zx5h3
zH5WkhYF<4jvF}jtlomX%UXb^KdQskG^{$|{FR7O$<cxYneUGGhxB6c79)aGg-lxtA
z^nUdL^+AC?q&}=ZBGC7#kE&M%`k4B-`hI~vp+2d8K%jH#y!w<t|4jX$`XPaSSp7(l
z^N*?v>eCYTW9rA%KNsj<sGkVR_(^Az`l+=E_0tmmGw^)|zMmD}XW{#~wF%=&$iGxS
zuYN(GUsS)Oep#SjQU6N)>xJaR?($~z(iQ68Oxb5s`X`;u=+)1uUtO>#tUD5j+q^gN
z%+~T2XRC9Ivt@Fdvt=QP(R{13#o4gH6rXWQ=WcVhs9$63+QfOxX=hU>KJ)Yz<aA2~
z59;yjYcVU7Zx_tl)o&07qwe$S3mA1@kWqIBM$K=kFG_oER=*WNza2rp6G6WlLBAJ4
zUyPvNkDz}WLH{m-cB#(>W&A+|eJO(eFoOPwkouDPBN-k4J_`Ti2>K5Z<VVn-M9`l`
zCH`3i{dola#|ZjQ2Aa66e5Z3KD7{K3eMgtlXEP_R1TF7$?f@-G={rDA^!$RQ{<Hco
z=g}9S<X@=21SS7cD0vqs`Crvv2`}8N{yKvG8|nuBm`IlIcJ7W!x~r$8Gbrh9=dPfn
zyHL_=Qqq4{|05{r%jzpA=_^vwJt*maBLBYuKi#bUR|NfS1pRN6X=48_g8n{&{vpEq
z#|Zjr1br=n{!awG9zp*%g8nIjz8*nuM9`Zdbk<Ud7;MF0I|e6Xa4H6;V{j%0XJc?K
z2KU9_d<^anTaWq_V(>r=9*n^&V(?HbpGyopacz0Kvpwp~dt$wrJMlPrbGvg-(3|%-
zn^5L3`xEb#cvhJ{1+*Fu)>69Cv-dhT1752>3-?m?F5Z{*_}2CKE)RVZsqzkIM^vAC
zd+PI7sLu}P-k?7BN`2M`^|=BiTp88pD)@?0pQ6;~KB>XgW)_>U$~&E%Q5pBe%IG`s
zAj;V3+!vH_pOkS;P{y^$^}48x>*2dW%D5qr7<S3{+7-;3q|%Ktn^|fD;1Nh6yYapW
z&&`1MIEAx)`XAxjSl$bFQ+XfUQh7hzTgvyt-CTYE?w0a_=5=^)6|8N7b*o_ACRn!%
z)*a;oot*Pv`5{P7MMzE$pUuziHj)$4-ihZfl=%>(CmYh!L*)m7eXx8mhTV>^?*{fg
zz&;pY7tZGO_akgOo_i5KiuOKIJ_O$mJoh2wQRk}i;U;}MLma$!;n|H?V(!5snD>)Q
z*xr3YyL}={9cEpe>zz@A?_a>|?xfEharU0K%0~s-2k0?@_5*rcp!)$mA<zSWo)qW+
zpr=6Be*GMBA`Krv`DMHh;CT@6(|A9G=V8Fd@IHuV6!0@h|2DvnAcsl-9|HVr06z-2
z+B^!3!+646j{pvHWn7r+V}RqiJ|4^UiCC^rGFP;lHGE3ieZ9jPmIIhId^&)i0enp0
z!r6lUQTQ10Hq?C#?+Tu00oNQ=c0}eMFONIp=Oz$dJ#S4OFV~+QM_VS9g)*m{^kkzv
z?KI0R!EKk@PJ8l1`2<{D)=#&QYOL&1`T|tDjD1#{vQX}a0I9ME*D24y9WS434&yx`
zVaFw`jxgphi6^Yz6kt<7r|h7Pb@&^2rcr0cHSx3nPdmwTr<~N}X=nDl9n_BXIx%@7
zl_;MmYv8rZF5E@602N7x69KhqfHh&fi9LqAJ9x9^6M)~2H|u{K@EqPJ@zep&gL?+_
zOU`r7?UV07*r^4({7$@I#d8|Z?2A_U`Q|!6AH%~O-;R)XI>edd&P62Fq}f9uY<?<*
z{5~h~&oRDPKqzy5CrW!ED(88X#NJ`SSy0KD1XBDxFkZm30IY?0p6Vc^;X!?=vrv8!
z@q7%<_0IEv-zDvrJzlhrBYww8PQDAzOXD`MUc&P->isf8&P*npmn(^$_%n!q1@W&S
z^cBRvQb{y3gv+lW=6mqG8};J*d-1#n@VoK;IG(e3-j9?F|9(6l!1F=)--Guj@Q{B#
z4F7xa{s^A$L)!OEB+6%<P38AHA6Q77`yfI;dLFyl84LCP$BBgVp~{CrfsdSBp?5pq
zM`*#q?0xGoyZq7etJrP6x?oLiQtKgquFyH>Rmhl|0vNc?NAJb%@$8BdJMiS5{^--M
zGKX^?b4usY8!CAuvEh?eBGI}1F|XdJdv(Vxj<<C2lm^_KDAroaDSF4NUQy39-D0a*
zJT&Va$7^e`+Em4DuW_S3V)-koV{WT4<2jZ3bi1X!(aw##o#te9x{ef%=V%vcwvPot
zJKK^;sih}&bTV5?TW&9He$7TsuO*qCty6^Q_^HY2$!h)0H{X0m4c?v~6YRv}u7cwv
z%8*dXHpa6JnkLz@k(6&eSwrihA7MUw@VLxhSwOQ#8!VSUJ8>a#!SYkC(-_w|1c>wc
zvwQA7_Lz%S9NSx;sC(5$@o}fAW}4oyy^cHOwc5uH>DHuE^W0;gUUkCRG})f6ZE{aJ
zo4l$!wQ0+->DiM`^W?FI>tn~<y60?aS8G$ibKyH(YR~%FN~Pg6E0rB6(`CyNR;TaD
zQV=?drsOJ>W_8-BRQ!CUGTl-$4Z?*=<-|<2VPbS4tZ}#Qx}RZLINR|^);U}JjWhz@
ze24kVvKNQkwo|K&>(+Fo(W)v(*Q6#u<Bu>OAs$sWbJkp<5|FS{+@-MRZ`Ecnt$J0j
zj{f#q#cFYUrdgw}G>QVyN}yCKBetJngr9_WQC-o{s=~ImRXc<-3@vQUK3>w5QEi41
z>m}wycj8%-_FUq!1UlC0+;KqIv1sVEv8WwyMmNdX-f<@gEmp_Dpc2rix*i(gl}3`J
zvf*V=IqA;2e%55-l0QiA#q}Nx@eST%tUY-wVdpHp4(}R0@gM8I6OX$d&QcCmDR6R1
zrO}cMs`GHQGYfXBeRI8n_Fu3@^`*%9g00zI`Z78ZQww8|tLn|VSE)RM$dK_?cFO_>
zn)q5cM1YrIvzU>v!cG8liF1kbiTR{wktxstn9i+4XV^>5S(7P-aAJnIHJnO#>DjxD
zuw?|SISf@z3ZRv_igqxOoOJxG>wt|sEw%Qu%4yK&_f;x2^pcBC8Qg_{`WPmieOkBl
zNJ?7iCtG8azU{UB46>SOc#B&M9-MH{;Ac^yI|wIX<*Y%=P7YfID`Rzrdm1mOqa$fO
z07Ol64J~9sUrFaiI$eSaB*X1;L_Cd0`afsqlA0k)`d_$%XeBsN|L0y#jAIs4$rt-D
zkD>pC3o<H;clu?}zMKI^^!fb<TPGcLP-cSBT9_AdlI~%5@o~4p@e=5m#Daa!o`d{j
zCA_5GFqc$`nS?IRS@X%cBt~+onVG}LsiYKm$8<>APrEa1N9zs9MB3~p4?VTbPlCk*
zdYk@9wi?P$Hl0%!EPV}eyR;ysns{7JP6=zsN`c;Z?9QrK1G;>+c)pGXIeD0ae9~IL
ztZgc2%fQk%BTDzt>Gp<n#8n78g(u|f-Xa5D>zU<9M?S*ZY)Zh|HYf<{E!bdkPzh`<
zEZ$|_q-J4$791mdTZAv<$&~PJHkh{k^vP;tX36}~FN{gdN~MFuF55!p%!4sIYkP?m
zl!B?$8Xd_l%bl!_-Ui1X2nJ2fX*4R87>&qxW`SS_H}JR_I5~T;4?N4TB|J->;?HGl
z$g{$+TzPX`dCj~9siw=VX}@2FmEqPNg0p{_DIb^2vY1)X<4MjTJ&dVGfT?ezBSTS`
z?h<;hpd$?<{Y>kKvVh0T$Kb)vs#tZF=e@9Adzh{WhoZ%VJ&zgAG!gYm?8TCEM}lD(
zlIc+`HQ-dyvsQ&!9br~nt0urz&*YhGGVy-<L<;OImE~-Wwb3qZ)|&ywdWzia=eIZN
zu2*YKw|Be(|KH(BbZ+cziK>HrO4}Q)TD9Ts01&3Y@_Pvw5K~5lJSG#T3t5Z9%1<-M
zU0fcQYi9Q{P=qnajjODVSszSaf_Q>+5hlC`N%dWHZlxow6sOC2?8N8s1guv`<ucN-
zHH7v2!YR(Z0l^{bsmyZIrA(7tIJ5qs44hqIlSgah@bE{NjK{}Sa27KkX37Va&XjX$
znLBsRVXnj+x*c<9x|y0w&8O$mVAOQ;QZthV@nys#mNDJAHDg$qQkh}ln+VBF#=alP
zbQf(ui|Lh<ho8k1D?pAR>@+{eAVSMA{RfbfNEh9SH-kRRSs9yCFyT}<w?riRCdR`W
z<QvY#^A;vVuKLLZJDitOv3dCxwu?;)<PblDmOy%qF+((0{~+rt{ft>JnDb)w3MOnw
z?4zL1a!ayIdKYCi68mge1ZKHm&5$LGMsC<iv^JcG(JahuT$L%4nN>Nh%&MG$cCSz6
zv9HUjb&98Y7ET)n)F5#Cf|IzsGAD8U<{S>EjfL`nIfE+?nzOg^3Y7!PUhc1|9I2l^
zh;`&p)jMt^SVwn$H($hWS8*B<#WrG!Mn0wN+6v$zw-X%XuI$h1o?CQh#tgmPQeJX6
zdc5uyMTlaehC_iJ=*2_(4sF}KwK!gHLh_g7W)n~<9`K6p@zzX36~`QG38ztbeXQX~
zZl~&~NVq91-6rX(jYiQqjfsbX_DO7;Apc|YI3D0_lY~na0nU<pNcAB&W^Yl)JXyiM
zE@Ug)NE-uF&DN=Au$o45*b1~g2$P-CV*cVH@YBrS@E1hAE0&{km-|_v@W(XVFWryF
zy#~&ljZOHa5S_^RB9$m>ZDKCD7W=FdB0^oTM}4aVrr!&6sdy+dagh6c<1-D}x4C{U
z1Q%5qizc^1ru#n2l1<ffR;Rdp)w}3R$V;Xc@^UNHQ)kqh+a<jp5&8i*;fCQs26U%v
zS%dmTdNx)11;mGv)kP{q`Pm?k_Us^7o2bLNBpN!Ngp56hx^%nT67r2C&1}dT`6)90
zl6sMEgQ9+!^^$2Gvk2z5<?9wpu&nef#Nvt^Rc)2o-f)`hRxs#aGHuwuLbp*?HRDw^
zNU*rFeNr}e+n<Y96;s}o%l2!8zNA;#J5tfj06GQfSC}_E0UBbbWzF7Xc3PgTAZ$>P
z|AJ+9U2Fj6(azN}9hi}htuH2yX3HybfQ8#*(4HLZ=N@uqWvAu$n>k55`eDQ^ZXdJ~
z-H!h}5CU1&h9nDF_UdID8Bf#GPV!3B&cpC@3LbU=bKQ2@vsd=)C==%}F3(%@wwIc-
zz4U^ucg)%6GT5Qo*yLdBR<a0}JhsCZPA@slbxp6O!*cv(87E#(KVNt2P1mb7YmV6@
z$tD2014B{B=P}MTtNY>sMa+P4e+Pw%IxAt>Hc6EM1LF@1HF#s$+LU6+d#J|I#py!0
zgWSpW`W&bR<s!B*?ETIsWhUmba#$22MNiK-8;kXE(S}gTp+YXen!!~^v{u1F!gNnK
z#U>Qmzy|_WrsFNZts;6K3x(EDi51D_MQqBc9xHOWhzbpsjcuh{iyK_W;R<x?ZCgg7
zcxop&)<t2IJzjN1%%NgsS*}B009|VMC%`c?Q?_%}vfS3iT|zbTn^0{K0Jnc;(`<Bw
zoqGaOjkcPOSx^oAPR!J`ql9?fyo;bpw8%ONIxv0F>gPCQsBryDR$gZM6ncI6MJmL-
zc;&g>HkF@5mxnBF>n9OzR--`nPqBj*kKlotcB)Y4nz{SStPvRsTFGmcC1(%%l1laJ
zT)Eb)XDwtT?1~`qnnlJr4Mn6W`)?2*mc9H4h#_+~jQ^p<vZ3tDWTW^Hi#tf?5jv03
zkuDLsP-&x&!SVB?u-lr^7}#%PXoXI9>_(N<WR(keT<Z98b}E}o;V+p_=hL}NZZOxE
z%cQ6RB3=zo&ySSZiD!`#yPU-KIi)yClaK;r3v<A8rrpjJR09?{=qX%5rjjjPIKGzA
zR7umHLJ`YWzKV!{VEN=XRNm4I@%w5=utjW69C*aH>n%SQ`7-162DGJqAC%bIYqc7X
zUdCn+hFQ?h)`Qr7^B%_*)bR^JsPU!i&Gw9kHdTUT(B$>$>M5uh8J?*(k#SQdVyKy_
zZ9i3~n?ZNfPAT7Rxn-(Y0MCf71;Ci!hmh8c#|(0iPp5G<;re+<zHQyAIj-xcb+tL+
z_?gq@J)oV~w28)umbg(L^OFFnIb<~7YNqB;RD%**8r$z4Z#bu+b8mT0Io+<e9b_(H
zep&+k91jZi)@x{Et<`8?)}!=mf**!V?B|JK2<j(0b+(XhKOC$Ys3vd<4C?x7t>$=r
zqFvQU=@<5h?~w7Wh!s+)j@7WEXIF~TiAR<Y>1S)L_N;a$NT&8Il&up`t&UAsCYm#T
zY64J)-V(hzhBx6rNsn-POX3}<sF~^M*$QMZ2Sh5weL?B3Q5Oeoe}FQ0-1FL)+FDa}
zXR-?BF(ByOk*HEPst`kU{mdRo(~-~s%k>A2d(({yb}e#V<s*w}oSncotDJGSBhjTO
zx?ivZ+T|ZOdhlUGxsF7Xf(Uq6#YP?J{471JorIQx&=t;fwce;q*Kr6lR&^a1Y%-v9
z@W8=+yXiLwB_foF;19)8fQu(06ec+!0S3jS5fpz_EYURd*LBp;>#XdSbubDvs3viQ
z>aUGu&}=oMh|ZdB9$37(*_Z?-n|K00-eS)=?ZsPsl>T^&iQo^C5Dy$ZdgzFwvGEHC
z2(E?4AJ}vMfo_~XbVOFhSV*>Zs9u|DV4Swi8$-&Oas2e7^2%zbtvN_j1pI>As!cgw
zka^*V_)NKwyA5+@y(yVc{Or*H7z{$7wW>B+6Mkl|ygOldDF`19@i3J+L0Eo2-~d02
zFU8_lg=ug|!=bN)CWRw`Pe>NxlzMQ&(26TG3Cb%N3I!#GIHew({;*81e%enSt)K3M
zAti={o{Hy9`AImjXoOr6rp63IDb{oS{-aZorxV6w>_zcm5*U*D>7!G4b@OCcSWgW2
zMoZU@w_4~TAN1Wr{~qJ-gjmQqh82b)?eui38PGw}(!ZDzJy=m%Zz|R&1#ha`Yd(C!
z50&v2#(4&Dcw;+ZLQ4`F_H1PuD+dPcSnD*?9W=h(t<yNx3h-kXYr>qpsh<8p-Q&IJ
z7iM$=JPbh<lX+*QQPz}t0s|B?HAM+<3e(by6PUm-f%yE4$*eQblea${l%ZQ=Eiat)
zVxCTbP>O~51E;4Ox?Kw=#y;ca)ELBslVgY&jK*Qp<|hw6eE85FGbW=H0ZRH*y}50x
zpTSF(p^5=I&<;X<RqA9+_5HN?FD^K7YtyTv6QSvfgXW0bD20$?rH96MyrmdbgxNx*
zN$csH(F>_%Wy|FR!#_jKjzYi_=@p0W^!xpX*zt$uXwuK2PSO>A{}C)WUKlK4l@qSt
z7eWoc54c$0U|ry60Zz8+O-b)Ep`S<4Ow;6L;2>Otl1jTV1MzI8X+)Gl0GQyR(C4)(
zW3wIv8W!a=xfOvB#q2Q+>sdc1u!jot2{glTZ4l%@%O6093;TiU1a*pjzj&LDhr@`#
zg9=usA(}~y$<-u+#090|N$2%p)BUJHca-#mnPKtW;|DW@z72kmgroY;(W}df)?Y)!
zbFuEHA7bF)hxc(LODCd<Tm3$+fF^7eL^}_pJKAa;ISw-#30*YiOH%G4I!RckmrfG)
zEz{|$i;WxYpub$NbJw>%a)P99L8~`Fn-9cjMZZv})pnYlLBkEDARm8FR4zEnWGp3O
zZY5OYqsoA~i>*i|)92POM0R!96P$*flb=0oTI3HtBH8T4{vA@j_SdpQ_B!KL2wKtu
z4`4rm^9p|@BMw6vAYxCTkyBv=#N7t6C;&V?8=~}!R1{>gf|(qG3B#$DRtG1vf7POZ
zC!it;N<ZvW8`J)!yT)8kS8E=!sn>SRc*nzxS25|5(A84-lHkk2Y+%ELj*RECn)xgZ
zULzST4euv<Scd{VM?zme7u(R2-`_=Bv8P%)?!*EHA8U#lKSUm8K0@v;8T-+LFxk;{
z2Nofm)@lu>+MH?oeHcbT=MV0O@@=;3FSJQ|%w%oQ*k55LP?7F=6dDFhIVVn57|>bW
zvrL9O_WG)xc_?K5p3o5YTOMP@i;pq44MEH4-2LqgGL!Z#M%lF(VZRX@W%T=5oEePC
z_9Yr+CL_Oqm|6qU8$`A#!K*jNTYetF1c2UIvzT}$>FcW(Q7>p#PcX=5g1=?@U3*db
zb!D5*z2622yUE{ziX))fpTww0zrW%z(~|iQ$-caE*&@nxvwr>3UgC6PIz2IQL2L<$
zl9(WO;&FM*5Ep-_H*(VFGRlUbb5@`vpqxM{Kz#zG0p$hC0P0s+mBV3WLG?j+%KI=j
z5&Oc$!c*tK9#IPxt4qYAB4=C|>etX-)N!3@91^;sN)9!>T`c`oR9t_Z&NU#Q-azMO
zI6amV@OO`iC}T~)4C7NYwy>e<^3z7(Ny}2_V}B@1l%ESZOMi*^i)==XL~NO+no-j@
z;j1VjR4-m^?F(%jMn?vg75=DQgJqi0BB3s#Ufje6mFV0;XEPnCj+jI&CogUU%2)8n
z0Vs8GDWm<D69CQFP9e@ZODILf&mKHtV`3~BXbVYGyg+$<*)CXVR+~j=@207z?+Ur2
zIH)Kht?2)Zei(L+EN&6i{2azVbh9U&H&|EE3fp=c;3f4Tk)=LI0bqw6SfPm_;7%M*
z*|VeO*akZ=G4Z*VCW1vV5quzaa0Pp~HL;_s-~daMqn*nSJFJUo5lvTPZR!j)(ZreB
zaZ!?PEMBi^HgI*+%4-SzDI6X&D5&gU9K~}Vv6@`m?0zi;Nz0RHwXq$vZP*SLEOW4>
zZvz#W7xjhEYXYJnF(9ZrIg`$4+Uz2jvNa%_lR>1XoI!&|8h|xgV^EsHldVrnHe~|L
zrCg9)gKUgWQt~MeNJN-XfEVPnq)*si(kJ9VW7`&<4bZL?N*ovp+4UtymP1u_lBZl1
zDt@aFlddHVr1veobGhD+xbaey<cayzi-rSWp-aOln(>V!M|-Ns43l_VK1>KhsiAq8
z0MJzGWa4p{Z=b+fCMN))BTNk{6&|bHiYh?+csr8#=_#6sF7Cj-?Gum|Pq+1sjVMLm
z3Czyru##$2F-^rRra~-e-jmhlte^5`+ptH4(Y0>T-cDbKl#4UZg&Ex(Bg_5Ekp*F<
z14tj9b$8D~U|Ebk+E{C*sTSwIipLQ_obUy;%9~?lJ;<_1z3@l)t;(`BkKO%bt+9ks
ztAo>=usn0FcU!EqgKya~9=-D<I$|un9rzkUdNJKJt9^Gj<0UOfBP(H7bApNUOCHCA
zfzC%(!%08Q9>T5?CNnsHJPMD#2I;^KY~r&0wK8a;5F45vCcL*>4}FLYgg^Qbjw-{0
zL63*2umiy1U{n=bV?x8p5}k+Wbf<Y)a7ebD-BM~%?g79;cH&ud8q{;8A%}Ay8Gt?G
z1{uq^5n7q*(Hx#tj355(10Kf>$2lgu<rc*qK-t%=V`m^Nuf#;SiLiJHWP(^jrODFT
zM-j0n%nAAr`a9e1$I&p2@8wJdOkBjl4bQP~y4-SI*cHtd1HOw;dRj^vu_GP|>16EC
z#uG3WvVPEdZ`?W<M=KzfpPF)J-3zvF;rwXoRIIM7rk^7YF&+==ny~bfsOz^~tUiL&
zenylcu6_)j#bxGMrip(lR%-b>FEx#vr<X5O&g>-mSgg!r--R-{k$Q_VCAtzT^KB#v
zRb%=oI!`ZG1x}CB#~k^bO}ahYombdR%Mn=m?|8SwC0+SV<<9O{Hg`r$eW$sT@XO}T
zh~{^iyO4Mp*3*nQ(aqh@ovb^j$o_twkYP%{kFfAcXG>u4V8lk5dWsYaWfU`^8NHOB
zFr2G;w$$17R!K|=OB3DqR*5#Cpp8XIIs!A4x?ZN#-QPHar%mC{Tr7_sJ^`V+b823=
z@EpV#&Zo4T%2H$5+_VMqQpRXYv3^@i7E^0%p-XM;Ak!s<uppVZmx=_M$ctwWYv!d`
zmgB(a*gJOnLlAm!D8C2tgSU^j!d_#><zW+ixLSvH_OLSn5vaT}2ovAIst47KTV7)V
zM_bTC6DtV!FIkd--yciw5B8?}PMaq*`b4*ZOY)1BVXp4Rs)@Gw=V6>Hc1@|#j(zM{
zCv^-ze{iN*7ik+er>boSVk1N>3E_UR-N1%*IT~wH_552@A{q7>?QB>HepN^$T6<KJ
z?qG%_G<@I=du$0)<fv%hile9>?iQh$Y>CXVq#T;PMHgUn3u(}%<k-x(Z`BtwN}jg7
zr$woMAy&`~5|smPIl$#YxTRCrjY<`v?uUHQ=oENd8TxwqfK?)=(tt)J6*k|4P1&4<
zHQ44F9L~_Tru8>29vBwsvgQS27U!p6ABl7RsZ)F}s=l5;JwMy6_jg!{;h+++fuK*J
zgvF)S5%vq;wNeXVsT@+vmN$v=e&xGX-in~Sa1<|F<P?hhT(?L+MH8we_PJSfolHx+
z0d%(F-U}}~3_-4x8!xbWwr8*#nxm8nZPN>o%U`gbfJn^!8Z0gIA+$MeF3a0U)Mh(l
zFxA6GcaSE5-4LiDu19ftEBVIu#uoJs2d(Bz_M5CeO_^aT$@>hVD&eh$%$qP`dL9kz
zX%G1|8cJ*rT4SL#H&KkIu8f!9CV9IDyGw-M0AF(6elFQ81R=NM5(n%_F~?YeIwjRv
zzYlc71w?aC8i$6}u7ayHs*j@<ohwP(qS^8DTv7J;Ze?Q;<~=pHf~$ozI)(ZOJ3Jhn
zP1D>c)C0gWoLJBZ=y~Kdk}79RM&)df4FV(^KP_n&Q!6dDaeqi!akAu9)I4ZKdYNl@
z`X$!Uf${)%V}-CAymqkAZY+9Z_tMO9<Zdy^^z^I&Xz(bw#U5Nif~hjL)G<VFtaxvc
zx#Y2RW;b-Sl*Ue!yT%)2P2O0Pd&g#lzi4?9EtoO%<;yjwLD5U5RkYghwo!w;0FI6C
z#Ibc02F!OWwV1Sdp@6jDZ%JP~;6;4~IYTcA<2kR!knl(OfvsPG$E8{j!v<>xZ!4d-
zUrC%vC>w0IjwXL{p^3NXa`U!I^NIm5snE4~iwJm@eij#NQ(g*&&7&$ipKS7?ZHk7@
z?z3J-<!I(Dsrn=pZY4>oj{qwzsa}jyr6tuzkP6?WV=DbA!2JRz-OtS>aLr-Od<H2q
zlJe6`2_?+uPJDVUss9)QqOf4iXYs}t>E?6IoGQ#`)xdmCYMRhrp39-uEI*;YHkX}G
zds%Kwk!$goJ>NH<nd`$B?AGAEREh%&?+o8(trLXPGT5l;8|>VA6uU-TcG~26vkj*x
zB#yR-^3{Uq8p^G54P|TTwi51{Lnpsf$HcB!$*xdv!u87?=G9I#10iQ{NfzXNT;fRR
z$Im1tdF{(WSO(n%j#)^`Z9vY74=BzZiE~+EK_y_%BZqT2?!GZwfVZINf|$sYUo3Yx
z&V#f((x)Fs>3*KaFAQo<;HEh)a(xfjLr;^Daw1qFLe^0|Cd|c;Gf<F8sVc4)yc=PV
zHSF=W;ZWInpGDx;$(2;0B{1f5Hl8<aJNJg2EXb{|L94S`Xc)UKC^_#(C7kxr&U(1T
z=^5OJ$E_a@;37T@Q7wiQ#Rm{N>)~7!rE^`qi9uLbMab?v>?~r9m(K&>OrT}@Z^MXh
z<zKgoBRN0WZne!+2=XW>1%x<42K`>PyN`;UeR6i*=QNQKwj$0*UY|y!o~6T9mkXz0
z#spQF$awlg4F513=<+lyC%`|AdJ`sPa#W!`MvKORr_bg}e8y1at0W&UHze#q63i|X
zQqc682^7TafrC5EAT$;rnOgIrzn7cN@DItPTd?#GpqQR{fsDvUgsGhX;`72hM5=Rg
z>kJH)#ASv^$$^oQ#JxjX7!vPu>GRO`38SS(g@Ldl!06-ne%z{0Vrel~8(w8AKMKds
zRHT{u96ZqJbcy&uqA+yPgeO(MB?+Q%Docpko2u{5>ceK?;JJcxy5_Xya}PB(D*RC)
zNL|w&JnnHga(n9b`4kTYpwGkjnomRZzXqy*YZfOR{Cf)bsQ7HgK>@UWm_&GxaUwOB
z#N@GlKE;vAl;@Hrk2=O9N85>=ys%RNu|g>{ZAQ<vC|J%oU?SDV*m0<FKc%bfHtxh$
zK&Pznz&0ZY#aRbbQWH%FH!n>RWiIA&aacqje?`Th1X=1Gq?Jf0$sA-9(kd^kv<}Rm
zFMz^55(=;rq?6Eyi#6}31Xs;%WxWTNgt6;{-2B7rn;)U`qi`TEJqKhzi=!|Pri_xY
z{xqY7uf-8PSDKA-M_DVm8wFV)^``!DU@j4?8Bgg?Zra|D1?gpL9ChFYZ-sj^nD^jP
z>f=r5dg46mmhN019S(9r3$7Sax+_-Y(xTisEY*;2&o5*YcO!zsqs(}b<)o7e{IV+I
zTZn1%RgBKnB0NHUTQ!+S_nxDm9zNvGk;Tc(zXJeij1Svc^2t|wDy>T%_~{I0Z7#KE
zINNVMgQ2F9+wo!5Gl}`s87z_DMO^+zn=#ZtPAZz2>uV&LKUk@>bbUfhgmI9Au_f|d
z0U8tDgM^(sJ`qDTu@5VB`PPL&g&_DadyQY|@bkP+W5V_0#2pN9l?jA0GcBtIj_A;M
z)78?;IH%x+;7W!4%)M#C8cuS$;)K*0`G)kuS*N65!kZD@nCTho9L6o^gr(VhiNWGv
zYGX%T<rx>aGHQ(eDK_h8=tRt@e-7SBR#C(zyR+$=saTZ#GPi#}ODgpX7Z`266k$s2
zE!*#lnBy7NfXt4&!2PzRf1a7Fz>XN-FoGh>d}>7UKo?VYu2~Ek_p^jQLx)LXrAQx`
zElpI)lPrbgOQhEf>0d;Go&iS+07D)*`t5#Af#L;4htBPLc%oHQ4lY&k@J+-WIl|yA
zkm^Op8p?`(tU=U?bMR29dd|Y7ILe9`-n=jutSCDn?_sk8v1j8PzGTX9OuB<2i>Bwy
zG`kt8AlE7RW~snQ1ADk)r<k^Z60+E6rM5#D0t|6zvJc<T;Lu5r@>?!$qs607IlYtF
z*r`rw2PdZTl@%=Rx1t4pN^UKjC#5Mci8vsum@d;xky;KVn4^pe8FpkqzfZ>EN!Vmy
z$!B4(U6e8rbis6Zj4OYLMX<L*u}KC_uy*r49&h7yu9O4trE^ZOdW8HUoFO?1+y5%_
z7WNqEN#BmR!!8WyUjx?b=^1Z))1CTz0WUiY_n^Tp&o4zdh2q6rniU^Dw1X|VT!6%;
z9K#cmx#i)j1Pj3#y17);`TU+16kks9rkmWGZVF8S#;|z<+w(XrxZ}4UycUYp;pT5s
z@!3GUdbYS}N73j$<=Wq~5DuS}?O3r0Ec%FHf+akb-?mtOA!a-;QCr1wGk(c07WMjC
z-dBaTk{50GT_@DNc;of%jhrJyyzY;+%I~8|zBEvTY5g(w3P&~;Rz>)IbSP6Bwuojd
zf52(V`Mt^Q1@@W<Lj9Ea_=y(%MWniTe~kzIwSYYzHVjaspl@s_An@%S8EH46*RXX6
zdM%^(N=z30xfe0HC`RzT>^OSb9rOCoyBJ$x?=n|h?EJZ~cU|dQ>45(~J-Ub`x}C_m
z3}31y>veJTZ-9mv_A=Ls)Q|5CZ8f9*3+xo`fb>lq@Sg|dXG|`p8-J5=(qY|R%Lly%
z2Kx}ZOtc_{0=kUyn0baQ{X0l{@viF`YHQFL{N9BbTp+#d6EWm2I@Ertw=-yS6LH};
z-zm|UTV{NP!_nMF{RU&KOKlmX-%O8$V@Zgvf17lc-iStzUXJ$t0qxn?AB&F{&Z8+?
z|1OD+C;AZvo)Lj5VtcTl!o_t6X(uhc9+%j$5tvLGTOdFX@$p3!`QA_{@Q<Xc8Dt|g
z+7&E|-BnY*WC-mOc7SfN5^fSJ6;T&pHR7k2f?LckPNDf7jBxTRNtTbr!?wZbD7rF#
z9FtGbnMY}K)aGXpqtsHsHo5&=tinR6IROm@`M=2ZY9khQ)(KI)m5?%Z_nURp$n(34
z*s|c5T<%=Q8rPB&IU@*5N*b+5n>tSgpIoeLjT+tkjz_UpZE_ODHlG>S&7i#AML?|z
zOZ~8!%^T5NQ_&#b4I`yxJMaklPVA#FRubo_VGU2s^sl3Lpu2#u7%(l?dKuKq*dqA3
z?Tza6n5yphZLo#0*xA&UZ$~cMkeCrqkPd6WZ=paVM&uvoXSYOyU~CwEk5RwR3R!wL
z;YE|j<!@2eub@UEttE1t{!@19jSTjAc}xERauU-oEJ+YVa2?sk=W1+exvc3Ig+DIe
zkK&gH$7k@JLdemY!l7*NG}jM52cu^Z0L^w@wh=(D!X~^0-X&SXeMUw91e+wy=Y;8}
z@a48!jVh%8t^g0pI_TogD=upc@Ltq}qfMAhz=1d&gmA!P)4>ZOX70^SS5Le34ossC
z?t1dbf$~269-^dphqc@%0;`zf7)2IN+B|H0rg32e`xVcnyzghsX947MlztL-PW*vK
zQ2+5p>y%OS3>uqC+><EH-~*+awgB=iNb`N6%jw;~#^sI0suXw|L$}k}Lq|Rnw1u>&
z(kmaM+DxcOhubZ)zC1*T)_~@s&XqkEhQ#bI{^czFHDLM?l4$mpBFR05Vwh84pSl$7
zS`zN+E}F56UWzwDyz3&ouI2Dj)QxQLHafR4QC@7E#BwZzX;g^Am>#RbeBkBPpFsm-
z#EXGqh#D9cYBBrS$-MhUacW_P6)oPxrpwqs(TYkRr1K~d^Zb4TbWya)S&4UGcO~Ue
zY2>en1xoeA>@Bnu3QZ{eONiDDWo1|Q1Vwf3O&?ZWtVYDRLu@c;5#bliu90SZ=*tT0
z{4AX+9f!_19GJ@;*H9lpyT~_&(F`tnXO5URK1@@af;~~w+sbi*kAq+<iHf1Ua=0rO
z))}UG0&A><#3;v%sv3Duk*%`3Im`|`qE8a9L+9;u=IHzwoi=gXgm_4*>vVXKsHf=g
z&{a>+d5PZV>71cM^`rh29Dn5#hj$%1wC`|b*O4O!?jJq4Z}jL9e?=Jh*rC0<j_x}m
z$|M}2i?%G(Yl+H8wz0BX5wTYUC|S^D`qN?&O@)B@90%=LL*mOe?n|t~y6DqXFmSEn
zrl_2CkrA*<<L+5L{-Hn4I#W>#%E~=`a8HIxyB;gauE>|$J}uVkJ63}L?mEoV(A`4W
z75q^zn;L}ZHw-8ve+aS7$IvLt6FZ+AN>ODuXb)0(hwrZp+Nop?A9NVHWN7v9ilNJf
z4&;(US&ESS%g5ep;4?c#?iNiv%U(w%4F1-MOK7=2Q%ke&?2XS@HWc{AH8BQe3Bx9@
zUraqfTjboEnH0ZiTCmoz?);KWawyZATd$8TSn~JRsmpW7nK=wXRhUWzd3-&UUN(Gb
z4zUpKp1;B0pQWx3^BqDPQmHi=L%qR&N@W(u6y8LC1hq5RmkyX(7Se@&=~vK-f9%;z
z0B4dsESA0xp;QLc0gdD-Bn!zkY4CuwH%5^pv4TJF#~|>#zJh$KN79hHP;<csEMJxd
z70j6cYh&YCg(s*NYF9`Vn2I@ydYIVekNt*N`6CAo7lsP?+#0KpEu@B!YvHz4OqVU#
ttFp-9jln@Vb$D|yh1MhsmllSHhKJS;tt_lYEK3Df45x)!auA%d{~vKT4h8@K

literal 0
HcmV?d00001

diff --git a/myvenv/Lib/site-packages/dateutil/__init__.py b/myvenv/Lib/site-packages/dateutil/__init__.py
new file mode 100644
index 0000000..0defb82
--- /dev/null
+++ b/myvenv/Lib/site-packages/dateutil/__init__.py
@@ -0,0 +1,8 @@
+# -*- coding: utf-8 -*-
+try:
+    from ._version import version as __version__
+except ImportError:
+    __version__ = 'unknown'
+
+__all__ = ['easter', 'parser', 'relativedelta', 'rrule', 'tz',
+           'utils', 'zoneinfo']
diff --git a/myvenv/Lib/site-packages/dateutil/__pycache__/__init__.cpython-39.pyc b/myvenv/Lib/site-packages/dateutil/__pycache__/__init__.cpython-39.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..2116d03bccfe1601a5214af3226f1695981fc0e8
GIT binary patch
literal 390
zcmYjNO-lnY5KXpScWEv3<k^$3hxG$IiHKl52qJ>0xCBCMrX}5MvLx9p?Vs>Jc=Ipi
z;Kh?5c=u#h6nw+X@L)dP3>%FGDB$zygTIFS){*~6133+D4?|dwIpSEN3KtPZ_egE^
z5%g9&7<I;@B6>h7+DCK5d(XJ&^ZpIW;&&WcGwhQVj1^k>q*0~POO++X1~BWu_>Gzw
z3#J$ukj#k|I7r8e*qBCwkKEeFjT6!q=~^ogYNoHU*r)V&q=~``Kcs)0Qa`+?YHi%P
zG1~ZqQYIy(FUSl-<xluhXGi2VEVX1J=E5<#eFus+%8?1!(&?I98@+(3vt*_Xn?t^+
zt7&eRkUM6}{D4%e7F0_v#Uru8L0+?I8R{(I%t5Djk5Zw8qja}k`SiHbJe+gViM8Eh
LBRs~Nco2O9Gw*ck

literal 0
HcmV?d00001

diff --git a/myvenv/Lib/site-packages/dateutil/__pycache__/_common.cpython-39.pyc b/myvenv/Lib/site-packages/dateutil/__pycache__/_common.cpython-39.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..a8a0efb79406a94fb63faf5944cffc50269903c2
GIT binary patch
literal 1450
zcmZux&u`N(6t<nTO+#0Pn9zVrLHvqP2V6KHgqQ|{0~Ev<6Hz29i@hytniSjJv?`p~
zoqqu&F8h~q<%-0e1LD18-CDqt?dSL{@B6;@HR0TxOJMx`{6l=R2>FhO>0!g+F-*M(
ziy%IEMg$e?kO(H}C(CETS|gr4zUi)HgF%*dqD;unNK4U))6QU&n0T1T&L9(`MCv6s
zg4fIpC|VU*g+LOYLJ=mQ$TssWaaLHuKBT@aYNCEf{F-P82ll#X3K#Z<I3rrHJ7P|>
zVQ&fsaOR7~zLb3t9uzd~MOb1oFlI1UVCs2Ta+(uPat14uUL!}ecf=Hh8-;nERoGf4
zTc=Nsh^oWIuffWLU|mb4gD3HJY{I1TPNrg%n&64leUlA?*DBkUk<r0crowI6-5n01
zuHKhj6Y75VUNAV=lj&aYBHj#iY-D#BMt#WBfe4KpnK-$_qf*qR;X&bW9;dP4ya~lM
zwuR6-9nT*VU7B1+h<Y+G#?+E+2LfcfOZrT;bKshjFL-7-{R*-ndxiRVR!O~Ravmk2
z)|{8@J*H}KTi%rtR7(S%A-X6`63*w~q){J2U23ywd{x3f_#DVB@jZlKd=>HK6fj!)
z62uf@+P73^11zydHb}Z)6T=SfQ-Xi*%cpn2jnH<hxB3>apY*P1FB_xc&5@B$mC6+K
z6$uoz%<M?@H-$Rq@&o7RAw#!dA(YWYAkm@@9k)+q#-s>qOa{g%TS)>fWk6T}4#IA+
zPXPK@)WY5g_0B0gk5+o3TC-AO9_N?gxkhymiB0X_(_&UB|A={FZTwZ|AY`AlCT*>1
zAhrKcPbKG9;7XVFnIVi<GlVhagzybGh|*OT$w%C&UdVy809WB@i(LQ!=q>1v*YMfP
zS3Y~Y?z4@jus`?N>KmV}EyG+NH?Hej*KZ3?p=XcnR#5#nTriuGL&f<u1Y9ZP!jECr
zZdHm$d!CE-Ov3^2C|u5~ZxO^T&OeO8<oE{Mu9M85+wqkO6;y3pu&3%AE@+M^G-c<|
z|7BD0r12jd>M+-K>W%}m@?#IaBMr_)7D3&5wu#?`$_c04KY3f>JghK2LTi;Bv1@+-
D-C`ry

literal 0
HcmV?d00001

diff --git a/myvenv/Lib/site-packages/dateutil/__pycache__/_version.cpython-39.pyc b/myvenv/Lib/site-packages/dateutil/__pycache__/_version.cpython-39.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..5ff2b9df37e2b5bca0df8ac3220ba68b3334befe
GIT binary patch
literal 256
zcmYe~<>g`kg7^JzQu=`OV-N=!FakLaKwQiNBvKfn7*ZIc7*m*n88n%zSdH{7^o%r_
zUorvZUUC45B9L-FO{QDyWvNBQnfZB9yii7bNohe&>Pm(p7LYO!@hi{SDkiiTs4m7O
zGd;5;F-IXRH7}(!uO!ALwK%&ZzaS={C_gJTxuiHIEx#x+JykcWAU9dJxI9(2B(XSK
z*DxlxvMe>PEXF4@DW*8HBvrQ{F*zHkt~e$ou_U#$Br``p9%{W_LFFwDo80`A(wtN~
MknP1FH?uGT0P7Y=CjbBd

literal 0
HcmV?d00001

diff --git a/myvenv/Lib/site-packages/dateutil/__pycache__/easter.cpython-39.pyc b/myvenv/Lib/site-packages/dateutil/__pycache__/easter.cpython-39.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..0a9b8e7be02815a33ab60240b0e1096921010f6c
GIT binary patch
literal 2220
zcmZ`*UvCpf5WhX2|HMg1T0#;6r7Oe(sT?OEP?ZQMR+7?EAe02CEKBjmyRk36+jDpK
z;uxJ@N+0?}`w`l{^()<LpDb1Cd!IUUXFEZtce?TJ?96XwXJ=;3rl*S*JpcUiH$Q>V
zUpP7cWMJ|TKD`EnTUCn_ZhNFknikLeL8>-)su`ZGIy_g+itG{Ld0zO5RCC<kvz8~`
zoEG<6uBLv#Lr>7)=tw9{8EpzFl-r;?OdFwSBk((+ab=VG!n6WTj{-%R?9rxsA|&kz
zrb;x_AW(cQP(zmJu0qM+l!EBv&~urj%xeb9H7#G4iv#f2dbaGuIg!|ir*|rQ`#UcV
z9>09@P32iUGo0?e*#CNWd-wbJ!jSQL2gRNZ2<Q)NBp8DRjz-TE4D#@8!KaTwkdufw
zR>o=*HOK8X(buF+ECV5WOMWDg)wd%E)V$S)Q1zV%LfE#{uiS|;a~97nSUeAF*$AZy
zOV)xFWq~&Vyd20D+qQbgCqd8VQ*B4Ri*PiJa{R)gm5y<Qx{Frdkw2%rem;UX<?@**
z54L7O=OdI#ZNqG2y%536KVHJUq`w#8mn>LI7U<1I8PK_e<Hh9rz}q5tod<6cdt>jj
zQ4V;{g4Le@+zCDpQWJau))y21FVDj+`bBO7cL}(8<n|{G`OP+&$bL(JPA0VYmi(T9
zl)A!lj%5`oJZWa73Daeob^>Jt<c<n_YFdJJ1J$NHkb)le=%c5!qKqyjnt`My=s-Fq
za^ti?xh;={n(haZLxRd?iFR9VqeTHf(L7`tOt_MEm@*V`z|a{0Ant}76Zz))-P>!+
zB|6mmAq>zrP`ti#+VPlVCQv=P7j`<H@P#zsP=Zy_Mg=nP-3Id#ixtlY>BjXEeO{*Y
zTOlRvnC=Oe3tWLp5Znc@a`7xEXAZgk5MKkj5`uCUYY+{lwU;P?tw!iE<HCm03e=k^
z+<F-b&274pdGx##Y-Ct;z!j2Xfu1nW#Vsa~a6X(F0mXiV6~1xnb6VL>R&JexOpQU1
zp=uL(Xa({_B<BbLd87nZG#f*HXe?<Cny%mZVgo~Xd+qMs#L7mQz7Quap4P|+_&f&0
z&HRts*lpeighQlV;d!G73oS-rqD%>@L`MNn;t4|vVM@R@v|-YW;`kY@*WYVE5TE;W
zy<Sh8J-0gQN3eS9!_{GPLfs8mO_cY+92Z9{^vtMzV#iJEVq=&VPXq9i9R?vJ+It!6
zvmQMZ&~QV^DKo=kuMf**bJU?L<JL;=wT$U(uC8{w-Ez~1GSKBfHCJ7znA38n)%mg+
z+`qkk=Ry4-^^ZxO4(jOX)-dk$tIBs{^aN55G0mv<%DlbWz;axL!&*(-I2srus~j|7
zRRHqlf-BSXOZPpvh$~48pMlZf8WQLm)&TpqLNdUM&wU6G1CG;KB#1SbMsgX+RV1Gv
zxrAgA$rU7McyJTRr%0B7z*SRx#k^4LC>5x<fZ1<cU&IcM;*2ZJ@>J|#cE!2W%b4_H
z(u|3Si5rvSm^5P2ib*FXJSP61mRbSaf4!~E+Di@hW^Ee^(Lf=-g3Jx2scj40hCWt%
zu7YFHFuDfUCToh7<Bs20(Ot1(m~OAE*Zdybq9?T{?qN;4MyzyLqYZMphMvK_dluZD
z!g~%wp>cQCjd@a-a!7%|XU~#3pg6mpDUcFbBR8BWa+S=IL~A)8=MN5e&^S0y7;l_0
p&x09WpbDd}vPjTGvbA%h47|8-Fa4kJ03|fuvQD;Oqe*x({{cESS+xKF

literal 0
HcmV?d00001

diff --git a/myvenv/Lib/site-packages/dateutil/__pycache__/relativedelta.cpython-39.pyc b/myvenv/Lib/site-packages/dateutil/__pycache__/relativedelta.cpython-39.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..70230def9465d640feedfe03c7bdb7d2270339ec
GIT binary patch
literal 14830
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

literal 0
HcmV?d00001

diff --git a/myvenv/Lib/site-packages/dateutil/__pycache__/rrule.cpython-39.pyc b/myvenv/Lib/site-packages/dateutil/__pycache__/rrule.cpython-39.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..8bb01dcd622deee87a3e533c2dc38e8e0d17949b
GIT binary patch
literal 43412
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
Hec=BBKIBWC

literal 0
HcmV?d00001

diff --git a/myvenv/Lib/site-packages/dateutil/__pycache__/tzwin.cpython-39.pyc b/myvenv/Lib/site-packages/dateutil/__pycache__/tzwin.cpython-39.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..4d7ebfa2a4b2739a98479eee7cf5225ae1ef26ae
GIT binary patch
literal 221
zcmYe~<>g`kg7^JzQmldWV-N=!FabFZKwQiNBvKes7;_jx7*d#m88n$+G6ID(8E-La
z`Drpnv6WQmm1pLyWGG?=3WJGX+0Irmp~b01#W60K>6s;oISOH^c`2oNB{43k#n~nK
z1u+3d`B|ySCB-pm`9+E8sk&JOxyic4<*B+QiN)EvhB3L7WvO{(F+Q0|F~ylBsk#M;
q$=N`4#W5*~C8?z)nK}9;RX|(y3My}L*yQG?l;)(`ft>sqh#3HN^*%fR

literal 0
HcmV?d00001

diff --git a/myvenv/Lib/site-packages/dateutil/__pycache__/utils.cpython-39.pyc b/myvenv/Lib/site-packages/dateutil/__pycache__/utils.cpython-39.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..599e9ea24e7b6eef5266b114e853aab2245728e0
GIT binary patch
literal 2289
zcmbVO&2L*p5Pu(bVqViyi3^ujtAf-#sErdqAPb_RlpCrLNjX@S?DgBVz0LbDyZhog
za!>SH@h`Lzmmc_s-jx#)5_eAgX8n=63Ke1%uXoq8GqW?l`Azus>yd}?*DrsH-*!Fk
zciOx@LTv8iV~#Khuj>h41gW0|-N2`Hn1)%{4YOLehW#~B7dy}VZe8q(#xt+GBi<1a
zzIR3K#EbVXOmsR?hGm5)Q^|_aNNU5zGMAdCEGhDHnJbwmlJQ)y(yCP1IUALEVpWkF
zHYzj|lBX&kvzfA!NN_8y%A{#UQLDwyp$>vv2q`)pcG&u&)sFsv<6i7nH_Kclg^+zH
zC3_|gs>WJDRU<VI6Q6`vBfvL8;vM5-?qIUs3xDCg^q=}z1q=U0_|mgAfin?24_*d%
zV#sepMZ_?EkhautnzPPy-bqq!OlPpRH(**$wKOuf^cXvlEGf0dmI*#*+_FrGT#Y9-
za>_bWu6f4ng~~@o#~qQ4Q`{rR*+r3KRp6rK$%O6Wc?Bzt6m%#g9-JwX*tQcRY^0{6
zov)XAzq!ii)}`~s@UcwnTi>wp@wK<K+@Yo*zw)b{<!j=)CXiKOUd*c9q{xQww5pLY
zUBeG?pm*r^K-gEFzJ}%BXUCo1BZFl39;mUhz|M~{7iDgH52QJ>#kBXmF33aE17!GE
zHXl#3q-kcdX}LLT9`v#~pmyH-P7QkoaA;0>at1lmBeMj&PiQi&>Ab4j0x7u;yN2BH
z_99=?E+KrZ2d(K94lB2@Sa^?79;L5uEW8ui`3n@zbN>XV4ky1t+=b&rTH_Kk7%T%a
z7%-P@${H(jmUDG30gDyXag@%Nd2_{tdP1T{W$Ma9KH=FEwKbc_oXv}paV^<Y7v~B!
z!T3fEEK*{CwFy6$&Jl@<f<>M)1r;h$mZ9F{lht~IvwO^xz!*16Bk<J_hWRBDojPMR
zj#mgnaf%|b(%4RC={w=>=;(-zbdfo)DBvx7LB<Ph0d>%Wk=E(DT9_=u;nfAVdyBM7
z=vr9F5ie8QUq*cEmKeEn_Vvbv{X5^DoZh*|ng?ID+wFKudWuKd{cUyo&XxVUhwX#U
zn(YJpv4g|Tr)~D=^!RRkkF6}kmzv&`?6lh-x7(Qix2^wdr`i6T>^MU!mJ#-n35a3V
z&?7L;CJMO+ser#y4yGnb*+64U%~fP|1r;LaL}~+|YUo&!soYpjU4RJ97&XqZ+C*Y7
z5Edn(MqoK~391HcVg|UP6kM_V8?9|9IcI!Eg>jWT>(>sJZ1qsrQO;`;+Fd;xd+M8x
znH(oAr#+liH@4Am3ulHH%)1r&wLrg%Rf6K*3}O}9ALC;_!eqTg@U#CkSa=KneeY?w
z2(EdHum+(szxZ$woPj|C&j+u>{zdKr12$YU02mbbb6sTy?%&YHR>7lMb2(1Io<op@
zP}GU3@j7J)`w;yI9T%jbK^yX?lBdgXppk}rXyRHo6!w6o!>TT1YIzl1s(CXcd(^E}
z-gkoc>76bh^@iW@^?TUI{=>LY?e_a%iGII|`u$Of_9^>)P1Nc-gzE;5dR+|Nz1Iv;
dXV5MIjjxvfU>wm^LwTz0>;*T&=w{=Ce*hHNepUbg

literal 0
HcmV?d00001

diff --git a/myvenv/Lib/site-packages/dateutil/_common.py b/myvenv/Lib/site-packages/dateutil/_common.py
new file mode 100644
index 0000000..4eb2659
--- /dev/null
+++ b/myvenv/Lib/site-packages/dateutil/_common.py
@@ -0,0 +1,43 @@
+"""
+Common code used in multiple modules.
+"""
+
+
+class weekday(object):
+    __slots__ = ["weekday", "n"]
+
+    def __init__(self, weekday, n=None):
+        self.weekday = weekday
+        self.n = n
+
+    def __call__(self, n):
+        if n == self.n:
+            return self
+        else:
+            return self.__class__(self.weekday, n)
+
+    def __eq__(self, other):
+        try:
+            if self.weekday != other.weekday or self.n != other.n:
+                return False
+        except AttributeError:
+            return False
+        return True
+
+    def __hash__(self):
+        return hash((
+          self.weekday,
+          self.n,
+        ))
+
+    def __ne__(self, other):
+        return not (self == other)
+
+    def __repr__(self):
+        s = ("MO", "TU", "WE", "TH", "FR", "SA", "SU")[self.weekday]
+        if not self.n:
+            return s
+        else:
+            return "%s(%+d)" % (s, self.n)
+
+# vim:ts=4:sw=4:et
diff --git a/myvenv/Lib/site-packages/dateutil/_version.py b/myvenv/Lib/site-packages/dateutil/_version.py
new file mode 100644
index 0000000..b723056
--- /dev/null
+++ b/myvenv/Lib/site-packages/dateutil/_version.py
@@ -0,0 +1,5 @@
+# coding: utf-8
+# file generated by setuptools_scm
+# don't change, don't track in version control
+version = '2.8.2'
+version_tuple = (2, 8, 2)
diff --git a/myvenv/Lib/site-packages/dateutil/easter.py b/myvenv/Lib/site-packages/dateutil/easter.py
new file mode 100644
index 0000000..f74d1f7
--- /dev/null
+++ b/myvenv/Lib/site-packages/dateutil/easter.py
@@ -0,0 +1,89 @@
+# -*- coding: utf-8 -*-
+"""
+This module offers a generic Easter computing method for any given year, using
+Western, Orthodox or Julian algorithms.
+"""
+
+import datetime
+
+__all__ = ["easter", "EASTER_JULIAN", "EASTER_ORTHODOX", "EASTER_WESTERN"]
+
+EASTER_JULIAN = 1
+EASTER_ORTHODOX = 2
+EASTER_WESTERN = 3
+
+
+def easter(year, method=EASTER_WESTERN):
+    """
+    This method was ported from the work done by GM Arts,
+    on top of the algorithm by Claus Tondering, which was
+    based in part on the algorithm of Ouding (1940), as
+    quoted in "Explanatory Supplement to the Astronomical
+    Almanac", P.  Kenneth Seidelmann, editor.
+
+    This algorithm implements three different Easter
+    calculation methods:
+
+    1. Original calculation in Julian calendar, valid in
+       dates after 326 AD
+    2. Original method, with date converted to Gregorian
+       calendar, valid in years 1583 to 4099
+    3. Revised method, in Gregorian calendar, valid in
+       years 1583 to 4099 as well
+
+    These methods are represented by the constants:
+
+    * ``EASTER_JULIAN   = 1``
+    * ``EASTER_ORTHODOX = 2``
+    * ``EASTER_WESTERN  = 3``
+
+    The default method is method 3.
+
+    More about the algorithm may be found at:
+
+    `GM Arts: Easter Algorithms <http://www.gmarts.org/index.php?go=415>`_
+
+    and
+
+    `The Calendar FAQ: Easter <https://www.tondering.dk/claus/cal/easter.php>`_
+
+    """
+
+    if not (1 <= method <= 3):
+        raise ValueError("invalid method")
+
+    # g - Golden year - 1
+    # c - Century
+    # h - (23 - Epact) mod 30
+    # i - Number of days from March 21 to Paschal Full Moon
+    # j - Weekday for PFM (0=Sunday, etc)
+    # p - Number of days from March 21 to Sunday on or before PFM
+    #     (-6 to 28 methods 1 & 3, to 56 for method 2)
+    # e - Extra days to add for method 2 (converting Julian
+    #     date to Gregorian date)
+
+    y = year
+    g = y % 19
+    e = 0
+    if method < 3:
+        # Old method
+        i = (19*g + 15) % 30
+        j = (y + y//4 + i) % 7
+        if method == 2:
+            # Extra dates to convert Julian to Gregorian date
+            e = 10
+            if y > 1600:
+                e = e + y//100 - 16 - (y//100 - 16)//4
+    else:
+        # New method
+        c = y//100
+        h = (c - c//4 - (8*c + 13)//25 + 19*g + 15) % 30
+        i = h - (h//28)*(1 - (h//28)*(29//(h + 1))*((21 - g)//11))
+        j = (y + y//4 + i + 2 - c + c//4) % 7
+
+    # p can be from -6 to 56 corresponding to dates 22 March to 23 May
+    # (later dates apply to method 2, although 23 May never actually occurs)
+    p = i - j + e
+    d = 1 + (p + 27 + (p + 6)//40) % 31
+    m = 3 + (p + 26)//30
+    return datetime.date(int(y), int(m), int(d))
diff --git a/myvenv/Lib/site-packages/dateutil/parser/__init__.py b/myvenv/Lib/site-packages/dateutil/parser/__init__.py
new file mode 100644
index 0000000..d174b0e
--- /dev/null
+++ b/myvenv/Lib/site-packages/dateutil/parser/__init__.py
@@ -0,0 +1,61 @@
+# -*- coding: utf-8 -*-
+from ._parser import parse, parser, parserinfo, ParserError
+from ._parser import DEFAULTPARSER, DEFAULTTZPARSER
+from ._parser import UnknownTimezoneWarning
+
+from ._parser import __doc__
+
+from .isoparser import isoparser, isoparse
+
+__all__ = ['parse', 'parser', 'parserinfo',
+           'isoparse', 'isoparser',
+           'ParserError',
+           'UnknownTimezoneWarning']
+
+
+###
+# Deprecate portions of the private interface so that downstream code that
+# is improperly relying on it is given *some* notice.
+
+
+def __deprecated_private_func(f):
+    from functools import wraps
+    import warnings
+
+    msg = ('{name} is a private function and may break without warning, '
+           'it will be moved and or renamed in future versions.')
+    msg = msg.format(name=f.__name__)
+
+    @wraps(f)
+    def deprecated_func(*args, **kwargs):
+        warnings.warn(msg, DeprecationWarning)
+        return f(*args, **kwargs)
+
+    return deprecated_func
+
+def __deprecate_private_class(c):
+    import warnings
+
+    msg = ('{name} is a private class and may break without warning, '
+           'it will be moved and or renamed in future versions.')
+    msg = msg.format(name=c.__name__)
+
+    class private_class(c):
+        __doc__ = c.__doc__
+
+        def __init__(self, *args, **kwargs):
+            warnings.warn(msg, DeprecationWarning)
+            super(private_class, self).__init__(*args, **kwargs)
+
+    private_class.__name__ = c.__name__
+
+    return private_class
+
+
+from ._parser import _timelex, _resultbase
+from ._parser import _tzparser, _parsetz
+
+_timelex = __deprecate_private_class(_timelex)
+_tzparser = __deprecate_private_class(_tzparser)
+_resultbase = __deprecate_private_class(_resultbase)
+_parsetz = __deprecated_private_func(_parsetz)
diff --git a/myvenv/Lib/site-packages/dateutil/parser/__pycache__/__init__.cpython-39.pyc b/myvenv/Lib/site-packages/dateutil/parser/__pycache__/__init__.cpython-39.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..346e925b7cb9e497d45f90711e64876b925b8171
GIT binary patch
literal 2094
zcmb_dOK&4Z5bo|7+vCKqWMSD|1PlTp4C^d#1FcrOkicaXMVkbqk)_te-8K`?!*q`m
zVv<uL**O3gegGgYk@!V@MM7E$i908%dhAWY<AB7Bx~jUnrn??rO@;OP5`pLUZ+{cN
zmI?U<Cs!W^lZP<$&p-qbG$siRXu<-PIDwP6flG0n!FnkuCFP)O=MKy(LB+~0$X?)C
zxfEBEYEVs<f+b1@M3jG|!Lq0b?~DXBQ58$T>u}yOeA5UTNi%5L?`kk_1+8QySfNDL
zW#g0v4d5-{E#OVyO<9vGz*j_lo3tBGDVW@LO=%P=Elt@nWtIvarTxq-Z{e2OP%2Yx
zX6ox3A3xfCytDP_$@az*)0|Itf?}af&CT6(m}ZCRPL#+=mdejUl}70Rb}F2Utj9SV
zQ;l>szsy^R?TW%sDhG*+WElwtUzLz}KzeBL;z3PRM6N#sBB+frJ)sa0DoD)EnQ+eO
zjP5%#vhND_YkE$P>5QDxDVfqK>pP+(%4gmwJz>WTVp7?B3I`D|w{)n&k)C8<rC}mZ
z{7CzuKT^>_m`lGuPJ4NjrGA(SKM9ZgJtf1Te;DPTXXD&IEPTG}M<7RW?C(iG$quBj
z`kC^T#6yK2rEpX}R?<I^O2dJA?SdK?H+yKt;=#b6r?0@!cYw^;_hd$M`U9h6Mvh5D
zj_FVI8@f#{=q3c%MH9^Gx*RFl3(?d?9$+t218vGfP#Ne8$I!lU5<M{9+-!Y8{uqDs
zL3bDOuDk2eAj-qo|5T=8oaWtisfT$s>TaoQU-oj{?Pn?+$j<&K>2>s>?Bt;ycHZqK
zM+Y)J=su42x;n~bXB75^pr^Y60yxg2_+9~kdz?pUlykl|Ix<Z$H&_aeF@6dCMaK!N
z(aC!Npv(PvF09_#{W$A|v3{_2MF9_JmrT_rE6ZZ7>Tr;{1;muW>LkpK$2kTYK<TKP
zxNB8jMCmq?=aFE*&Fz1^9CdU92%$CVF_$%1nXbADlXVTRh+Rao#p^>5EJn$>Bbdb~
z;Bp`EiWvQb6!@GveL$@!oq3`JsCCX6>dY920cb66sv4X#iT??ty*ShW+W#G)3Vpo>
zPncVHBG+#MktBff3)pv1c!2}1u&Fb3!4)XbGcRzbpdOUK0cY~gmALXnPOa&eNximw
zEu<LAXNB<wOlHnyVdM~`V{*#&ons0G!mvQ_SGi483sl>#S^=h3ftZpWkEB986liQa
z#?><Js~f2DoK-hf&aGvfs~7O2`ZdEWvI^KBV$`cZ)?gF>25d~;|F6ETJu|1QUd9`j
zI8QP$jsdZz#`zcHFfQ<`s*5X4eQsq>#xYomIKFTV?OB`E>!^n{(5C7&l&!6}`Zf$}
zt4GVs>OoPUrou9`_ro`Blx=NbqW@kS*K>&HYJ@16SH_)+$JAReho6+kb7&H={L(CQ
zCG|MY_d+ePJ@9<8Xb;>9`DC-b3LT_a{cEGJ?E!i-Q57WED2jO4=7DVln@?!NfmLY@
xQ0T9^i==}DQ&l)-y|cttzIVR}`2+k5+rRHE+M+d9V=d+_drj{~i-JV){Sz3=6a@eP

literal 0
HcmV?d00001

diff --git a/myvenv/Lib/site-packages/dateutil/parser/__pycache__/_parser.cpython-39.pyc b/myvenv/Lib/site-packages/dateutil/parser/__pycache__/_parser.cpython-39.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..b529a84843028060717e1d20006f304a0cb11cc8
GIT binary patch
literal 40589
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

literal 0
HcmV?d00001

diff --git a/myvenv/Lib/site-packages/dateutil/parser/__pycache__/isoparser.cpython-39.pyc b/myvenv/Lib/site-packages/dateutil/parser/__pycache__/isoparser.cpython-39.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..72f3e90d0c44b3c4e381ad8dcee2879c14c1420f
GIT binary patch
literal 11339
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
CN|Lt#

literal 0
HcmV?d00001

diff --git a/myvenv/Lib/site-packages/dateutil/parser/_parser.py b/myvenv/Lib/site-packages/dateutil/parser/_parser.py
new file mode 100644
index 0000000..37d1663
--- /dev/null
+++ b/myvenv/Lib/site-packages/dateutil/parser/_parser.py
@@ -0,0 +1,1613 @@
+# -*- coding: utf-8 -*-
+"""
+This module offers a generic date/time string parser which is able to parse
+most known formats to represent a date and/or time.
+
+This module attempts to be forgiving with regards to unlikely input formats,
+returning a datetime object even for dates which are ambiguous. If an element
+of a date/time stamp is omitted, the following rules are applied:
+
+- If AM or PM is left unspecified, a 24-hour clock is assumed, however, an hour
+  on a 12-hour clock (``0 <= hour <= 12``) *must* be specified if AM or PM is
+  specified.
+- If a time zone is omitted, a timezone-naive datetime is returned.
+
+If any other elements are missing, they are taken from the
+:class:`datetime.datetime` object passed to the parameter ``default``. If this
+results in a day number exceeding the valid number of days per month, the
+value falls back to the end of the month.
+
+Additional resources about date/time string formats can be found below:
+
+- `A summary of the international standard date and time notation
+  <https://www.cl.cam.ac.uk/~mgk25/iso-time.html>`_
+- `W3C Date and Time Formats <https://www.w3.org/TR/NOTE-datetime>`_
+- `Time Formats (Planetary Rings Node) <https://pds-rings.seti.org:443/tools/time_formats.html>`_
+- `CPAN ParseDate module
+  <https://metacpan.org/pod/release/MUIR/Time-modules-2013.0912/lib/Time/ParseDate.pm>`_
+- `Java SimpleDateFormat Class
+  <https://docs.oracle.com/javase/6/docs/api/java/text/SimpleDateFormat.html>`_
+"""
+from __future__ import unicode_literals
+
+import datetime
+import re
+import string
+import time
+import warnings
+
+from calendar import monthrange
+from io import StringIO
+
+import six
+from six import integer_types, text_type
+
+from decimal import Decimal
+
+from warnings import warn
+
+from .. import relativedelta
+from .. import tz
+
+__all__ = ["parse", "parserinfo", "ParserError"]
+
+
+# TODO: pandas.core.tools.datetimes imports this explicitly.  Might be worth
+# making public and/or figuring out if there is something we can
+# take off their plate.
+class _timelex(object):
+    # Fractional seconds are sometimes split by a comma
+    _split_decimal = re.compile("([.,])")
+
+    def __init__(self, instream):
+        if isinstance(instream, (bytes, bytearray)):
+            instream = instream.decode()
+
+        if isinstance(instream, text_type):
+            instream = StringIO(instream)
+        elif getattr(instream, 'read', None) is None:
+            raise TypeError('Parser must be a string or character stream, not '
+                            '{itype}'.format(itype=instream.__class__.__name__))
+
+        self.instream = instream
+        self.charstack = []
+        self.tokenstack = []
+        self.eof = False
+
+    def get_token(self):
+        """
+        This function breaks the time string into lexical units (tokens), which
+        can be parsed by the parser. Lexical units are demarcated by changes in
+        the character set, so any continuous string of letters is considered
+        one unit, any continuous string of numbers is considered one unit.
+
+        The main complication arises from the fact that dots ('.') can be used
+        both as separators (e.g. "Sep.20.2009") or decimal points (e.g.
+        "4:30:21.447"). As such, it is necessary to read the full context of
+        any dot-separated strings before breaking it into tokens; as such, this
+        function maintains a "token stack", for when the ambiguous context
+        demands that multiple tokens be parsed at once.
+        """
+        if self.tokenstack:
+            return self.tokenstack.pop(0)
+
+        seenletters = False
+        token = None
+        state = None
+
+        while not self.eof:
+            # We only realize that we've reached the end of a token when we
+            # find a character that's not part of the current token - since
+            # that character may be part of the next token, it's stored in the
+            # charstack.
+            if self.charstack:
+                nextchar = self.charstack.pop(0)
+            else:
+                nextchar = self.instream.read(1)
+                while nextchar == '\x00':
+                    nextchar = self.instream.read(1)
+
+            if not nextchar:
+                self.eof = True
+                break
+            elif not state:
+                # First character of the token - determines if we're starting
+                # to parse a word, a number or something else.
+                token = nextchar
+                if self.isword(nextchar):
+                    state = 'a'
+                elif self.isnum(nextchar):
+                    state = '0'
+                elif self.isspace(nextchar):
+                    token = ' '
+                    break  # emit token
+                else:
+                    break  # emit token
+            elif state == 'a':
+                # If we've already started reading a word, we keep reading
+                # letters until we find something that's not part of a word.
+                seenletters = True
+                if self.isword(nextchar):
+                    token += nextchar
+                elif nextchar == '.':
+                    token += nextchar
+                    state = 'a.'
+                else:
+                    self.charstack.append(nextchar)
+                    break  # emit token
+            elif state == '0':
+                # If we've already started reading a number, we keep reading
+                # numbers until we find something that doesn't fit.
+                if self.isnum(nextchar):
+                    token += nextchar
+                elif nextchar == '.' or (nextchar == ',' and len(token) >= 2):
+                    token += nextchar
+                    state = '0.'
+                else:
+                    self.charstack.append(nextchar)
+                    break  # emit token
+            elif state == 'a.':
+                # If we've seen some letters and a dot separator, continue
+                # parsing, and the tokens will be broken up later.
+                seenletters = True
+                if nextchar == '.' or self.isword(nextchar):
+                    token += nextchar
+                elif self.isnum(nextchar) and token[-1] == '.':
+                    token += nextchar
+                    state = '0.'
+                else:
+                    self.charstack.append(nextchar)
+                    break  # emit token
+            elif state == '0.':
+                # If we've seen at least one dot separator, keep going, we'll
+                # break up the tokens later.
+                if nextchar == '.' or self.isnum(nextchar):
+                    token += nextchar
+                elif self.isword(nextchar) and token[-1] == '.':
+                    token += nextchar
+                    state = 'a.'
+                else:
+                    self.charstack.append(nextchar)
+                    break  # emit token
+
+        if (state in ('a.', '0.') and (seenletters or token.count('.') > 1 or
+                                       token[-1] in '.,')):
+            l = self._split_decimal.split(token)
+            token = l[0]
+            for tok in l[1:]:
+                if tok:
+                    self.tokenstack.append(tok)
+
+        if state == '0.' and token.count('.') == 0:
+            token = token.replace(',', '.')
+
+        return token
+
+    def __iter__(self):
+        return self
+
+    def __next__(self):
+        token = self.get_token()
+        if token is None:
+            raise StopIteration
+
+        return token
+
+    def next(self):
+        return self.__next__()  # Python 2.x support
+
+    @classmethod
+    def split(cls, s):
+        return list(cls(s))
+
+    @classmethod
+    def isword(cls, nextchar):
+        """ Whether or not the next character is part of a word """
+        return nextchar.isalpha()
+
+    @classmethod
+    def isnum(cls, nextchar):
+        """ Whether the next character is part of a number """
+        return nextchar.isdigit()
+
+    @classmethod
+    def isspace(cls, nextchar):
+        """ Whether the next character is whitespace """
+        return nextchar.isspace()
+
+
+class _resultbase(object):
+
+    def __init__(self):
+        for attr in self.__slots__:
+            setattr(self, attr, None)
+
+    def _repr(self, classname):
+        l = []
+        for attr in self.__slots__:
+            value = getattr(self, attr)
+            if value is not None:
+                l.append("%s=%s" % (attr, repr(value)))
+        return "%s(%s)" % (classname, ", ".join(l))
+
+    def __len__(self):
+        return (sum(getattr(self, attr) is not None
+                    for attr in self.__slots__))
+
+    def __repr__(self):
+        return self._repr(self.__class__.__name__)
+
+
+class parserinfo(object):
+    """
+    Class which handles what inputs are accepted. Subclass this to customize
+    the language and acceptable values for each parameter.
+
+    :param dayfirst:
+        Whether to interpret the first value in an ambiguous 3-integer date
+        (e.g. 01/05/09) as the day (``True``) or month (``False``). If
+        ``yearfirst`` is set to ``True``, this distinguishes between YDM
+        and YMD. Default is ``False``.
+
+    :param yearfirst:
+        Whether to interpret the first value in an ambiguous 3-integer date
+        (e.g. 01/05/09) as the year. If ``True``, the first number is taken
+        to be the year, otherwise the last number is taken to be the year.
+        Default is ``False``.
+    """
+
+    # m from a.m/p.m, t from ISO T separator
+    JUMP = [" ", ".", ",", ";", "-", "/", "'",
+            "at", "on", "and", "ad", "m", "t", "of",
+            "st", "nd", "rd", "th"]
+
+    WEEKDAYS = [("Mon", "Monday"),
+                ("Tue", "Tuesday"),     # TODO: "Tues"
+                ("Wed", "Wednesday"),
+                ("Thu", "Thursday"),    # TODO: "Thurs"
+                ("Fri", "Friday"),
+                ("Sat", "Saturday"),
+                ("Sun", "Sunday")]
+    MONTHS = [("Jan", "January"),
+              ("Feb", "February"),      # TODO: "Febr"
+              ("Mar", "March"),
+              ("Apr", "April"),
+              ("May", "May"),
+              ("Jun", "June"),
+              ("Jul", "July"),
+              ("Aug", "August"),
+              ("Sep", "Sept", "September"),
+              ("Oct", "October"),
+              ("Nov", "November"),
+              ("Dec", "December")]
+    HMS = [("h", "hour", "hours"),
+           ("m", "minute", "minutes"),
+           ("s", "second", "seconds")]
+    AMPM = [("am", "a"),
+            ("pm", "p")]
+    UTCZONE = ["UTC", "GMT", "Z", "z"]
+    PERTAIN = ["of"]
+    TZOFFSET = {}
+    # TODO: ERA = ["AD", "BC", "CE", "BCE", "Stardate",
+    #              "Anno Domini", "Year of Our Lord"]
+
+    def __init__(self, dayfirst=False, yearfirst=False):
+        self._jump = self._convert(self.JUMP)
+        self._weekdays = self._convert(self.WEEKDAYS)
+        self._months = self._convert(self.MONTHS)
+        self._hms = self._convert(self.HMS)
+        self._ampm = self._convert(self.AMPM)
+        self._utczone = self._convert(self.UTCZONE)
+        self._pertain = self._convert(self.PERTAIN)
+
+        self.dayfirst = dayfirst
+        self.yearfirst = yearfirst
+
+        self._year = time.localtime().tm_year
+        self._century = self._year // 100 * 100
+
+    def _convert(self, lst):
+        dct = {}
+        for i, v in enumerate(lst):
+            if isinstance(v, tuple):
+                for v in v:
+                    dct[v.lower()] = i
+            else:
+                dct[v.lower()] = i
+        return dct
+
+    def jump(self, name):
+        return name.lower() in self._jump
+
+    def weekday(self, name):
+        try:
+            return self._weekdays[name.lower()]
+        except KeyError:
+            pass
+        return None
+
+    def month(self, name):
+        try:
+            return self._months[name.lower()] + 1
+        except KeyError:
+            pass
+        return None
+
+    def hms(self, name):
+        try:
+            return self._hms[name.lower()]
+        except KeyError:
+            return None
+
+    def ampm(self, name):
+        try:
+            return self._ampm[name.lower()]
+        except KeyError:
+            return None
+
+    def pertain(self, name):
+        return name.lower() in self._pertain
+
+    def utczone(self, name):
+        return name.lower() in self._utczone
+
+    def tzoffset(self, name):
+        if name in self._utczone:
+            return 0
+
+        return self.TZOFFSET.get(name)
+
+    def convertyear(self, year, century_specified=False):
+        """
+        Converts two-digit years to year within [-50, 49]
+        range of self._year (current local time)
+        """
+
+        # Function contract is that the year is always positive
+        assert year >= 0
+
+        if year < 100 and not century_specified:
+            # assume current century to start
+            year += self._century
+
+            if year >= self._year + 50:  # if too far in future
+                year -= 100
+            elif year < self._year - 50:  # if too far in past
+                year += 100
+
+        return year
+
+    def validate(self, res):
+        # move to info
+        if res.year is not None:
+            res.year = self.convertyear(res.year, res.century_specified)
+
+        if ((res.tzoffset == 0 and not res.tzname) or
+             (res.tzname == 'Z' or res.tzname == 'z')):
+            res.tzname = "UTC"
+            res.tzoffset = 0
+        elif res.tzoffset != 0 and res.tzname and self.utczone(res.tzname):
+            res.tzoffset = 0
+        return True
+
+
+class _ymd(list):
+    def __init__(self, *args, **kwargs):
+        super(self.__class__, self).__init__(*args, **kwargs)
+        self.century_specified = False
+        self.dstridx = None
+        self.mstridx = None
+        self.ystridx = None
+
+    @property
+    def has_year(self):
+        return self.ystridx is not None
+
+    @property
+    def has_month(self):
+        return self.mstridx is not None
+
+    @property
+    def has_day(self):
+        return self.dstridx is not None
+
+    def could_be_day(self, value):
+        if self.has_day:
+            return False
+        elif not self.has_month:
+            return 1 <= value <= 31
+        elif not self.has_year:
+            # Be permissive, assume leap year
+            month = self[self.mstridx]
+            return 1 <= value <= monthrange(2000, month)[1]
+        else:
+            month = self[self.mstridx]
+            year = self[self.ystridx]
+            return 1 <= value <= monthrange(year, month)[1]
+
+    def append(self, val, label=None):
+        if hasattr(val, '__len__'):
+            if val.isdigit() and len(val) > 2:
+                self.century_specified = True
+                if label not in [None, 'Y']:  # pragma: no cover
+                    raise ValueError(label)
+                label = 'Y'
+        elif val > 100:
+            self.century_specified = True
+            if label not in [None, 'Y']:  # pragma: no cover
+                raise ValueError(label)
+            label = 'Y'
+
+        super(self.__class__, self).append(int(val))
+
+        if label == 'M':
+            if self.has_month:
+                raise ValueError('Month is already set')
+            self.mstridx = len(self) - 1
+        elif label == 'D':
+            if self.has_day:
+                raise ValueError('Day is already set')
+            self.dstridx = len(self) - 1
+        elif label == 'Y':
+            if self.has_year:
+                raise ValueError('Year is already set')
+            self.ystridx = len(self) - 1
+
+    def _resolve_from_stridxs(self, strids):
+        """
+        Try to resolve the identities of year/month/day elements using
+        ystridx, mstridx, and dstridx, if enough of these are specified.
+        """
+        if len(self) == 3 and len(strids) == 2:
+            # we can back out the remaining stridx value
+            missing = [x for x in range(3) if x not in strids.values()]
+            key = [x for x in ['y', 'm', 'd'] if x not in strids]
+            assert len(missing) == len(key) == 1
+            key = key[0]
+            val = missing[0]
+            strids[key] = val
+
+        assert len(self) == len(strids)  # otherwise this should not be called
+        out = {key: self[strids[key]] for key in strids}
+        return (out.get('y'), out.get('m'), out.get('d'))
+
+    def resolve_ymd(self, yearfirst, dayfirst):
+        len_ymd = len(self)
+        year, month, day = (None, None, None)
+
+        strids = (('y', self.ystridx),
+                  ('m', self.mstridx),
+                  ('d', self.dstridx))
+
+        strids = {key: val for key, val in strids if val is not None}
+        if (len(self) == len(strids) > 0 or
+                (len(self) == 3 and len(strids) == 2)):
+            return self._resolve_from_stridxs(strids)
+
+        mstridx = self.mstridx
+
+        if len_ymd > 3:
+            raise ValueError("More than three YMD values")
+        elif len_ymd == 1 or (mstridx is not None and len_ymd == 2):
+            # One member, or two members with a month string
+            if mstridx is not None:
+                month = self[mstridx]
+                # since mstridx is 0 or 1, self[mstridx-1] always
+                # looks up the other element
+                other = self[mstridx - 1]
+            else:
+                other = self[0]
+
+            if len_ymd > 1 or mstridx is None:
+                if other > 31:
+                    year = other
+                else:
+                    day = other
+
+        elif len_ymd == 2:
+            # Two members with numbers
+            if self[0] > 31:
+                # 99-01
+                year, month = self
+            elif self[1] > 31:
+                # 01-99
+                month, year = self
+            elif dayfirst and self[1] <= 12:
+                # 13-01
+                day, month = self
+            else:
+                # 01-13
+                month, day = self
+
+        elif len_ymd == 3:
+            # Three members
+            if mstridx == 0:
+                if self[1] > 31:
+                    # Apr-2003-25
+                    month, year, day = self
+                else:
+                    month, day, year = self
+            elif mstridx == 1:
+                if self[0] > 31 or (yearfirst and self[2] <= 31):
+                    # 99-Jan-01
+                    year, month, day = self
+                else:
+                    # 01-Jan-01
+                    # Give precedence to day-first, since
+                    # two-digit years is usually hand-written.
+                    day, month, year = self
+
+            elif mstridx == 2:
+                # WTF!?
+                if self[1] > 31:
+                    # 01-99-Jan
+                    day, year, month = self
+                else:
+                    # 99-01-Jan
+                    year, day, month = self
+
+            else:
+                if (self[0] > 31 or
+                    self.ystridx == 0 or
+                        (yearfirst and self[1] <= 12 and self[2] <= 31)):
+                    # 99-01-01
+                    if dayfirst and self[2] <= 12:
+                        year, day, month = self
+                    else:
+                        year, month, day = self
+                elif self[0] > 12 or (dayfirst and self[1] <= 12):
+                    # 13-01-01
+                    day, month, year = self
+                else:
+                    # 01-13-01
+                    month, day, year = self
+
+        return year, month, day
+
+
+class parser(object):
+    def __init__(self, info=None):
+        self.info = info or parserinfo()
+
+    def parse(self, timestr, default=None,
+              ignoretz=False, tzinfos=None, **kwargs):
+        """
+        Parse the date/time string into a :class:`datetime.datetime` object.
+
+        :param timestr:
+            Any date/time string using the supported formats.
+
+        :param default:
+            The default datetime object, if this is a datetime object and not
+            ``None``, elements specified in ``timestr`` replace elements in the
+            default object.
+
+        :param ignoretz:
+            If set ``True``, time zones in parsed strings are ignored and a
+            naive :class:`datetime.datetime` object is returned.
+
+        :param tzinfos:
+            Additional time zone names / aliases which may be present in the
+            string. This argument maps time zone names (and optionally offsets
+            from those time zones) to time zones. This parameter can be a
+            dictionary with timezone aliases mapping time zone names to time
+            zones or a function taking two parameters (``tzname`` and
+            ``tzoffset``) and returning a time zone.
+
+            The timezones to which the names are mapped can be an integer
+            offset from UTC in seconds or a :class:`tzinfo` object.
+
+            .. doctest::
+               :options: +NORMALIZE_WHITESPACE
+
+                >>> from dateutil.parser import parse
+                >>> from dateutil.tz import gettz
+                >>> tzinfos = {"BRST": -7200, "CST": gettz("America/Chicago")}
+                >>> parse("2012-01-19 17:21:00 BRST", tzinfos=tzinfos)
+                datetime.datetime(2012, 1, 19, 17, 21, tzinfo=tzoffset(u'BRST', -7200))
+                >>> parse("2012-01-19 17:21:00 CST", tzinfos=tzinfos)
+                datetime.datetime(2012, 1, 19, 17, 21,
+                                  tzinfo=tzfile('/usr/share/zoneinfo/America/Chicago'))
+
+            This parameter is ignored if ``ignoretz`` is set.
+
+        :param \\*\\*kwargs:
+            Keyword arguments as passed to ``_parse()``.
+
+        :return:
+            Returns a :class:`datetime.datetime` object or, if the
+            ``fuzzy_with_tokens`` option is ``True``, returns a tuple, the
+            first element being a :class:`datetime.datetime` object, the second
+            a tuple containing the fuzzy tokens.
+
+        :raises ParserError:
+            Raised for invalid or unknown string format, if the provided
+            :class:`tzinfo` is not in a valid format, or if an invalid date
+            would be created.
+
+        :raises TypeError:
+            Raised for non-string or character stream input.
+
+        :raises OverflowError:
+            Raised if the parsed date exceeds the largest valid C integer on
+            your system.
+        """
+
+        if default is None:
+            default = datetime.datetime.now().replace(hour=0, minute=0,
+                                                      second=0, microsecond=0)
+
+        res, skipped_tokens = self._parse(timestr, **kwargs)
+
+        if res is None:
+            raise ParserError("Unknown string format: %s", timestr)
+
+        if len(res) == 0:
+            raise ParserError("String does not contain a date: %s", timestr)
+
+        try:
+            ret = self._build_naive(res, default)
+        except ValueError as e:
+            six.raise_from(ParserError(str(e) + ": %s", timestr), e)
+
+        if not ignoretz:
+            ret = self._build_tzaware(ret, res, tzinfos)
+
+        if kwargs.get('fuzzy_with_tokens', False):
+            return ret, skipped_tokens
+        else:
+            return ret
+
+    class _result(_resultbase):
+        __slots__ = ["year", "month", "day", "weekday",
+                     "hour", "minute", "second", "microsecond",
+                     "tzname", "tzoffset", "ampm","any_unused_tokens"]
+
+    def _parse(self, timestr, dayfirst=None, yearfirst=None, fuzzy=False,
+               fuzzy_with_tokens=False):
+        """
+        Private method which performs the heavy lifting of parsing, called from
+        ``parse()``, which passes on its ``kwargs`` to this function.
+
+        :param timestr:
+            The string to parse.
+
+        :param dayfirst:
+            Whether to interpret the first value in an ambiguous 3-integer date
+            (e.g. 01/05/09) as the day (``True``) or month (``False``). If
+            ``yearfirst`` is set to ``True``, this distinguishes between YDM
+            and YMD. If set to ``None``, this value is retrieved from the
+            current :class:`parserinfo` object (which itself defaults to
+            ``False``).
+
+        :param yearfirst:
+            Whether to interpret the first value in an ambiguous 3-integer date
+            (e.g. 01/05/09) as the year. If ``True``, the first number is taken
+            to be the year, otherwise the last number is taken to be the year.
+            If this is set to ``None``, the value is retrieved from the current
+            :class:`parserinfo` object (which itself defaults to ``False``).
+
+        :param fuzzy:
+            Whether to allow fuzzy parsing, allowing for string like "Today is
+            January 1, 2047 at 8:21:00AM".
+
+        :param fuzzy_with_tokens:
+            If ``True``, ``fuzzy`` is automatically set to True, and the parser
+            will return a tuple where the first element is the parsed
+            :class:`datetime.datetime` datetimestamp and the second element is
+            a tuple containing the portions of the string which were ignored:
+
+            .. doctest::
+
+                >>> from dateutil.parser import parse
+                >>> parse("Today is January 1, 2047 at 8:21:00AM", fuzzy_with_tokens=True)
+                (datetime.datetime(2047, 1, 1, 8, 21), (u'Today is ', u' ', u'at '))
+
+        """
+        if fuzzy_with_tokens:
+            fuzzy = True
+
+        info = self.info
+
+        if dayfirst is None:
+            dayfirst = info.dayfirst
+
+        if yearfirst is None:
+            yearfirst = info.yearfirst
+
+        res = self._result()
+        l = _timelex.split(timestr)         # Splits the timestr into tokens
+
+        skipped_idxs = []
+
+        # year/month/day list
+        ymd = _ymd()
+
+        len_l = len(l)
+        i = 0
+        try:
+            while i < len_l:
+
+                # Check if it's a number
+                value_repr = l[i]
+                try:
+                    value = float(value_repr)
+                except ValueError:
+                    value = None
+
+                if value is not None:
+                    # Numeric token
+                    i = self._parse_numeric_token(l, i, info, ymd, res, fuzzy)
+
+                # Check weekday
+                elif info.weekday(l[i]) is not None:
+                    value = info.weekday(l[i])
+                    res.weekday = value
+
+                # Check month name
+                elif info.month(l[i]) is not None:
+                    value = info.month(l[i])
+                    ymd.append(value, 'M')
+
+                    if i + 1 < len_l:
+                        if l[i + 1] in ('-', '/'):
+                            # Jan-01[-99]
+                            sep = l[i + 1]
+                            ymd.append(l[i + 2])
+
+                            if i + 3 < len_l and l[i + 3] == sep:
+                                # Jan-01-99
+                                ymd.append(l[i + 4])
+                                i += 2
+
+                            i += 2
+
+                        elif (i + 4 < len_l and l[i + 1] == l[i + 3] == ' ' and
+                              info.pertain(l[i + 2])):
+                            # Jan of 01
+                            # In this case, 01 is clearly year
+                            if l[i + 4].isdigit():
+                                # Convert it here to become unambiguous
+                                value = int(l[i + 4])
+                                year = str(info.convertyear(value))
+                                ymd.append(year, 'Y')
+                            else:
+                                # Wrong guess
+                                pass
+                                # TODO: not hit in tests
+                            i += 4
+
+                # Check am/pm
+                elif info.ampm(l[i]) is not None:
+                    value = info.ampm(l[i])
+                    val_is_ampm = self._ampm_valid(res.hour, res.ampm, fuzzy)
+
+                    if val_is_ampm:
+                        res.hour = self._adjust_ampm(res.hour, value)
+                        res.ampm = value
+
+                    elif fuzzy:
+                        skipped_idxs.append(i)
+
+                # Check for a timezone name
+                elif self._could_be_tzname(res.hour, res.tzname, res.tzoffset, l[i]):
+                    res.tzname = l[i]
+                    res.tzoffset = info.tzoffset(res.tzname)
+
+                    # Check for something like GMT+3, or BRST+3. Notice
+                    # that it doesn't mean "I am 3 hours after GMT", but
+                    # "my time +3 is GMT". If found, we reverse the
+                    # logic so that timezone parsing code will get it
+                    # right.
+                    if i + 1 < len_l and l[i + 1] in ('+', '-'):
+                        l[i + 1] = ('+', '-')[l[i + 1] == '+']
+                        res.tzoffset = None
+                        if info.utczone(res.tzname):
+                            # With something like GMT+3, the timezone
+                            # is *not* GMT.
+                            res.tzname = None
+
+                # Check for a numbered timezone
+                elif res.hour is not None and l[i] in ('+', '-'):
+                    signal = (-1, 1)[l[i] == '+']
+                    len_li = len(l[i + 1])
+
+                    # TODO: check that l[i + 1] is integer?
+                    if len_li == 4:
+                        # -0300
+                        hour_offset = int(l[i + 1][:2])
+                        min_offset = int(l[i + 1][2:])
+                    elif i + 2 < len_l and l[i + 2] == ':':
+                        # -03:00
+                        hour_offset = int(l[i + 1])
+                        min_offset = int(l[i + 3])  # TODO: Check that l[i+3] is minute-like?
+                        i += 2
+                    elif len_li <= 2:
+                        # -[0]3
+                        hour_offset = int(l[i + 1][:2])
+                        min_offset = 0
+                    else:
+                        raise ValueError(timestr)
+
+                    res.tzoffset = signal * (hour_offset * 3600 + min_offset * 60)
+
+                    # Look for a timezone name between parenthesis
+                    if (i + 5 < len_l and
+                            info.jump(l[i + 2]) and l[i + 3] == '(' and
+                            l[i + 5] == ')' and
+                            3 <= len(l[i + 4]) and
+                            self._could_be_tzname(res.hour, res.tzname,
+                                                  None, l[i + 4])):
+                        # -0300 (BRST)
+                        res.tzname = l[i + 4]
+                        i += 4
+
+                    i += 1
+
+                # Check jumps
+                elif not (info.jump(l[i]) or fuzzy):
+                    raise ValueError(timestr)
+
+                else:
+                    skipped_idxs.append(i)
+                i += 1
+
+            # Process year/month/day
+            year, month, day = ymd.resolve_ymd(yearfirst, dayfirst)
+
+            res.century_specified = ymd.century_specified
+            res.year = year
+            res.month = month
+            res.day = day
+
+        except (IndexError, ValueError):
+            return None, None
+
+        if not info.validate(res):
+            return None, None
+
+        if fuzzy_with_tokens:
+            skipped_tokens = self._recombine_skipped(l, skipped_idxs)
+            return res, tuple(skipped_tokens)
+        else:
+            return res, None
+
+    def _parse_numeric_token(self, tokens, idx, info, ymd, res, fuzzy):
+        # Token is a number
+        value_repr = tokens[idx]
+        try:
+            value = self._to_decimal(value_repr)
+        except Exception as e:
+            six.raise_from(ValueError('Unknown numeric token'), e)
+
+        len_li = len(value_repr)
+
+        len_l = len(tokens)
+
+        if (len(ymd) == 3 and len_li in (2, 4) and
+            res.hour is None and
+            (idx + 1 >= len_l or
+             (tokens[idx + 1] != ':' and
+              info.hms(tokens[idx + 1]) is None))):
+            # 19990101T23[59]
+            s = tokens[idx]
+            res.hour = int(s[:2])
+
+            if len_li == 4:
+                res.minute = int(s[2:])
+
+        elif len_li == 6 or (len_li > 6 and tokens[idx].find('.') == 6):
+            # YYMMDD or HHMMSS[.ss]
+            s = tokens[idx]
+
+            if not ymd and '.' not in tokens[idx]:
+                ymd.append(s[:2])
+                ymd.append(s[2:4])
+                ymd.append(s[4:])
+            else:
+                # 19990101T235959[.59]
+
+                # TODO: Check if res attributes already set.
+                res.hour = int(s[:2])
+                res.minute = int(s[2:4])
+                res.second, res.microsecond = self._parsems(s[4:])
+
+        elif len_li in (8, 12, 14):
+            # YYYYMMDD
+            s = tokens[idx]
+            ymd.append(s[:4], 'Y')
+            ymd.append(s[4:6])
+            ymd.append(s[6:8])
+
+            if len_li > 8:
+                res.hour = int(s[8:10])
+                res.minute = int(s[10:12])
+
+                if len_li > 12:
+                    res.second = int(s[12:])
+
+        elif self._find_hms_idx(idx, tokens, info, allow_jump=True) is not None:
+            # HH[ ]h or MM[ ]m or SS[.ss][ ]s
+            hms_idx = self._find_hms_idx(idx, tokens, info, allow_jump=True)
+            (idx, hms) = self._parse_hms(idx, tokens, info, hms_idx)
+            if hms is not None:
+                # TODO: checking that hour/minute/second are not
+                # already set?
+                self._assign_hms(res, value_repr, hms)
+
+        elif idx + 2 < len_l and tokens[idx + 1] == ':':
+            # HH:MM[:SS[.ss]]
+            res.hour = int(value)
+            value = self._to_decimal(tokens[idx + 2])  # TODO: try/except for this?
+            (res.minute, res.second) = self._parse_min_sec(value)
+
+            if idx + 4 < len_l and tokens[idx + 3] == ':':
+                res.second, res.microsecond = self._parsems(tokens[idx + 4])
+
+                idx += 2
+
+            idx += 2
+
+        elif idx + 1 < len_l and tokens[idx + 1] in ('-', '/', '.'):
+            sep = tokens[idx + 1]
+            ymd.append(value_repr)
+
+            if idx + 2 < len_l and not info.jump(tokens[idx + 2]):
+                if tokens[idx + 2].isdigit():
+                    # 01-01[-01]
+                    ymd.append(tokens[idx + 2])
+                else:
+                    # 01-Jan[-01]
+                    value = info.month(tokens[idx + 2])
+
+                    if value is not None:
+                        ymd.append(value, 'M')
+                    else:
+                        raise ValueError()
+
+                if idx + 3 < len_l and tokens[idx + 3] == sep:
+                    # We have three members
+                    value = info.month(tokens[idx + 4])
+
+                    if value is not None:
+                        ymd.append(value, 'M')
+                    else:
+                        ymd.append(tokens[idx + 4])
+                    idx += 2
+
+                idx += 1
+            idx += 1
+
+        elif idx + 1 >= len_l or info.jump(tokens[idx + 1]):
+            if idx + 2 < len_l and info.ampm(tokens[idx + 2]) is not None:
+                # 12 am
+                hour = int(value)
+                res.hour = self._adjust_ampm(hour, info.ampm(tokens[idx + 2]))
+                idx += 1
+            else:
+                # Year, month or day
+                ymd.append(value)
+            idx += 1
+
+        elif info.ampm(tokens[idx + 1]) is not None and (0 <= value < 24):
+            # 12am
+            hour = int(value)
+            res.hour = self._adjust_ampm(hour, info.ampm(tokens[idx + 1]))
+            idx += 1
+
+        elif ymd.could_be_day(value):
+            ymd.append(value)
+
+        elif not fuzzy:
+            raise ValueError()
+
+        return idx
+
+    def _find_hms_idx(self, idx, tokens, info, allow_jump):
+        len_l = len(tokens)
+
+        if idx+1 < len_l and info.hms(tokens[idx+1]) is not None:
+            # There is an "h", "m", or "s" label following this token.  We take
+            # assign the upcoming label to the current token.
+            # e.g. the "12" in 12h"
+            hms_idx = idx + 1
+
+        elif (allow_jump and idx+2 < len_l and tokens[idx+1] == ' ' and
+              info.hms(tokens[idx+2]) is not None):
+            # There is a space and then an "h", "m", or "s" label.
+            # e.g. the "12" in "12 h"
+            hms_idx = idx + 2
+
+        elif idx > 0 and info.hms(tokens[idx-1]) is not None:
+            # There is a "h", "m", or "s" preceding this token.  Since neither
+            # of the previous cases was hit, there is no label following this
+            # token, so we use the previous label.
+            # e.g. the "04" in "12h04"
+            hms_idx = idx-1
+
+        elif (1 < idx == len_l-1 and tokens[idx-1] == ' ' and
+              info.hms(tokens[idx-2]) is not None):
+            # If we are looking at the final token, we allow for a
+            # backward-looking check to skip over a space.
+            # TODO: Are we sure this is the right condition here?
+            hms_idx = idx - 2
+
+        else:
+            hms_idx = None
+
+        return hms_idx
+
+    def _assign_hms(self, res, value_repr, hms):
+        # See GH issue #427, fixing float rounding
+        value = self._to_decimal(value_repr)
+
+        if hms == 0:
+            # Hour
+            res.hour = int(value)
+            if value % 1:
+                res.minute = int(60*(value % 1))
+
+        elif hms == 1:
+            (res.minute, res.second) = self._parse_min_sec(value)
+
+        elif hms == 2:
+            (res.second, res.microsecond) = self._parsems(value_repr)
+
+    def _could_be_tzname(self, hour, tzname, tzoffset, token):
+        return (hour is not None and
+                tzname is None and
+                tzoffset is None and
+                len(token) <= 5 and
+                (all(x in string.ascii_uppercase for x in token)
+                 or token in self.info.UTCZONE))
+
+    def _ampm_valid(self, hour, ampm, fuzzy):
+        """
+        For fuzzy parsing, 'a' or 'am' (both valid English words)
+        may erroneously trigger the AM/PM flag. Deal with that
+        here.
+        """
+        val_is_ampm = True
+
+        # If there's already an AM/PM flag, this one isn't one.
+        if fuzzy and ampm is not None:
+            val_is_ampm = False
+
+        # If AM/PM is found and hour is not, raise a ValueError
+        if hour is None:
+            if fuzzy:
+                val_is_ampm = False
+            else:
+                raise ValueError('No hour specified with AM or PM flag.')
+        elif not 0 <= hour <= 12:
+            # If AM/PM is found, it's a 12 hour clock, so raise
+            # an error for invalid range
+            if fuzzy:
+                val_is_ampm = False
+            else:
+                raise ValueError('Invalid hour specified for 12-hour clock.')
+
+        return val_is_ampm
+
+    def _adjust_ampm(self, hour, ampm):
+        if hour < 12 and ampm == 1:
+            hour += 12
+        elif hour == 12 and ampm == 0:
+            hour = 0
+        return hour
+
+    def _parse_min_sec(self, value):
+        # TODO: Every usage of this function sets res.second to the return
+        # value. Are there any cases where second will be returned as None and
+        # we *don't* want to set res.second = None?
+        minute = int(value)
+        second = None
+
+        sec_remainder = value % 1
+        if sec_remainder:
+            second = int(60 * sec_remainder)
+        return (minute, second)
+
+    def _parse_hms(self, idx, tokens, info, hms_idx):
+        # TODO: Is this going to admit a lot of false-positives for when we
+        # just happen to have digits and "h", "m" or "s" characters in non-date
+        # text?  I guess hex hashes won't have that problem, but there's plenty
+        # of random junk out there.
+        if hms_idx is None:
+            hms = None
+            new_idx = idx
+        elif hms_idx > idx:
+            hms = info.hms(tokens[hms_idx])
+            new_idx = hms_idx
+        else:
+            # Looking backwards, increment one.
+            hms = info.hms(tokens[hms_idx]) + 1
+            new_idx = idx
+
+        return (new_idx, hms)
+
+    # ------------------------------------------------------------------
+    # Handling for individual tokens.  These are kept as methods instead
+    #  of functions for the sake of customizability via subclassing.
+
+    def _parsems(self, value):
+        """Parse a I[.F] seconds value into (seconds, microseconds)."""
+        if "." not in value:
+            return int(value), 0
+        else:
+            i, f = value.split(".")
+            return int(i), int(f.ljust(6, "0")[:6])
+
+    def _to_decimal(self, val):
+        try:
+            decimal_value = Decimal(val)
+            # See GH 662, edge case, infinite value should not be converted
+            #  via `_to_decimal`
+            if not decimal_value.is_finite():
+                raise ValueError("Converted decimal value is infinite or NaN")
+        except Exception as e:
+            msg = "Could not convert %s to decimal" % val
+            six.raise_from(ValueError(msg), e)
+        else:
+            return decimal_value
+
+    # ------------------------------------------------------------------
+    # Post-Parsing construction of datetime output.  These are kept as
+    #  methods instead of functions for the sake of customizability via
+    #  subclassing.
+
+    def _build_tzinfo(self, tzinfos, tzname, tzoffset):
+        if callable(tzinfos):
+            tzdata = tzinfos(tzname, tzoffset)
+        else:
+            tzdata = tzinfos.get(tzname)
+        # handle case where tzinfo is paased an options that returns None
+        # eg tzinfos = {'BRST' : None}
+        if isinstance(tzdata, datetime.tzinfo) or tzdata is None:
+            tzinfo = tzdata
+        elif isinstance(tzdata, text_type):
+            tzinfo = tz.tzstr(tzdata)
+        elif isinstance(tzdata, integer_types):
+            tzinfo = tz.tzoffset(tzname, tzdata)
+        else:
+            raise TypeError("Offset must be tzinfo subclass, tz string, "
+                            "or int offset.")
+        return tzinfo
+
+    def _build_tzaware(self, naive, res, tzinfos):
+        if (callable(tzinfos) or (tzinfos and res.tzname in tzinfos)):
+            tzinfo = self._build_tzinfo(tzinfos, res.tzname, res.tzoffset)
+            aware = naive.replace(tzinfo=tzinfo)
+            aware = self._assign_tzname(aware, res.tzname)
+
+        elif res.tzname and res.tzname in time.tzname:
+            aware = naive.replace(tzinfo=tz.tzlocal())
+
+            # Handle ambiguous local datetime
+            aware = self._assign_tzname(aware, res.tzname)
+
+            # This is mostly relevant for winter GMT zones parsed in the UK
+            if (aware.tzname() != res.tzname and
+                    res.tzname in self.info.UTCZONE):
+                aware = aware.replace(tzinfo=tz.UTC)
+
+        elif res.tzoffset == 0:
+            aware = naive.replace(tzinfo=tz.UTC)
+
+        elif res.tzoffset:
+            aware = naive.replace(tzinfo=tz.tzoffset(res.tzname, res.tzoffset))
+
+        elif not res.tzname and not res.tzoffset:
+            # i.e. no timezone information was found.
+            aware = naive
+
+        elif res.tzname:
+            # tz-like string was parsed but we don't know what to do
+            # with it
+            warnings.warn("tzname {tzname} identified but not understood.  "
+                          "Pass `tzinfos` argument in order to correctly "
+                          "return a timezone-aware datetime.  In a future "
+                          "version, this will raise an "
+                          "exception.".format(tzname=res.tzname),
+                          category=UnknownTimezoneWarning)
+            aware = naive
+
+        return aware
+
+    def _build_naive(self, res, default):
+        repl = {}
+        for attr in ("year", "month", "day", "hour",
+                     "minute", "second", "microsecond"):
+            value = getattr(res, attr)
+            if value is not None:
+                repl[attr] = value
+
+        if 'day' not in repl:
+            # If the default day exceeds the last day of the month, fall back
+            # to the end of the month.
+            cyear = default.year if res.year is None else res.year
+            cmonth = default.month if res.month is None else res.month
+            cday = default.day if res.day is None else res.day
+
+            if cday > monthrange(cyear, cmonth)[1]:
+                repl['day'] = monthrange(cyear, cmonth)[1]
+
+        naive = default.replace(**repl)
+
+        if res.weekday is not None and not res.day:
+            naive = naive + relativedelta.relativedelta(weekday=res.weekday)
+
+        return naive
+
+    def _assign_tzname(self, dt, tzname):
+        if dt.tzname() != tzname:
+            new_dt = tz.enfold(dt, fold=1)
+            if new_dt.tzname() == tzname:
+                return new_dt
+
+        return dt
+
+    def _recombine_skipped(self, tokens, skipped_idxs):
+        """
+        >>> tokens = ["foo", " ", "bar", " ", "19June2000", "baz"]
+        >>> skipped_idxs = [0, 1, 2, 5]
+        >>> _recombine_skipped(tokens, skipped_idxs)
+        ["foo bar", "baz"]
+        """
+        skipped_tokens = []
+        for i, idx in enumerate(sorted(skipped_idxs)):
+            if i > 0 and idx - 1 == skipped_idxs[i - 1]:
+                skipped_tokens[-1] = skipped_tokens[-1] + tokens[idx]
+            else:
+                skipped_tokens.append(tokens[idx])
+
+        return skipped_tokens
+
+
+DEFAULTPARSER = parser()
+
+
+def parse(timestr, parserinfo=None, **kwargs):
+    """
+
+    Parse a string in one of the supported formats, using the
+    ``parserinfo`` parameters.
+
+    :param timestr:
+        A string containing a date/time stamp.
+
+    :param parserinfo:
+        A :class:`parserinfo` object containing parameters for the parser.
+        If ``None``, the default arguments to the :class:`parserinfo`
+        constructor are used.
+
+    The ``**kwargs`` parameter takes the following keyword arguments:
+
+    :param default:
+        The default datetime object, if this is a datetime object and not
+        ``None``, elements specified in ``timestr`` replace elements in the
+        default object.
+
+    :param ignoretz:
+        If set ``True``, time zones in parsed strings are ignored and a naive
+        :class:`datetime` object is returned.
+
+    :param tzinfos:
+        Additional time zone names / aliases which may be present in the
+        string. This argument maps time zone names (and optionally offsets
+        from those time zones) to time zones. This parameter can be a
+        dictionary with timezone aliases mapping time zone names to time
+        zones or a function taking two parameters (``tzname`` and
+        ``tzoffset``) and returning a time zone.
+
+        The timezones to which the names are mapped can be an integer
+        offset from UTC in seconds or a :class:`tzinfo` object.
+
+        .. doctest::
+           :options: +NORMALIZE_WHITESPACE
+
+            >>> from dateutil.parser import parse
+            >>> from dateutil.tz import gettz
+            >>> tzinfos = {"BRST": -7200, "CST": gettz("America/Chicago")}
+            >>> parse("2012-01-19 17:21:00 BRST", tzinfos=tzinfos)
+            datetime.datetime(2012, 1, 19, 17, 21, tzinfo=tzoffset(u'BRST', -7200))
+            >>> parse("2012-01-19 17:21:00 CST", tzinfos=tzinfos)
+            datetime.datetime(2012, 1, 19, 17, 21,
+                              tzinfo=tzfile('/usr/share/zoneinfo/America/Chicago'))
+
+        This parameter is ignored if ``ignoretz`` is set.
+
+    :param dayfirst:
+        Whether to interpret the first value in an ambiguous 3-integer date
+        (e.g. 01/05/09) as the day (``True``) or month (``False``). If
+        ``yearfirst`` is set to ``True``, this distinguishes between YDM and
+        YMD. If set to ``None``, this value is retrieved from the current
+        :class:`parserinfo` object (which itself defaults to ``False``).
+
+    :param yearfirst:
+        Whether to interpret the first value in an ambiguous 3-integer date
+        (e.g. 01/05/09) as the year. If ``True``, the first number is taken to
+        be the year, otherwise the last number is taken to be the year. If
+        this is set to ``None``, the value is retrieved from the current
+        :class:`parserinfo` object (which itself defaults to ``False``).
+
+    :param fuzzy:
+        Whether to allow fuzzy parsing, allowing for string like "Today is
+        January 1, 2047 at 8:21:00AM".
+
+    :param fuzzy_with_tokens:
+        If ``True``, ``fuzzy`` is automatically set to True, and the parser
+        will return a tuple where the first element is the parsed
+        :class:`datetime.datetime` datetimestamp and the second element is
+        a tuple containing the portions of the string which were ignored:
+
+        .. doctest::
+
+            >>> from dateutil.parser import parse
+            >>> parse("Today is January 1, 2047 at 8:21:00AM", fuzzy_with_tokens=True)
+            (datetime.datetime(2047, 1, 1, 8, 21), (u'Today is ', u' ', u'at '))
+
+    :return:
+        Returns a :class:`datetime.datetime` object or, if the
+        ``fuzzy_with_tokens`` option is ``True``, returns a tuple, the
+        first element being a :class:`datetime.datetime` object, the second
+        a tuple containing the fuzzy tokens.
+
+    :raises ParserError:
+        Raised for invalid or unknown string formats, if the provided
+        :class:`tzinfo` is not in a valid format, or if an invalid date would
+        be created.
+
+    :raises OverflowError:
+        Raised if the parsed date exceeds the largest valid C integer on
+        your system.
+    """
+    if parserinfo:
+        return parser(parserinfo).parse(timestr, **kwargs)
+    else:
+        return DEFAULTPARSER.parse(timestr, **kwargs)
+
+
+class _tzparser(object):
+
+    class _result(_resultbase):
+
+        __slots__ = ["stdabbr", "stdoffset", "dstabbr", "dstoffset",
+                     "start", "end"]
+
+        class _attr(_resultbase):
+            __slots__ = ["month", "week", "weekday",
+                         "yday", "jyday", "day", "time"]
+
+        def __repr__(self):
+            return self._repr("")
+
+        def __init__(self):
+            _resultbase.__init__(self)
+            self.start = self._attr()
+            self.end = self._attr()
+
+    def parse(self, tzstr):
+        res = self._result()
+        l = [x for x in re.split(r'([,:.]|[a-zA-Z]+|[0-9]+)',tzstr) if x]
+        used_idxs = list()
+        try:
+
+            len_l = len(l)
+
+            i = 0
+            while i < len_l:
+                # BRST+3[BRDT[+2]]
+                j = i
+                while j < len_l and not [x for x in l[j]
+                                         if x in "0123456789:,-+"]:
+                    j += 1
+                if j != i:
+                    if not res.stdabbr:
+                        offattr = "stdoffset"
+                        res.stdabbr = "".join(l[i:j])
+                    else:
+                        offattr = "dstoffset"
+                        res.dstabbr = "".join(l[i:j])
+
+                    for ii in range(j):
+                        used_idxs.append(ii)
+                    i = j
+                    if (i < len_l and (l[i] in ('+', '-') or l[i][0] in
+                                       "0123456789")):
+                        if l[i] in ('+', '-'):
+                            # Yes, that's right.  See the TZ variable
+                            # documentation.
+                            signal = (1, -1)[l[i] == '+']
+                            used_idxs.append(i)
+                            i += 1
+                        else:
+                            signal = -1
+                        len_li = len(l[i])
+                        if len_li == 4:
+                            # -0300
+                            setattr(res, offattr, (int(l[i][:2]) * 3600 +
+                                                   int(l[i][2:]) * 60) * signal)
+                        elif i + 1 < len_l and l[i + 1] == ':':
+                            # -03:00
+                            setattr(res, offattr,
+                                    (int(l[i]) * 3600 +
+                                     int(l[i + 2]) * 60) * signal)
+                            used_idxs.append(i)
+                            i += 2
+                        elif len_li <= 2:
+                            # -[0]3
+                            setattr(res, offattr,
+                                    int(l[i][:2]) * 3600 * signal)
+                        else:
+                            return None
+                        used_idxs.append(i)
+                        i += 1
+                    if res.dstabbr:
+                        break
+                else:
+                    break
+
+
+            if i < len_l:
+                for j in range(i, len_l):
+                    if l[j] == ';':
+                        l[j] = ','
+
+                assert l[i] == ','
+
+                i += 1
+
+            if i >= len_l:
+                pass
+            elif (8 <= l.count(',') <= 9 and
+                  not [y for x in l[i:] if x != ','
+                       for y in x if y not in "0123456789+-"]):
+                # GMT0BST,3,0,30,3600,10,0,26,7200[,3600]
+                for x in (res.start, res.end):
+                    x.month = int(l[i])
+                    used_idxs.append(i)
+                    i += 2
+                    if l[i] == '-':
+                        value = int(l[i + 1]) * -1
+                        used_idxs.append(i)
+                        i += 1
+                    else:
+                        value = int(l[i])
+                    used_idxs.append(i)
+                    i += 2
+                    if value:
+                        x.week = value
+                        x.weekday = (int(l[i]) - 1) % 7
+                    else:
+                        x.day = int(l[i])
+                    used_idxs.append(i)
+                    i += 2
+                    x.time = int(l[i])
+                    used_idxs.append(i)
+                    i += 2
+                if i < len_l:
+                    if l[i] in ('-', '+'):
+                        signal = (-1, 1)[l[i] == "+"]
+                        used_idxs.append(i)
+                        i += 1
+                    else:
+                        signal = 1
+                    used_idxs.append(i)
+                    res.dstoffset = (res.stdoffset + int(l[i]) * signal)
+
+                # This was a made-up format that is not in normal use
+                warn(('Parsed time zone "%s"' % tzstr) +
+                     'is in a non-standard dateutil-specific format, which ' +
+                     'is now deprecated; support for parsing this format ' +
+                     'will be removed in future versions. It is recommended ' +
+                     'that you switch to a standard format like the GNU ' +
+                     'TZ variable format.', tz.DeprecatedTzFormatWarning)
+            elif (l.count(',') == 2 and l[i:].count('/') <= 2 and
+                  not [y for x in l[i:] if x not in (',', '/', 'J', 'M',
+                                                     '.', '-', ':')
+                       for y in x if y not in "0123456789"]):
+                for x in (res.start, res.end):
+                    if l[i] == 'J':
+                        # non-leap year day (1 based)
+                        used_idxs.append(i)
+                        i += 1
+                        x.jyday = int(l[i])
+                    elif l[i] == 'M':
+                        # month[-.]week[-.]weekday
+                        used_idxs.append(i)
+                        i += 1
+                        x.month = int(l[i])
+                        used_idxs.append(i)
+                        i += 1
+                        assert l[i] in ('-', '.')
+                        used_idxs.append(i)
+                        i += 1
+                        x.week = int(l[i])
+                        if x.week == 5:
+                            x.week = -1
+                        used_idxs.append(i)
+                        i += 1
+                        assert l[i] in ('-', '.')
+                        used_idxs.append(i)
+                        i += 1
+                        x.weekday = (int(l[i]) - 1) % 7
+                    else:
+                        # year day (zero based)
+                        x.yday = int(l[i]) + 1
+
+                    used_idxs.append(i)
+                    i += 1
+
+                    if i < len_l and l[i] == '/':
+                        used_idxs.append(i)
+                        i += 1
+                        # start time
+                        len_li = len(l[i])
+                        if len_li == 4:
+                            # -0300
+                            x.time = (int(l[i][:2]) * 3600 +
+                                      int(l[i][2:]) * 60)
+                        elif i + 1 < len_l and l[i + 1] == ':':
+                            # -03:00
+                            x.time = int(l[i]) * 3600 + int(l[i + 2]) * 60
+                            used_idxs.append(i)
+                            i += 2
+                            if i + 1 < len_l and l[i + 1] == ':':
+                                used_idxs.append(i)
+                                i += 2
+                                x.time += int(l[i])
+                        elif len_li <= 2:
+                            # -[0]3
+                            x.time = (int(l[i][:2]) * 3600)
+                        else:
+                            return None
+                        used_idxs.append(i)
+                        i += 1
+
+                    assert i == len_l or l[i] == ','
+
+                    i += 1
+
+                assert i >= len_l
+
+        except (IndexError, ValueError, AssertionError):
+            return None
+
+        unused_idxs = set(range(len_l)).difference(used_idxs)
+        res.any_unused_tokens = not {l[n] for n in unused_idxs}.issubset({",",":"})
+        return res
+
+
+DEFAULTTZPARSER = _tzparser()
+
+
+def _parsetz(tzstr):
+    return DEFAULTTZPARSER.parse(tzstr)
+
+
+class ParserError(ValueError):
+    """Exception subclass used for any failure to parse a datetime string.
+
+    This is a subclass of :py:exc:`ValueError`, and should be raised any time
+    earlier versions of ``dateutil`` would have raised ``ValueError``.
+
+    .. versionadded:: 2.8.1
+    """
+    def __str__(self):
+        try:
+            return self.args[0] % self.args[1:]
+        except (TypeError, IndexError):
+            return super(ParserError, self).__str__()
+
+    def __repr__(self):
+        args = ", ".join("'%s'" % arg for arg in self.args)
+        return "%s(%s)" % (self.__class__.__name__, args)
+
+
+class UnknownTimezoneWarning(RuntimeWarning):
+    """Raised when the parser finds a timezone it cannot parse into a tzinfo.
+
+    .. versionadded:: 2.7.0
+    """
+# vim:ts=4:sw=4:et
diff --git a/myvenv/Lib/site-packages/dateutil/parser/isoparser.py b/myvenv/Lib/site-packages/dateutil/parser/isoparser.py
new file mode 100644
index 0000000..5d7bee3
--- /dev/null
+++ b/myvenv/Lib/site-packages/dateutil/parser/isoparser.py
@@ -0,0 +1,416 @@
+# -*- coding: utf-8 -*-
+"""
+This module offers a parser for ISO-8601 strings
+
+It is intended to support all valid date, time and datetime formats per the
+ISO-8601 specification.
+
+..versionadded:: 2.7.0
+"""
+from datetime import datetime, timedelta, time, date
+import calendar
+from dateutil import tz
+
+from functools import wraps
+
+import re
+import six
+
+__all__ = ["isoparse", "isoparser"]
+
+
+def _takes_ascii(f):
+    @wraps(f)
+    def func(self, str_in, *args, **kwargs):
+        # If it's a stream, read the whole thing
+        str_in = getattr(str_in, 'read', lambda: str_in)()
+
+        # If it's unicode, turn it into bytes, since ISO-8601 only covers ASCII
+        if isinstance(str_in, six.text_type):
+            # ASCII is the same in UTF-8
+            try:
+                str_in = str_in.encode('ascii')
+            except UnicodeEncodeError as e:
+                msg = 'ISO-8601 strings should contain only ASCII characters'
+                six.raise_from(ValueError(msg), e)
+
+        return f(self, str_in, *args, **kwargs)
+
+    return func
+
+
+class isoparser(object):
+    def __init__(self, sep=None):
+        """
+        :param sep:
+            A single character that separates date and time portions. If
+            ``None``, the parser will accept any single character.
+            For strict ISO-8601 adherence, pass ``'T'``.
+        """
+        if sep is not None:
+            if (len(sep) != 1 or ord(sep) >= 128 or sep in '0123456789'):
+                raise ValueError('Separator must be a single, non-numeric ' +
+                                 'ASCII character')
+
+            sep = sep.encode('ascii')
+
+        self._sep = sep
+
+    @_takes_ascii
+    def isoparse(self, dt_str):
+        """
+        Parse an ISO-8601 datetime string into a :class:`datetime.datetime`.
+
+        An ISO-8601 datetime string consists of a date portion, followed
+        optionally by a time portion - the date and time portions are separated
+        by a single character separator, which is ``T`` in the official
+        standard. Incomplete date formats (such as ``YYYY-MM``) may *not* be
+        combined with a time portion.
+
+        Supported date formats are:
+
+        Common:
+
+        - ``YYYY``
+        - ``YYYY-MM`` or ``YYYYMM``
+        - ``YYYY-MM-DD`` or ``YYYYMMDD``
+
+        Uncommon:
+
+        - ``YYYY-Www`` or ``YYYYWww`` - ISO week (day defaults to 0)
+        - ``YYYY-Www-D`` or ``YYYYWwwD`` - ISO week and day
+
+        The ISO week and day numbering follows the same logic as
+        :func:`datetime.date.isocalendar`.
+
+        Supported time formats are:
+
+        - ``hh``
+        - ``hh:mm`` or ``hhmm``
+        - ``hh:mm:ss`` or ``hhmmss``
+        - ``hh:mm:ss.ssssss`` (Up to 6 sub-second digits)
+
+        Midnight is a special case for `hh`, as the standard supports both
+        00:00 and 24:00 as a representation. The decimal separator can be
+        either a dot or a comma.
+
+
+        .. caution::
+
+            Support for fractional components other than seconds is part of the
+            ISO-8601 standard, but is not currently implemented in this parser.
+
+        Supported time zone offset formats are:
+
+        - `Z` (UTC)
+        - `±HH:MM`
+        - `±HHMM`
+        - `±HH`
+
+        Offsets will be represented as :class:`dateutil.tz.tzoffset` objects,
+        with the exception of UTC, which will be represented as
+        :class:`dateutil.tz.tzutc`. Time zone offsets equivalent to UTC (such
+        as `+00:00`) will also be represented as :class:`dateutil.tz.tzutc`.
+
+        :param dt_str:
+            A string or stream containing only an ISO-8601 datetime string
+
+        :return:
+            Returns a :class:`datetime.datetime` representing the string.
+            Unspecified components default to their lowest value.
+
+        .. warning::
+
+            As of version 2.7.0, the strictness of the parser should not be
+            considered a stable part of the contract. Any valid ISO-8601 string
+            that parses correctly with the default settings will continue to
+            parse correctly in future versions, but invalid strings that
+            currently fail (e.g. ``2017-01-01T00:00+00:00:00``) are not
+            guaranteed to continue failing in future versions if they encode
+            a valid date.
+
+        .. versionadded:: 2.7.0
+        """
+        components, pos = self._parse_isodate(dt_str)
+
+        if len(dt_str) > pos:
+            if self._sep is None or dt_str[pos:pos + 1] == self._sep:
+                components += self._parse_isotime(dt_str[pos + 1:])
+            else:
+                raise ValueError('String contains unknown ISO components')
+
+        if len(components) > 3 and components[3] == 24:
+            components[3] = 0
+            return datetime(*components) + timedelta(days=1)
+
+        return datetime(*components)
+
+    @_takes_ascii
+    def parse_isodate(self, datestr):
+        """
+        Parse the date portion of an ISO string.
+
+        :param datestr:
+            The string portion of an ISO string, without a separator
+
+        :return:
+            Returns a :class:`datetime.date` object
+        """
+        components, pos = self._parse_isodate(datestr)
+        if pos < len(datestr):
+            raise ValueError('String contains unknown ISO ' +
+                             'components: {!r}'.format(datestr.decode('ascii')))
+        return date(*components)
+
+    @_takes_ascii
+    def parse_isotime(self, timestr):
+        """
+        Parse the time portion of an ISO string.
+
+        :param timestr:
+            The time portion of an ISO string, without a separator
+
+        :return:
+            Returns a :class:`datetime.time` object
+        """
+        components = self._parse_isotime(timestr)
+        if components[0] == 24:
+            components[0] = 0
+        return time(*components)
+
+    @_takes_ascii
+    def parse_tzstr(self, tzstr, zero_as_utc=True):
+        """
+        Parse a valid ISO time zone string.
+
+        See :func:`isoparser.isoparse` for details on supported formats.
+
+        :param tzstr:
+            A string representing an ISO time zone offset
+
+        :param zero_as_utc:
+            Whether to return :class:`dateutil.tz.tzutc` for zero-offset zones
+
+        :return:
+            Returns :class:`dateutil.tz.tzoffset` for offsets and
+            :class:`dateutil.tz.tzutc` for ``Z`` and (if ``zero_as_utc`` is
+            specified) offsets equivalent to UTC.
+        """
+        return self._parse_tzstr(tzstr, zero_as_utc=zero_as_utc)
+
+    # Constants
+    _DATE_SEP = b'-'
+    _TIME_SEP = b':'
+    _FRACTION_REGEX = re.compile(b'[\\.,]([0-9]+)')
+
+    def _parse_isodate(self, dt_str):
+        try:
+            return self._parse_isodate_common(dt_str)
+        except ValueError:
+            return self._parse_isodate_uncommon(dt_str)
+
+    def _parse_isodate_common(self, dt_str):
+        len_str = len(dt_str)
+        components = [1, 1, 1]
+
+        if len_str < 4:
+            raise ValueError('ISO string too short')
+
+        # Year
+        components[0] = int(dt_str[0:4])
+        pos = 4
+        if pos >= len_str:
+            return components, pos
+
+        has_sep = dt_str[pos:pos + 1] == self._DATE_SEP
+        if has_sep:
+            pos += 1
+
+        # Month
+        if len_str - pos < 2:
+            raise ValueError('Invalid common month')
+
+        components[1] = int(dt_str[pos:pos + 2])
+        pos += 2
+
+        if pos >= len_str:
+            if has_sep:
+                return components, pos
+            else:
+                raise ValueError('Invalid ISO format')
+
+        if has_sep:
+            if dt_str[pos:pos + 1] != self._DATE_SEP:
+                raise ValueError('Invalid separator in ISO string')
+            pos += 1
+
+        # Day
+        if len_str - pos < 2:
+            raise ValueError('Invalid common day')
+        components[2] = int(dt_str[pos:pos + 2])
+        return components, pos + 2
+
+    def _parse_isodate_uncommon(self, dt_str):
+        if len(dt_str) < 4:
+            raise ValueError('ISO string too short')
+
+        # All ISO formats start with the year
+        year = int(dt_str[0:4])
+
+        has_sep = dt_str[4:5] == self._DATE_SEP
+
+        pos = 4 + has_sep       # Skip '-' if it's there
+        if dt_str[pos:pos + 1] == b'W':
+            # YYYY-?Www-?D?
+            pos += 1
+            weekno = int(dt_str[pos:pos + 2])
+            pos += 2
+
+            dayno = 1
+            if len(dt_str) > pos:
+                if (dt_str[pos:pos + 1] == self._DATE_SEP) != has_sep:
+                    raise ValueError('Inconsistent use of dash separator')
+
+                pos += has_sep
+
+                dayno = int(dt_str[pos:pos + 1])
+                pos += 1
+
+            base_date = self._calculate_weekdate(year, weekno, dayno)
+        else:
+            # YYYYDDD or YYYY-DDD
+            if len(dt_str) - pos < 3:
+                raise ValueError('Invalid ordinal day')
+
+            ordinal_day = int(dt_str[pos:pos + 3])
+            pos += 3
+
+            if ordinal_day < 1 or ordinal_day > (365 + calendar.isleap(year)):
+                raise ValueError('Invalid ordinal day' +
+                                 ' {} for year {}'.format(ordinal_day, year))
+
+            base_date = date(year, 1, 1) + timedelta(days=ordinal_day - 1)
+
+        components = [base_date.year, base_date.month, base_date.day]
+        return components, pos
+
+    def _calculate_weekdate(self, year, week, day):
+        """
+        Calculate the day of corresponding to the ISO year-week-day calendar.
+
+        This function is effectively the inverse of
+        :func:`datetime.date.isocalendar`.
+
+        :param year:
+            The year in the ISO calendar
+
+        :param week:
+            The week in the ISO calendar - range is [1, 53]
+
+        :param day:
+            The day in the ISO calendar - range is [1 (MON), 7 (SUN)]
+
+        :return:
+            Returns a :class:`datetime.date`
+        """
+        if not 0 < week < 54:
+            raise ValueError('Invalid week: {}'.format(week))
+
+        if not 0 < day < 8:     # Range is 1-7
+            raise ValueError('Invalid weekday: {}'.format(day))
+
+        # Get week 1 for the specific year:
+        jan_4 = date(year, 1, 4)   # Week 1 always has January 4th in it
+        week_1 = jan_4 - timedelta(days=jan_4.isocalendar()[2] - 1)
+
+        # Now add the specific number of weeks and days to get what we want
+        week_offset = (week - 1) * 7 + (day - 1)
+        return week_1 + timedelta(days=week_offset)
+
+    def _parse_isotime(self, timestr):
+        len_str = len(timestr)
+        components = [0, 0, 0, 0, None]
+        pos = 0
+        comp = -1
+
+        if len_str < 2:
+            raise ValueError('ISO time too short')
+
+        has_sep = False
+
+        while pos < len_str and comp < 5:
+            comp += 1
+
+            if timestr[pos:pos + 1] in b'-+Zz':
+                # Detect time zone boundary
+                components[-1] = self._parse_tzstr(timestr[pos:])
+                pos = len_str
+                break
+
+            if comp == 1 and timestr[pos:pos+1] == self._TIME_SEP:
+                has_sep = True
+                pos += 1
+            elif comp == 2 and has_sep:
+                if timestr[pos:pos+1] != self._TIME_SEP:
+                    raise ValueError('Inconsistent use of colon separator')
+                pos += 1
+
+            if comp < 3:
+                # Hour, minute, second
+                components[comp] = int(timestr[pos:pos + 2])
+                pos += 2
+
+            if comp == 3:
+                # Fraction of a second
+                frac = self._FRACTION_REGEX.match(timestr[pos:])
+                if not frac:
+                    continue
+
+                us_str = frac.group(1)[:6]  # Truncate to microseconds
+                components[comp] = int(us_str) * 10**(6 - len(us_str))
+                pos += len(frac.group())
+
+        if pos < len_str:
+            raise ValueError('Unused components in ISO string')
+
+        if components[0] == 24:
+            # Standard supports 00:00 and 24:00 as representations of midnight
+            if any(component != 0 for component in components[1:4]):
+                raise ValueError('Hour may only be 24 at 24:00:00.000')
+
+        return components
+
+    def _parse_tzstr(self, tzstr, zero_as_utc=True):
+        if tzstr == b'Z' or tzstr == b'z':
+            return tz.UTC
+
+        if len(tzstr) not in {3, 5, 6}:
+            raise ValueError('Time zone offset must be 1, 3, 5 or 6 characters')
+
+        if tzstr[0:1] == b'-':
+            mult = -1
+        elif tzstr[0:1] == b'+':
+            mult = 1
+        else:
+            raise ValueError('Time zone offset requires sign')
+
+        hours = int(tzstr[1:3])
+        if len(tzstr) == 3:
+            minutes = 0
+        else:
+            minutes = int(tzstr[(4 if tzstr[3:4] == self._TIME_SEP else 3):])
+
+        if zero_as_utc and hours == 0 and minutes == 0:
+            return tz.UTC
+        else:
+            if minutes > 59:
+                raise ValueError('Invalid minutes in time zone offset')
+
+            if hours > 23:
+                raise ValueError('Invalid hours in time zone offset')
+
+            return tz.tzoffset(None, mult * (hours * 60 + minutes) * 60)
+
+
+DEFAULT_ISOPARSER = isoparser()
+isoparse = DEFAULT_ISOPARSER.isoparse
diff --git a/myvenv/Lib/site-packages/dateutil/relativedelta.py b/myvenv/Lib/site-packages/dateutil/relativedelta.py
new file mode 100644
index 0000000..a9e85f7
--- /dev/null
+++ b/myvenv/Lib/site-packages/dateutil/relativedelta.py
@@ -0,0 +1,599 @@
+# -*- coding: utf-8 -*-
+import datetime
+import calendar
+
+import operator
+from math import copysign
+
+from six import integer_types
+from warnings import warn
+
+from ._common import weekday
+
+MO, TU, WE, TH, FR, SA, SU = weekdays = tuple(weekday(x) for x in range(7))
+
+__all__ = ["relativedelta", "MO", "TU", "WE", "TH", "FR", "SA", "SU"]
+
+
+class relativedelta(object):
+    """
+    The relativedelta type is designed to be applied to an existing datetime and
+    can replace specific components of that datetime, or represents an interval
+    of time.
+
+    It is based on the specification of the excellent work done by M.-A. Lemburg
+    in his
+    `mx.DateTime <https://www.egenix.com/products/python/mxBase/mxDateTime/>`_ extension.
+    However, notice that this type does *NOT* implement the same algorithm as
+    his work. Do *NOT* expect it to behave like mx.DateTime's counterpart.
+
+    There are two different ways to build a relativedelta instance. The
+    first one is passing it two date/datetime classes::
+
+        relativedelta(datetime1, datetime2)
+
+    The second one is passing it any number of the following keyword arguments::
+
+        relativedelta(arg1=x,arg2=y,arg3=z...)
+
+        year, month, day, hour, minute, second, microsecond:
+            Absolute information (argument is singular); adding or subtracting a
+            relativedelta with absolute information does not perform an arithmetic
+            operation, but rather REPLACES the corresponding value in the
+            original datetime with the value(s) in relativedelta.
+
+        years, months, weeks, days, hours, minutes, seconds, microseconds:
+            Relative information, may be negative (argument is plural); adding
+            or subtracting a relativedelta with relative information performs
+            the corresponding arithmetic operation on the original datetime value
+            with the information in the relativedelta.
+
+        weekday: 
+            One of the weekday instances (MO, TU, etc) available in the
+            relativedelta module. These instances may receive a parameter N,
+            specifying the Nth weekday, which could be positive or negative
+            (like MO(+1) or MO(-2)). Not specifying it is the same as specifying
+            +1. You can also use an integer, where 0=MO. This argument is always
+            relative e.g. if the calculated date is already Monday, using MO(1)
+            or MO(-1) won't change the day. To effectively make it absolute, use
+            it in combination with the day argument (e.g. day=1, MO(1) for first
+            Monday of the month).
+
+        leapdays:
+            Will add given days to the date found, if year is a leap
+            year, and the date found is post 28 of february.
+
+        yearday, nlyearday:
+            Set the yearday or the non-leap year day (jump leap days).
+            These are converted to day/month/leapdays information.
+
+    There are relative and absolute forms of the keyword
+    arguments. The plural is relative, and the singular is
+    absolute. For each argument in the order below, the absolute form
+    is applied first (by setting each attribute to that value) and
+    then the relative form (by adding the value to the attribute).
+
+    The order of attributes considered when this relativedelta is
+    added to a datetime is:
+
+    1. Year
+    2. Month
+    3. Day
+    4. Hours
+    5. Minutes
+    6. Seconds
+    7. Microseconds
+
+    Finally, weekday is applied, using the rule described above.
+
+    For example
+
+    >>> from datetime import datetime
+    >>> from dateutil.relativedelta import relativedelta, MO
+    >>> dt = datetime(2018, 4, 9, 13, 37, 0)
+    >>> delta = relativedelta(hours=25, day=1, weekday=MO(1))
+    >>> dt + delta
+    datetime.datetime(2018, 4, 2, 14, 37)
+
+    First, the day is set to 1 (the first of the month), then 25 hours
+    are added, to get to the 2nd day and 14th hour, finally the
+    weekday is applied, but since the 2nd is already a Monday there is
+    no effect.
+
+    """
+
+    def __init__(self, dt1=None, dt2=None,
+                 years=0, months=0, days=0, leapdays=0, weeks=0,
+                 hours=0, minutes=0, seconds=0, microseconds=0,
+                 year=None, month=None, day=None, weekday=None,
+                 yearday=None, nlyearday=None,
+                 hour=None, minute=None, second=None, microsecond=None):
+
+        if dt1 and dt2:
+            # datetime is a subclass of date. So both must be date
+            if not (isinstance(dt1, datetime.date) and
+                    isinstance(dt2, datetime.date)):
+                raise TypeError("relativedelta only diffs datetime/date")
+
+            # We allow two dates, or two datetimes, so we coerce them to be
+            # of the same type
+            if (isinstance(dt1, datetime.datetime) !=
+                    isinstance(dt2, datetime.datetime)):
+                if not isinstance(dt1, datetime.datetime):
+                    dt1 = datetime.datetime.fromordinal(dt1.toordinal())
+                elif not isinstance(dt2, datetime.datetime):
+                    dt2 = datetime.datetime.fromordinal(dt2.toordinal())
+
+            self.years = 0
+            self.months = 0
+            self.days = 0
+            self.leapdays = 0
+            self.hours = 0
+            self.minutes = 0
+            self.seconds = 0
+            self.microseconds = 0
+            self.year = None
+            self.month = None
+            self.day = None
+            self.weekday = None
+            self.hour = None
+            self.minute = None
+            self.second = None
+            self.microsecond = None
+            self._has_time = 0
+
+            # Get year / month delta between the two
+            months = (dt1.year - dt2.year) * 12 + (dt1.month - dt2.month)
+            self._set_months(months)
+
+            # Remove the year/month delta so the timedelta is just well-defined
+            # time units (seconds, days and microseconds)
+            dtm = self.__radd__(dt2)
+
+            # If we've overshot our target, make an adjustment
+            if dt1 < dt2:
+                compare = operator.gt
+                increment = 1
+            else:
+                compare = operator.lt
+                increment = -1
+
+            while compare(dt1, dtm):
+                months += increment
+                self._set_months(months)
+                dtm = self.__radd__(dt2)
+
+            # Get the timedelta between the "months-adjusted" date and dt1
+            delta = dt1 - dtm
+            self.seconds = delta.seconds + delta.days * 86400
+            self.microseconds = delta.microseconds
+        else:
+            # Check for non-integer values in integer-only quantities
+            if any(x is not None and x != int(x) for x in (years, months)):
+                raise ValueError("Non-integer years and months are "
+                                 "ambiguous and not currently supported.")
+
+            # Relative information
+            self.years = int(years)
+            self.months = int(months)
+            self.days = days + weeks * 7
+            self.leapdays = leapdays
+            self.hours = hours
+            self.minutes = minutes
+            self.seconds = seconds
+            self.microseconds = microseconds
+
+            # Absolute information
+            self.year = year
+            self.month = month
+            self.day = day
+            self.hour = hour
+            self.minute = minute
+            self.second = second
+            self.microsecond = microsecond
+
+            if any(x is not None and int(x) != x
+                   for x in (year, month, day, hour,
+                             minute, second, microsecond)):
+                # For now we'll deprecate floats - later it'll be an error.
+                warn("Non-integer value passed as absolute information. " +
+                     "This is not a well-defined condition and will raise " +
+                     "errors in future versions.", DeprecationWarning)
+
+            if isinstance(weekday, integer_types):
+                self.weekday = weekdays[weekday]
+            else:
+                self.weekday = weekday
+
+            yday = 0
+            if nlyearday:
+                yday = nlyearday
+            elif yearday:
+                yday = yearday
+                if yearday > 59:
+                    self.leapdays = -1
+            if yday:
+                ydayidx = [31, 59, 90, 120, 151, 181, 212,
+                           243, 273, 304, 334, 366]
+                for idx, ydays in enumerate(ydayidx):
+                    if yday <= ydays:
+                        self.month = idx+1
+                        if idx == 0:
+                            self.day = yday
+                        else:
+                            self.day = yday-ydayidx[idx-1]
+                        break
+                else:
+                    raise ValueError("invalid year day (%d)" % yday)
+
+        self._fix()
+
+    def _fix(self):
+        if abs(self.microseconds) > 999999:
+            s = _sign(self.microseconds)
+            div, mod = divmod(self.microseconds * s, 1000000)
+            self.microseconds = mod * s
+            self.seconds += div * s
+        if abs(self.seconds) > 59:
+            s = _sign(self.seconds)
+            div, mod = divmod(self.seconds * s, 60)
+            self.seconds = mod * s
+            self.minutes += div * s
+        if abs(self.minutes) > 59:
+            s = _sign(self.minutes)
+            div, mod = divmod(self.minutes * s, 60)
+            self.minutes = mod * s
+            self.hours += div * s
+        if abs(self.hours) > 23:
+            s = _sign(self.hours)
+            div, mod = divmod(self.hours * s, 24)
+            self.hours = mod * s
+            self.days += div * s
+        if abs(self.months) > 11:
+            s = _sign(self.months)
+            div, mod = divmod(self.months * s, 12)
+            self.months = mod * s
+            self.years += div * s
+        if (self.hours or self.minutes or self.seconds or self.microseconds
+                or self.hour is not None or self.minute is not None or
+                self.second is not None or self.microsecond is not None):
+            self._has_time = 1
+        else:
+            self._has_time = 0
+
+    @property
+    def weeks(self):
+        return int(self.days / 7.0)
+
+    @weeks.setter
+    def weeks(self, value):
+        self.days = self.days - (self.weeks * 7) + value * 7
+
+    def _set_months(self, months):
+        self.months = months
+        if abs(self.months) > 11:
+            s = _sign(self.months)
+            div, mod = divmod(self.months * s, 12)
+            self.months = mod * s
+            self.years = div * s
+        else:
+            self.years = 0
+
+    def normalized(self):
+        """
+        Return a version of this object represented entirely using integer
+        values for the relative attributes.
+
+        >>> relativedelta(days=1.5, hours=2).normalized()
+        relativedelta(days=+1, hours=+14)
+
+        :return:
+            Returns a :class:`dateutil.relativedelta.relativedelta` object.
+        """
+        # Cascade remainders down (rounding each to roughly nearest microsecond)
+        days = int(self.days)
+
+        hours_f = round(self.hours + 24 * (self.days - days), 11)
+        hours = int(hours_f)
+
+        minutes_f = round(self.minutes + 60 * (hours_f - hours), 10)
+        minutes = int(minutes_f)
+
+        seconds_f = round(self.seconds + 60 * (minutes_f - minutes), 8)
+        seconds = int(seconds_f)
+
+        microseconds = round(self.microseconds + 1e6 * (seconds_f - seconds))
+
+        # Constructor carries overflow back up with call to _fix()
+        return self.__class__(years=self.years, months=self.months,
+                              days=days, hours=hours, minutes=minutes,
+                              seconds=seconds, microseconds=microseconds,
+                              leapdays=self.leapdays, year=self.year,
+                              month=self.month, day=self.day,
+                              weekday=self.weekday, hour=self.hour,
+                              minute=self.minute, second=self.second,
+                              microsecond=self.microsecond)
+
+    def __add__(self, other):
+        if isinstance(other, relativedelta):
+            return self.__class__(years=other.years + self.years,
+                                 months=other.months + self.months,
+                                 days=other.days + self.days,
+                                 hours=other.hours + self.hours,
+                                 minutes=other.minutes + self.minutes,
+                                 seconds=other.seconds + self.seconds,
+                                 microseconds=(other.microseconds +
+                                               self.microseconds),
+                                 leapdays=other.leapdays or self.leapdays,
+                                 year=(other.year if other.year is not None
+                                       else self.year),
+                                 month=(other.month if other.month is not None
+                                        else self.month),
+                                 day=(other.day if other.day is not None
+                                      else self.day),
+                                 weekday=(other.weekday if other.weekday is not None
+                                          else self.weekday),
+                                 hour=(other.hour if other.hour is not None
+                                       else self.hour),
+                                 minute=(other.minute if other.minute is not None
+                                         else self.minute),
+                                 second=(other.second if other.second is not None
+                                         else self.second),
+                                 microsecond=(other.microsecond if other.microsecond
+                                              is not None else
+                                              self.microsecond))
+        if isinstance(other, datetime.timedelta):
+            return self.__class__(years=self.years,
+                                  months=self.months,
+                                  days=self.days + other.days,
+                                  hours=self.hours,
+                                  minutes=self.minutes,
+                                  seconds=self.seconds + other.seconds,
+                                  microseconds=self.microseconds + other.microseconds,
+                                  leapdays=self.leapdays,
+                                  year=self.year,
+                                  month=self.month,
+                                  day=self.day,
+                                  weekday=self.weekday,
+                                  hour=self.hour,
+                                  minute=self.minute,
+                                  second=self.second,
+                                  microsecond=self.microsecond)
+        if not isinstance(other, datetime.date):
+            return NotImplemented
+        elif self._has_time and not isinstance(other, datetime.datetime):
+            other = datetime.datetime.fromordinal(other.toordinal())
+        year = (self.year or other.year)+self.years
+        month = self.month or other.month
+        if self.months:
+            assert 1 <= abs(self.months) <= 12
+            month += self.months
+            if month > 12:
+                year += 1
+                month -= 12
+            elif month < 1:
+                year -= 1
+                month += 12
+        day = min(calendar.monthrange(year, month)[1],
+                  self.day or other.day)
+        repl = {"year": year, "month": month, "day": day}
+        for attr in ["hour", "minute", "second", "microsecond"]:
+            value = getattr(self, attr)
+            if value is not None:
+                repl[attr] = value
+        days = self.days
+        if self.leapdays and month > 2 and calendar.isleap(year):
+            days += self.leapdays
+        ret = (other.replace(**repl)
+               + datetime.timedelta(days=days,
+                                    hours=self.hours,
+                                    minutes=self.minutes,
+                                    seconds=self.seconds,
+                                    microseconds=self.microseconds))
+        if self.weekday:
+            weekday, nth = self.weekday.weekday, self.weekday.n or 1
+            jumpdays = (abs(nth) - 1) * 7
+            if nth > 0:
+                jumpdays += (7 - ret.weekday() + weekday) % 7
+            else:
+                jumpdays += (ret.weekday() - weekday) % 7
+                jumpdays *= -1
+            ret += datetime.timedelta(days=jumpdays)
+        return ret
+
+    def __radd__(self, other):
+        return self.__add__(other)
+
+    def __rsub__(self, other):
+        return self.__neg__().__radd__(other)
+
+    def __sub__(self, other):
+        if not isinstance(other, relativedelta):
+            return NotImplemented   # In case the other object defines __rsub__
+        return self.__class__(years=self.years - other.years,
+                             months=self.months - other.months,
+                             days=self.days - other.days,
+                             hours=self.hours - other.hours,
+                             minutes=self.minutes - other.minutes,
+                             seconds=self.seconds - other.seconds,
+                             microseconds=self.microseconds - other.microseconds,
+                             leapdays=self.leapdays or other.leapdays,
+                             year=(self.year if self.year is not None
+                                   else other.year),
+                             month=(self.month if self.month is not None else
+                                    other.month),
+                             day=(self.day if self.day is not None else
+                                  other.day),
+                             weekday=(self.weekday if self.weekday is not None else
+                                      other.weekday),
+                             hour=(self.hour if self.hour is not None else
+                                   other.hour),
+                             minute=(self.minute if self.minute is not None else
+                                     other.minute),
+                             second=(self.second if self.second is not None else
+                                     other.second),
+                             microsecond=(self.microsecond if self.microsecond
+                                          is not None else
+                                          other.microsecond))
+
+    def __abs__(self):
+        return self.__class__(years=abs(self.years),
+                              months=abs(self.months),
+                              days=abs(self.days),
+                              hours=abs(self.hours),
+                              minutes=abs(self.minutes),
+                              seconds=abs(self.seconds),
+                              microseconds=abs(self.microseconds),
+                              leapdays=self.leapdays,
+                              year=self.year,
+                              month=self.month,
+                              day=self.day,
+                              weekday=self.weekday,
+                              hour=self.hour,
+                              minute=self.minute,
+                              second=self.second,
+                              microsecond=self.microsecond)
+
+    def __neg__(self):
+        return self.__class__(years=-self.years,
+                             months=-self.months,
+                             days=-self.days,
+                             hours=-self.hours,
+                             minutes=-self.minutes,
+                             seconds=-self.seconds,
+                             microseconds=-self.microseconds,
+                             leapdays=self.leapdays,
+                             year=self.year,
+                             month=self.month,
+                             day=self.day,
+                             weekday=self.weekday,
+                             hour=self.hour,
+                             minute=self.minute,
+                             second=self.second,
+                             microsecond=self.microsecond)
+
+    def __bool__(self):
+        return not (not self.years and
+                    not self.months and
+                    not self.days and
+                    not self.hours and
+                    not self.minutes and
+                    not self.seconds and
+                    not self.microseconds and
+                    not self.leapdays and
+                    self.year is None and
+                    self.month is None and
+                    self.day is None and
+                    self.weekday is None and
+                    self.hour is None and
+                    self.minute is None and
+                    self.second is None and
+                    self.microsecond is None)
+    # Compatibility with Python 2.x
+    __nonzero__ = __bool__
+
+    def __mul__(self, other):
+        try:
+            f = float(other)
+        except TypeError:
+            return NotImplemented
+
+        return self.__class__(years=int(self.years * f),
+                             months=int(self.months * f),
+                             days=int(self.days * f),
+                             hours=int(self.hours * f),
+                             minutes=int(self.minutes * f),
+                             seconds=int(self.seconds * f),
+                             microseconds=int(self.microseconds * f),
+                             leapdays=self.leapdays,
+                             year=self.year,
+                             month=self.month,
+                             day=self.day,
+                             weekday=self.weekday,
+                             hour=self.hour,
+                             minute=self.minute,
+                             second=self.second,
+                             microsecond=self.microsecond)
+
+    __rmul__ = __mul__
+
+    def __eq__(self, other):
+        if not isinstance(other, relativedelta):
+            return NotImplemented
+        if self.weekday or other.weekday:
+            if not self.weekday or not other.weekday:
+                return False
+            if self.weekday.weekday != other.weekday.weekday:
+                return False
+            n1, n2 = self.weekday.n, other.weekday.n
+            if n1 != n2 and not ((not n1 or n1 == 1) and (not n2 or n2 == 1)):
+                return False
+        return (self.years == other.years and
+                self.months == other.months and
+                self.days == other.days and
+                self.hours == other.hours and
+                self.minutes == other.minutes and
+                self.seconds == other.seconds and
+                self.microseconds == other.microseconds and
+                self.leapdays == other.leapdays and
+                self.year == other.year and
+                self.month == other.month and
+                self.day == other.day and
+                self.hour == other.hour and
+                self.minute == other.minute and
+                self.second == other.second and
+                self.microsecond == other.microsecond)
+
+    def __hash__(self):
+        return hash((
+            self.weekday,
+            self.years,
+            self.months,
+            self.days,
+            self.hours,
+            self.minutes,
+            self.seconds,
+            self.microseconds,
+            self.leapdays,
+            self.year,
+            self.month,
+            self.day,
+            self.hour,
+            self.minute,
+            self.second,
+            self.microsecond,
+        ))
+
+    def __ne__(self, other):
+        return not self.__eq__(other)
+
+    def __div__(self, other):
+        try:
+            reciprocal = 1 / float(other)
+        except TypeError:
+            return NotImplemented
+
+        return self.__mul__(reciprocal)
+
+    __truediv__ = __div__
+
+    def __repr__(self):
+        l = []
+        for attr in ["years", "months", "days", "leapdays",
+                     "hours", "minutes", "seconds", "microseconds"]:
+            value = getattr(self, attr)
+            if value:
+                l.append("{attr}={value:+g}".format(attr=attr, value=value))
+        for attr in ["year", "month", "day", "weekday",
+                     "hour", "minute", "second", "microsecond"]:
+            value = getattr(self, attr)
+            if value is not None:
+                l.append("{attr}={value}".format(attr=attr, value=repr(value)))
+        return "{classname}({attrs})".format(classname=self.__class__.__name__,
+                                             attrs=", ".join(l))
+
+
+def _sign(x):
+    return int(copysign(1, x))
+
+# vim:ts=4:sw=4:et
diff --git a/myvenv/Lib/site-packages/dateutil/rrule.py b/myvenv/Lib/site-packages/dateutil/rrule.py
new file mode 100644
index 0000000..b320339
--- /dev/null
+++ b/myvenv/Lib/site-packages/dateutil/rrule.py
@@ -0,0 +1,1737 @@
+# -*- coding: utf-8 -*-
+"""
+The rrule module offers a small, complete, and very fast, implementation of
+the recurrence rules documented in the
+`iCalendar RFC <https://tools.ietf.org/html/rfc5545>`_,
+including support for caching of results.
+"""
+import calendar
+import datetime
+import heapq
+import itertools
+import re
+import sys
+from functools import wraps
+# For warning about deprecation of until and count
+from warnings import warn
+
+from six import advance_iterator, integer_types
+
+from six.moves import _thread, range
+
+from ._common import weekday as weekdaybase
+
+try:
+    from math import gcd
+except ImportError:
+    from fractions import gcd
+
+__all__ = ["rrule", "rruleset", "rrulestr",
+           "YEARLY", "MONTHLY", "WEEKLY", "DAILY",
+           "HOURLY", "MINUTELY", "SECONDLY",
+           "MO", "TU", "WE", "TH", "FR", "SA", "SU"]
+
+# Every mask is 7 days longer to handle cross-year weekly periods.
+M366MASK = tuple([1]*31+[2]*29+[3]*31+[4]*30+[5]*31+[6]*30 +
+                 [7]*31+[8]*31+[9]*30+[10]*31+[11]*30+[12]*31+[1]*7)
+M365MASK = list(M366MASK)
+M29, M30, M31 = list(range(1, 30)), list(range(1, 31)), list(range(1, 32))
+MDAY366MASK = tuple(M31+M29+M31+M30+M31+M30+M31+M31+M30+M31+M30+M31+M31[:7])
+MDAY365MASK = list(MDAY366MASK)
+M29, M30, M31 = list(range(-29, 0)), list(range(-30, 0)), list(range(-31, 0))
+NMDAY366MASK = tuple(M31+M29+M31+M30+M31+M30+M31+M31+M30+M31+M30+M31+M31[:7])
+NMDAY365MASK = list(NMDAY366MASK)
+M366RANGE = (0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366)
+M365RANGE = (0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365)
+WDAYMASK = [0, 1, 2, 3, 4, 5, 6]*55
+del M29, M30, M31, M365MASK[59], MDAY365MASK[59], NMDAY365MASK[31]
+MDAY365MASK = tuple(MDAY365MASK)
+M365MASK = tuple(M365MASK)
+
+FREQNAMES = ['YEARLY', 'MONTHLY', 'WEEKLY', 'DAILY', 'HOURLY', 'MINUTELY', 'SECONDLY']
+
+(YEARLY,
+ MONTHLY,
+ WEEKLY,
+ DAILY,
+ HOURLY,
+ MINUTELY,
+ SECONDLY) = list(range(7))
+
+# Imported on demand.
+easter = None
+parser = None
+
+
+class weekday(weekdaybase):
+    """
+    This version of weekday does not allow n = 0.
+    """
+    def __init__(self, wkday, n=None):
+        if n == 0:
+            raise ValueError("Can't create weekday with n==0")
+
+        super(weekday, self).__init__(wkday, n)
+
+
+MO, TU, WE, TH, FR, SA, SU = weekdays = tuple(weekday(x) for x in range(7))
+
+
+def _invalidates_cache(f):
+    """
+    Decorator for rruleset methods which may invalidate the
+    cached length.
+    """
+    @wraps(f)
+    def inner_func(self, *args, **kwargs):
+        rv = f(self, *args, **kwargs)
+        self._invalidate_cache()
+        return rv
+
+    return inner_func
+
+
+class rrulebase(object):
+    def __init__(self, cache=False):
+        if cache:
+            self._cache = []
+            self._cache_lock = _thread.allocate_lock()
+            self._invalidate_cache()
+        else:
+            self._cache = None
+            self._cache_complete = False
+            self._len = None
+
+    def __iter__(self):
+        if self._cache_complete:
+            return iter(self._cache)
+        elif self._cache is None:
+            return self._iter()
+        else:
+            return self._iter_cached()
+
+    def _invalidate_cache(self):
+        if self._cache is not None:
+            self._cache = []
+            self._cache_complete = False
+            self._cache_gen = self._iter()
+
+            if self._cache_lock.locked():
+                self._cache_lock.release()
+
+        self._len = None
+
+    def _iter_cached(self):
+        i = 0
+        gen = self._cache_gen
+        cache = self._cache
+        acquire = self._cache_lock.acquire
+        release = self._cache_lock.release
+        while gen:
+            if i == len(cache):
+                acquire()
+                if self._cache_complete:
+                    break
+                try:
+                    for j in range(10):
+                        cache.append(advance_iterator(gen))
+                except StopIteration:
+                    self._cache_gen = gen = None
+                    self._cache_complete = True
+                    break
+                release()
+            yield cache[i]
+            i += 1
+        while i < self._len:
+            yield cache[i]
+            i += 1
+
+    def __getitem__(self, item):
+        if self._cache_complete:
+            return self._cache[item]
+        elif isinstance(item, slice):
+            if item.step and item.step < 0:
+                return list(iter(self))[item]
+            else:
+                return list(itertools.islice(self,
+                                             item.start or 0,
+                                             item.stop or sys.maxsize,
+                                             item.step or 1))
+        elif item >= 0:
+            gen = iter(self)
+            try:
+                for i in range(item+1):
+                    res = advance_iterator(gen)
+            except StopIteration:
+                raise IndexError
+            return res
+        else:
+            return list(iter(self))[item]
+
+    def __contains__(self, item):
+        if self._cache_complete:
+            return item in self._cache
+        else:
+            for i in self:
+                if i == item:
+                    return True
+                elif i > item:
+                    return False
+        return False
+
+    # __len__() introduces a large performance penalty.
+    def count(self):
+        """ Returns the number of recurrences in this set. It will have go
+            trough the whole recurrence, if this hasn't been done before. """
+        if self._len is None:
+            for x in self:
+                pass
+        return self._len
+
+    def before(self, dt, inc=False):
+        """ Returns the last recurrence before the given datetime instance. The
+            inc keyword defines what happens if dt is an occurrence. With
+            inc=True, if dt itself is an occurrence, it will be returned. """
+        if self._cache_complete:
+            gen = self._cache
+        else:
+            gen = self
+        last = None
+        if inc:
+            for i in gen:
+                if i > dt:
+                    break
+                last = i
+        else:
+            for i in gen:
+                if i >= dt:
+                    break
+                last = i
+        return last
+
+    def after(self, dt, inc=False):
+        """ Returns the first recurrence after the given datetime instance. The
+            inc keyword defines what happens if dt is an occurrence. With
+            inc=True, if dt itself is an occurrence, it will be returned.  """
+        if self._cache_complete:
+            gen = self._cache
+        else:
+            gen = self
+        if inc:
+            for i in gen:
+                if i >= dt:
+                    return i
+        else:
+            for i in gen:
+                if i > dt:
+                    return i
+        return None
+
+    def xafter(self, dt, count=None, inc=False):
+        """
+        Generator which yields up to `count` recurrences after the given
+        datetime instance, equivalent to `after`.
+
+        :param dt:
+            The datetime at which to start generating recurrences.
+
+        :param count:
+            The maximum number of recurrences to generate. If `None` (default),
+            dates are generated until the recurrence rule is exhausted.
+
+        :param inc:
+            If `dt` is an instance of the rule and `inc` is `True`, it is
+            included in the output.
+
+        :yields: Yields a sequence of `datetime` objects.
+        """
+
+        if self._cache_complete:
+            gen = self._cache
+        else:
+            gen = self
+
+        # Select the comparison function
+        if inc:
+            comp = lambda dc, dtc: dc >= dtc
+        else:
+            comp = lambda dc, dtc: dc > dtc
+
+        # Generate dates
+        n = 0
+        for d in gen:
+            if comp(d, dt):
+                if count is not None:
+                    n += 1
+                    if n > count:
+                        break
+
+                yield d
+
+    def between(self, after, before, inc=False, count=1):
+        """ Returns all the occurrences of the rrule between after and before.
+        The inc keyword defines what happens if after and/or before are
+        themselves occurrences. With inc=True, they will be included in the
+        list, if they are found in the recurrence set. """
+        if self._cache_complete:
+            gen = self._cache
+        else:
+            gen = self
+        started = False
+        l = []
+        if inc:
+            for i in gen:
+                if i > before:
+                    break
+                elif not started:
+                    if i >= after:
+                        started = True
+                        l.append(i)
+                else:
+                    l.append(i)
+        else:
+            for i in gen:
+                if i >= before:
+                    break
+                elif not started:
+                    if i > after:
+                        started = True
+                        l.append(i)
+                else:
+                    l.append(i)
+        return l
+
+
+class rrule(rrulebase):
+    """
+    That's the base of the rrule operation. It accepts all the keywords
+    defined in the RFC as its constructor parameters (except byday,
+    which was renamed to byweekday) and more. The constructor prototype is::
+
+            rrule(freq)
+
+    Where freq must be one of YEARLY, MONTHLY, WEEKLY, DAILY, HOURLY, MINUTELY,
+    or SECONDLY.
+
+    .. note::
+        Per RFC section 3.3.10, recurrence instances falling on invalid dates
+        and times are ignored rather than coerced:
+
+            Recurrence rules may generate recurrence instances with an invalid
+            date (e.g., February 30) or nonexistent local time (e.g., 1:30 AM
+            on a day where the local time is moved forward by an hour at 1:00
+            AM).  Such recurrence instances MUST be ignored and MUST NOT be
+            counted as part of the recurrence set.
+
+        This can lead to possibly surprising behavior when, for example, the
+        start date occurs at the end of the month:
+
+        >>> from dateutil.rrule import rrule, MONTHLY
+        >>> from datetime import datetime
+        >>> start_date = datetime(2014, 12, 31)
+        >>> list(rrule(freq=MONTHLY, count=4, dtstart=start_date))
+        ... # doctest: +NORMALIZE_WHITESPACE
+        [datetime.datetime(2014, 12, 31, 0, 0),
+         datetime.datetime(2015, 1, 31, 0, 0),
+         datetime.datetime(2015, 3, 31, 0, 0),
+         datetime.datetime(2015, 5, 31, 0, 0)]
+
+    Additionally, it supports the following keyword arguments:
+
+    :param dtstart:
+        The recurrence start. Besides being the base for the recurrence,
+        missing parameters in the final recurrence instances will also be
+        extracted from this date. If not given, datetime.now() will be used
+        instead.
+    :param interval:
+        The interval between each freq iteration. For example, when using
+        YEARLY, an interval of 2 means once every two years, but with HOURLY,
+        it means once every two hours. The default interval is 1.
+    :param wkst:
+        The week start day. Must be one of the MO, TU, WE constants, or an
+        integer, specifying the first day of the week. This will affect
+        recurrences based on weekly periods. The default week start is got
+        from calendar.firstweekday(), and may be modified by
+        calendar.setfirstweekday().
+    :param count:
+        If given, this determines how many occurrences will be generated.
+
+        .. note::
+            As of version 2.5.0, the use of the keyword ``until`` in conjunction
+            with ``count`` is deprecated, to make sure ``dateutil`` is fully
+            compliant with `RFC-5545 Sec. 3.3.10 <https://tools.ietf.org/
+            html/rfc5545#section-3.3.10>`_. Therefore, ``until`` and ``count``
+            **must not** occur in the same call to ``rrule``.
+    :param until:
+        If given, this must be a datetime instance specifying the upper-bound
+        limit of the recurrence. The last recurrence in the rule is the greatest
+        datetime that is less than or equal to the value specified in the
+        ``until`` parameter.
+
+        .. note::
+            As of version 2.5.0, the use of the keyword ``until`` in conjunction
+            with ``count`` is deprecated, to make sure ``dateutil`` is fully
+            compliant with `RFC-5545 Sec. 3.3.10 <https://tools.ietf.org/
+            html/rfc5545#section-3.3.10>`_. Therefore, ``until`` and ``count``
+            **must not** occur in the same call to ``rrule``.
+    :param bysetpos:
+        If given, it must be either an integer, or a sequence of integers,
+        positive or negative. Each given integer will specify an occurrence
+        number, corresponding to the nth occurrence of the rule inside the
+        frequency period. For example, a bysetpos of -1 if combined with a
+        MONTHLY frequency, and a byweekday of (MO, TU, WE, TH, FR), will
+        result in the last work day of every month.
+    :param bymonth:
+        If given, it must be either an integer, or a sequence of integers,
+        meaning the months to apply the recurrence to.
+    :param bymonthday:
+        If given, it must be either an integer, or a sequence of integers,
+        meaning the month days to apply the recurrence to.
+    :param byyearday:
+        If given, it must be either an integer, or a sequence of integers,
+        meaning the year days to apply the recurrence to.
+    :param byeaster:
+        If given, it must be either an integer, or a sequence of integers,
+        positive or negative. Each integer will define an offset from the
+        Easter Sunday. Passing the offset 0 to byeaster will yield the Easter
+        Sunday itself. This is an extension to the RFC specification.
+    :param byweekno:
+        If given, it must be either an integer, or a sequence of integers,
+        meaning the week numbers to apply the recurrence to. Week numbers
+        have the meaning described in ISO8601, that is, the first week of
+        the year is that containing at least four days of the new year.
+    :param byweekday:
+        If given, it must be either an integer (0 == MO), a sequence of
+        integers, one of the weekday constants (MO, TU, etc), or a sequence
+        of these constants. When given, these variables will define the
+        weekdays where the recurrence will be applied. It's also possible to
+        use an argument n for the weekday instances, which will mean the nth
+        occurrence of this weekday in the period. For example, with MONTHLY,
+        or with YEARLY and BYMONTH, using FR(+1) in byweekday will specify the
+        first friday of the month where the recurrence happens. Notice that in
+        the RFC documentation, this is specified as BYDAY, but was renamed to
+        avoid the ambiguity of that keyword.
+    :param byhour:
+        If given, it must be either an integer, or a sequence of integers,
+        meaning the hours to apply the recurrence to.
+    :param byminute:
+        If given, it must be either an integer, or a sequence of integers,
+        meaning the minutes to apply the recurrence to.
+    :param bysecond:
+        If given, it must be either an integer, or a sequence of integers,
+        meaning the seconds to apply the recurrence to.
+    :param cache:
+        If given, it must be a boolean value specifying to enable or disable
+        caching of results. If you will use the same rrule instance multiple
+        times, enabling caching will improve the performance considerably.
+     """
+    def __init__(self, freq, dtstart=None,
+                 interval=1, wkst=None, count=None, until=None, bysetpos=None,
+                 bymonth=None, bymonthday=None, byyearday=None, byeaster=None,
+                 byweekno=None, byweekday=None,
+                 byhour=None, byminute=None, bysecond=None,
+                 cache=False):
+        super(rrule, self).__init__(cache)
+        global easter
+        if not dtstart:
+            if until and until.tzinfo:
+                dtstart = datetime.datetime.now(tz=until.tzinfo).replace(microsecond=0)
+            else:
+                dtstart = datetime.datetime.now().replace(microsecond=0)
+        elif not isinstance(dtstart, datetime.datetime):
+            dtstart = datetime.datetime.fromordinal(dtstart.toordinal())
+        else:
+            dtstart = dtstart.replace(microsecond=0)
+        self._dtstart = dtstart
+        self._tzinfo = dtstart.tzinfo
+        self._freq = freq
+        self._interval = interval
+        self._count = count
+
+        # Cache the original byxxx rules, if they are provided, as the _byxxx
+        # attributes do not necessarily map to the inputs, and this can be
+        # a problem in generating the strings. Only store things if they've
+        # been supplied (the string retrieval will just use .get())
+        self._original_rule = {}
+
+        if until and not isinstance(until, datetime.datetime):
+            until = datetime.datetime.fromordinal(until.toordinal())
+        self._until = until
+
+        if self._dtstart and self._until:
+            if (self._dtstart.tzinfo is not None) != (self._until.tzinfo is not None):
+                # According to RFC5545 Section 3.3.10:
+                # https://tools.ietf.org/html/rfc5545#section-3.3.10
+                #
+                # > If the "DTSTART" property is specified as a date with UTC
+                # > time or a date with local time and time zone reference,
+                # > then the UNTIL rule part MUST be specified as a date with
+                # > UTC time.
+                raise ValueError(
+                    'RRULE UNTIL values must be specified in UTC when DTSTART '
+                    'is timezone-aware'
+                )
+
+        if count is not None and until:
+            warn("Using both 'count' and 'until' is inconsistent with RFC 5545"
+                 " and has been deprecated in dateutil. Future versions will "
+                 "raise an error.", DeprecationWarning)
+
+        if wkst is None:
+            self._wkst = calendar.firstweekday()
+        elif isinstance(wkst, integer_types):
+            self._wkst = wkst
+        else:
+            self._wkst = wkst.weekday
+
+        if bysetpos is None:
+            self._bysetpos = None
+        elif isinstance(bysetpos, integer_types):
+            if bysetpos == 0 or not (-366 <= bysetpos <= 366):
+                raise ValueError("bysetpos must be between 1 and 366, "
+                                 "or between -366 and -1")
+            self._bysetpos = (bysetpos,)
+        else:
+            self._bysetpos = tuple(bysetpos)
+            for pos in self._bysetpos:
+                if pos == 0 or not (-366 <= pos <= 366):
+                    raise ValueError("bysetpos must be between 1 and 366, "
+                                     "or between -366 and -1")
+
+        if self._bysetpos:
+            self._original_rule['bysetpos'] = self._bysetpos
+
+        if (byweekno is None and byyearday is None and bymonthday is None and
+                byweekday is None and byeaster is None):
+            if freq == YEARLY:
+                if bymonth is None:
+                    bymonth = dtstart.month
+                    self._original_rule['bymonth'] = None
+                bymonthday = dtstart.day
+                self._original_rule['bymonthday'] = None
+            elif freq == MONTHLY:
+                bymonthday = dtstart.day
+                self._original_rule['bymonthday'] = None
+            elif freq == WEEKLY:
+                byweekday = dtstart.weekday()
+                self._original_rule['byweekday'] = None
+
+        # bymonth
+        if bymonth is None:
+            self._bymonth = None
+        else:
+            if isinstance(bymonth, integer_types):
+                bymonth = (bymonth,)
+
+            self._bymonth = tuple(sorted(set(bymonth)))
+
+            if 'bymonth' not in self._original_rule:
+                self._original_rule['bymonth'] = self._bymonth
+
+        # byyearday
+        if byyearday is None:
+            self._byyearday = None
+        else:
+            if isinstance(byyearday, integer_types):
+                byyearday = (byyearday,)
+
+            self._byyearday = tuple(sorted(set(byyearday)))
+            self._original_rule['byyearday'] = self._byyearday
+
+        # byeaster
+        if byeaster is not None:
+            if not easter:
+                from dateutil import easter
+            if isinstance(byeaster, integer_types):
+                self._byeaster = (byeaster,)
+            else:
+                self._byeaster = tuple(sorted(byeaster))
+
+            self._original_rule['byeaster'] = self._byeaster
+        else:
+            self._byeaster = None
+
+        # bymonthday
+        if bymonthday is None:
+            self._bymonthday = ()
+            self._bynmonthday = ()
+        else:
+            if isinstance(bymonthday, integer_types):
+                bymonthday = (bymonthday,)
+
+            bymonthday = set(bymonthday)            # Ensure it's unique
+
+            self._bymonthday = tuple(sorted(x for x in bymonthday if x > 0))
+            self._bynmonthday = tuple(sorted(x for x in bymonthday if x < 0))
+
+            # Storing positive numbers first, then negative numbers
+            if 'bymonthday' not in self._original_rule:
+                self._original_rule['bymonthday'] = tuple(
+                    itertools.chain(self._bymonthday, self._bynmonthday))
+
+        # byweekno
+        if byweekno is None:
+            self._byweekno = None
+        else:
+            if isinstance(byweekno, integer_types):
+                byweekno = (byweekno,)
+
+            self._byweekno = tuple(sorted(set(byweekno)))
+
+            self._original_rule['byweekno'] = self._byweekno
+
+        # byweekday / bynweekday
+        if byweekday is None:
+            self._byweekday = None
+            self._bynweekday = None
+        else:
+            # If it's one of the valid non-sequence types, convert to a
+            # single-element sequence before the iterator that builds the
+            # byweekday set.
+            if isinstance(byweekday, integer_types) or hasattr(byweekday, "n"):
+                byweekday = (byweekday,)
+
+            self._byweekday = set()
+            self._bynweekday = set()
+            for wday in byweekday:
+                if isinstance(wday, integer_types):
+                    self._byweekday.add(wday)
+                elif not wday.n or freq > MONTHLY:
+                    self._byweekday.add(wday.weekday)
+                else:
+                    self._bynweekday.add((wday.weekday, wday.n))
+
+            if not self._byweekday:
+                self._byweekday = None
+            elif not self._bynweekday:
+                self._bynweekday = None
+
+            if self._byweekday is not None:
+                self._byweekday = tuple(sorted(self._byweekday))
+                orig_byweekday = [weekday(x) for x in self._byweekday]
+            else:
+                orig_byweekday = ()
+
+            if self._bynweekday is not None:
+                self._bynweekday = tuple(sorted(self._bynweekday))
+                orig_bynweekday = [weekday(*x) for x in self._bynweekday]
+            else:
+                orig_bynweekday = ()
+
+            if 'byweekday' not in self._original_rule:
+                self._original_rule['byweekday'] = tuple(itertools.chain(
+                    orig_byweekday, orig_bynweekday))
+
+        # byhour
+        if byhour is None:
+            if freq < HOURLY:
+                self._byhour = {dtstart.hour}
+            else:
+                self._byhour = None
+        else:
+            if isinstance(byhour, integer_types):
+                byhour = (byhour,)
+
+            if freq == HOURLY:
+                self._byhour = self.__construct_byset(start=dtstart.hour,
+                                                      byxxx=byhour,
+                                                      base=24)
+            else:
+                self._byhour = set(byhour)
+
+            self._byhour = tuple(sorted(self._byhour))
+            self._original_rule['byhour'] = self._byhour
+
+        # byminute
+        if byminute is None:
+            if freq < MINUTELY:
+                self._byminute = {dtstart.minute}
+            else:
+                self._byminute = None
+        else:
+            if isinstance(byminute, integer_types):
+                byminute = (byminute,)
+
+            if freq == MINUTELY:
+                self._byminute = self.__construct_byset(start=dtstart.minute,
+                                                        byxxx=byminute,
+                                                        base=60)
+            else:
+                self._byminute = set(byminute)
+
+            self._byminute = tuple(sorted(self._byminute))
+            self._original_rule['byminute'] = self._byminute
+
+        # bysecond
+        if bysecond is None:
+            if freq < SECONDLY:
+                self._bysecond = ((dtstart.second,))
+            else:
+                self._bysecond = None
+        else:
+            if isinstance(bysecond, integer_types):
+                bysecond = (bysecond,)
+
+            self._bysecond = set(bysecond)
+
+            if freq == SECONDLY:
+                self._bysecond = self.__construct_byset(start=dtstart.second,
+                                                        byxxx=bysecond,
+                                                        base=60)
+            else:
+                self._bysecond = set(bysecond)
+
+            self._bysecond = tuple(sorted(self._bysecond))
+            self._original_rule['bysecond'] = self._bysecond
+
+        if self._freq >= HOURLY:
+            self._timeset = None
+        else:
+            self._timeset = []
+            for hour in self._byhour:
+                for minute in self._byminute:
+                    for second in self._bysecond:
+                        self._timeset.append(
+                            datetime.time(hour, minute, second,
+                                          tzinfo=self._tzinfo))
+            self._timeset.sort()
+            self._timeset = tuple(self._timeset)
+
+    def __str__(self):
+        """
+        Output a string that would generate this RRULE if passed to rrulestr.
+        This is mostly compatible with RFC5545, except for the
+        dateutil-specific extension BYEASTER.
+        """
+
+        output = []
+        h, m, s = [None] * 3
+        if self._dtstart:
+            output.append(self._dtstart.strftime('DTSTART:%Y%m%dT%H%M%S'))
+            h, m, s = self._dtstart.timetuple()[3:6]
+
+        parts = ['FREQ=' + FREQNAMES[self._freq]]
+        if self._interval != 1:
+            parts.append('INTERVAL=' + str(self._interval))
+
+        if self._wkst:
+            parts.append('WKST=' + repr(weekday(self._wkst))[0:2])
+
+        if self._count is not None:
+            parts.append('COUNT=' + str(self._count))
+
+        if self._until:
+            parts.append(self._until.strftime('UNTIL=%Y%m%dT%H%M%S'))
+
+        if self._original_rule.get('byweekday') is not None:
+            # The str() method on weekday objects doesn't generate
+            # RFC5545-compliant strings, so we should modify that.
+            original_rule = dict(self._original_rule)
+            wday_strings = []
+            for wday in original_rule['byweekday']:
+                if wday.n:
+                    wday_strings.append('{n:+d}{wday}'.format(
+                        n=wday.n,
+                        wday=repr(wday)[0:2]))
+                else:
+                    wday_strings.append(repr(wday))
+
+            original_rule['byweekday'] = wday_strings
+        else:
+            original_rule = self._original_rule
+
+        partfmt = '{name}={vals}'
+        for name, key in [('BYSETPOS', 'bysetpos'),
+                          ('BYMONTH', 'bymonth'),
+                          ('BYMONTHDAY', 'bymonthday'),
+                          ('BYYEARDAY', 'byyearday'),
+                          ('BYWEEKNO', 'byweekno'),
+                          ('BYDAY', 'byweekday'),
+                          ('BYHOUR', 'byhour'),
+                          ('BYMINUTE', 'byminute'),
+                          ('BYSECOND', 'bysecond'),
+                          ('BYEASTER', 'byeaster')]:
+            value = original_rule.get(key)
+            if value:
+                parts.append(partfmt.format(name=name, vals=(','.join(str(v)
+                                                             for v in value))))
+
+        output.append('RRULE:' + ';'.join(parts))
+        return '\n'.join(output)
+
+    def replace(self, **kwargs):
+        """Return new rrule with same attributes except for those attributes given new
+           values by whichever keyword arguments are specified."""
+        new_kwargs = {"interval": self._interval,
+                      "count": self._count,
+                      "dtstart": self._dtstart,
+                      "freq": self._freq,
+                      "until": self._until,
+                      "wkst": self._wkst,
+                      "cache": False if self._cache is None else True }
+        new_kwargs.update(self._original_rule)
+        new_kwargs.update(kwargs)
+        return rrule(**new_kwargs)
+
+    def _iter(self):
+        year, month, day, hour, minute, second, weekday, yearday, _ = \
+            self._dtstart.timetuple()
+
+        # Some local variables to speed things up a bit
+        freq = self._freq
+        interval = self._interval
+        wkst = self._wkst
+        until = self._until
+        bymonth = self._bymonth
+        byweekno = self._byweekno
+        byyearday = self._byyearday
+        byweekday = self._byweekday
+        byeaster = self._byeaster
+        bymonthday = self._bymonthday
+        bynmonthday = self._bynmonthday
+        bysetpos = self._bysetpos
+        byhour = self._byhour
+        byminute = self._byminute
+        bysecond = self._bysecond
+
+        ii = _iterinfo(self)
+        ii.rebuild(year, month)
+
+        getdayset = {YEARLY: ii.ydayset,
+                     MONTHLY: ii.mdayset,
+                     WEEKLY: ii.wdayset,
+                     DAILY: ii.ddayset,
+                     HOURLY: ii.ddayset,
+                     MINUTELY: ii.ddayset,
+                     SECONDLY: ii.ddayset}[freq]
+
+        if freq < HOURLY:
+            timeset = self._timeset
+        else:
+            gettimeset = {HOURLY: ii.htimeset,
+                          MINUTELY: ii.mtimeset,
+                          SECONDLY: ii.stimeset}[freq]
+            if ((freq >= HOURLY and
+                 self._byhour and hour not in self._byhour) or
+                (freq >= MINUTELY and
+                 self._byminute and minute not in self._byminute) or
+                (freq >= SECONDLY and
+                 self._bysecond and second not in self._bysecond)):
+                timeset = ()
+            else:
+                timeset = gettimeset(hour, minute, second)
+
+        total = 0
+        count = self._count
+        while True:
+            # Get dayset with the right frequency
+            dayset, start, end = getdayset(year, month, day)
+
+            # Do the "hard" work ;-)
+            filtered = False
+            for i in dayset[start:end]:
+                if ((bymonth and ii.mmask[i] not in bymonth) or
+                    (byweekno and not ii.wnomask[i]) or
+                    (byweekday and ii.wdaymask[i] not in byweekday) or
+                    (ii.nwdaymask and not ii.nwdaymask[i]) or
+                    (byeaster and not ii.eastermask[i]) or
+                    ((bymonthday or bynmonthday) and
+                     ii.mdaymask[i] not in bymonthday and
+                     ii.nmdaymask[i] not in bynmonthday) or
+                    (byyearday and
+                     ((i < ii.yearlen and i+1 not in byyearday and
+                       -ii.yearlen+i not in byyearday) or
+                      (i >= ii.yearlen and i+1-ii.yearlen not in byyearday and
+                       -ii.nextyearlen+i-ii.yearlen not in byyearday)))):
+                    dayset[i] = None
+                    filtered = True
+
+            # Output results
+            if bysetpos and timeset:
+                poslist = []
+                for pos in bysetpos:
+                    if pos < 0:
+                        daypos, timepos = divmod(pos, len(timeset))
+                    else:
+                        daypos, timepos = divmod(pos-1, len(timeset))
+                    try:
+                        i = [x for x in dayset[start:end]
+                             if x is not None][daypos]
+                        time = timeset[timepos]
+                    except IndexError:
+                        pass
+                    else:
+                        date = datetime.date.fromordinal(ii.yearordinal+i)
+                        res = datetime.datetime.combine(date, time)
+                        if res not in poslist:
+                            poslist.append(res)
+                poslist.sort()
+                for res in poslist:
+                    if until and res > until:
+                        self._len = total
+                        return
+                    elif res >= self._dtstart:
+                        if count is not None:
+                            count -= 1
+                            if count < 0:
+                                self._len = total
+                                return
+                        total += 1
+                        yield res
+            else:
+                for i in dayset[start:end]:
+                    if i is not None:
+                        date = datetime.date.fromordinal(ii.yearordinal + i)
+                        for time in timeset:
+                            res = datetime.datetime.combine(date, time)
+                            if until and res > until:
+                                self._len = total
+                                return
+                            elif res >= self._dtstart:
+                                if count is not None:
+                                    count -= 1
+                                    if count < 0:
+                                        self._len = total
+                                        return
+
+                                total += 1
+                                yield res
+
+            # Handle frequency and interval
+            fixday = False
+            if freq == YEARLY:
+                year += interval
+                if year > datetime.MAXYEAR:
+                    self._len = total
+                    return
+                ii.rebuild(year, month)
+            elif freq == MONTHLY:
+                month += interval
+                if month > 12:
+                    div, mod = divmod(month, 12)
+                    month = mod
+                    year += div
+                    if month == 0:
+                        month = 12
+                        year -= 1
+                    if year > datetime.MAXYEAR:
+                        self._len = total
+                        return
+                ii.rebuild(year, month)
+            elif freq == WEEKLY:
+                if wkst > weekday:
+                    day += -(weekday+1+(6-wkst))+self._interval*7
+                else:
+                    day += -(weekday-wkst)+self._interval*7
+                weekday = wkst
+                fixday = True
+            elif freq == DAILY:
+                day += interval
+                fixday = True
+            elif freq == HOURLY:
+                if filtered:
+                    # Jump to one iteration before next day
+                    hour += ((23-hour)//interval)*interval
+
+                if byhour:
+                    ndays, hour = self.__mod_distance(value=hour,
+                                                      byxxx=self._byhour,
+                                                      base=24)
+                else:
+                    ndays, hour = divmod(hour+interval, 24)
+
+                if ndays:
+                    day += ndays
+                    fixday = True
+
+                timeset = gettimeset(hour, minute, second)
+            elif freq == MINUTELY:
+                if filtered:
+                    # Jump to one iteration before next day
+                    minute += ((1439-(hour*60+minute))//interval)*interval
+
+                valid = False
+                rep_rate = (24*60)
+                for j in range(rep_rate // gcd(interval, rep_rate)):
+                    if byminute:
+                        nhours, minute = \
+                            self.__mod_distance(value=minute,
+                                                byxxx=self._byminute,
+                                                base=60)
+                    else:
+                        nhours, minute = divmod(minute+interval, 60)
+
+                    div, hour = divmod(hour+nhours, 24)
+                    if div:
+                        day += div
+                        fixday = True
+                        filtered = False
+
+                    if not byhour or hour in byhour:
+                        valid = True
+                        break
+
+                if not valid:
+                    raise ValueError('Invalid combination of interval and ' +
+                                     'byhour resulting in empty rule.')
+
+                timeset = gettimeset(hour, minute, second)
+            elif freq == SECONDLY:
+                if filtered:
+                    # Jump to one iteration before next day
+                    second += (((86399 - (hour * 3600 + minute * 60 + second))
+                                // interval) * interval)
+
+                rep_rate = (24 * 3600)
+                valid = False
+                for j in range(0, rep_rate // gcd(interval, rep_rate)):
+                    if bysecond:
+                        nminutes, second = \
+                            self.__mod_distance(value=second,
+                                                byxxx=self._bysecond,
+                                                base=60)
+                    else:
+                        nminutes, second = divmod(second+interval, 60)
+
+                    div, minute = divmod(minute+nminutes, 60)
+                    if div:
+                        hour += div
+                        div, hour = divmod(hour, 24)
+                        if div:
+                            day += div
+                            fixday = True
+
+                    if ((not byhour or hour in byhour) and
+                            (not byminute or minute in byminute) and
+                            (not bysecond or second in bysecond)):
+                        valid = True
+                        break
+
+                if not valid:
+                    raise ValueError('Invalid combination of interval, ' +
+                                     'byhour and byminute resulting in empty' +
+                                     ' rule.')
+
+                timeset = gettimeset(hour, minute, second)
+
+            if fixday and day > 28:
+                daysinmonth = calendar.monthrange(year, month)[1]
+                if day > daysinmonth:
+                    while day > daysinmonth:
+                        day -= daysinmonth
+                        month += 1
+                        if month == 13:
+                            month = 1
+                            year += 1
+                            if year > datetime.MAXYEAR:
+                                self._len = total
+                                return
+                        daysinmonth = calendar.monthrange(year, month)[1]
+                    ii.rebuild(year, month)
+
+    def __construct_byset(self, start, byxxx, base):
+        """
+        If a `BYXXX` sequence is passed to the constructor at the same level as
+        `FREQ` (e.g. `FREQ=HOURLY,BYHOUR={2,4,7},INTERVAL=3`), there are some
+        specifications which cannot be reached given some starting conditions.
+
+        This occurs whenever the interval is not coprime with the base of a
+        given unit and the difference between the starting position and the
+        ending position is not coprime with the greatest common denominator
+        between the interval and the base. For example, with a FREQ of hourly
+        starting at 17:00 and an interval of 4, the only valid values for
+        BYHOUR would be {21, 1, 5, 9, 13, 17}, because 4 and 24 are not
+        coprime.
+
+        :param start:
+            Specifies the starting position.
+        :param byxxx:
+            An iterable containing the list of allowed values.
+        :param base:
+            The largest allowable value for the specified frequency (e.g.
+            24 hours, 60 minutes).
+
+        This does not preserve the type of the iterable, returning a set, since
+        the values should be unique and the order is irrelevant, this will
+        speed up later lookups.
+
+        In the event of an empty set, raises a :exception:`ValueError`, as this
+        results in an empty rrule.
+        """
+
+        cset = set()
+
+        # Support a single byxxx value.
+        if isinstance(byxxx, integer_types):
+            byxxx = (byxxx, )
+
+        for num in byxxx:
+            i_gcd = gcd(self._interval, base)
+            # Use divmod rather than % because we need to wrap negative nums.
+            if i_gcd == 1 or divmod(num - start, i_gcd)[1] == 0:
+                cset.add(num)
+
+        if len(cset) == 0:
+            raise ValueError("Invalid rrule byxxx generates an empty set.")
+
+        return cset
+
+    def __mod_distance(self, value, byxxx, base):
+        """
+        Calculates the next value in a sequence where the `FREQ` parameter is
+        specified along with a `BYXXX` parameter at the same "level"
+        (e.g. `HOURLY` specified with `BYHOUR`).
+
+        :param value:
+            The old value of the component.
+        :param byxxx:
+            The `BYXXX` set, which should have been generated by
+            `rrule._construct_byset`, or something else which checks that a
+            valid rule is present.
+        :param base:
+            The largest allowable value for the specified frequency (e.g.
+            24 hours, 60 minutes).
+
+        If a valid value is not found after `base` iterations (the maximum
+        number before the sequence would start to repeat), this raises a
+        :exception:`ValueError`, as no valid values were found.
+
+        This returns a tuple of `divmod(n*interval, base)`, where `n` is the
+        smallest number of `interval` repetitions until the next specified
+        value in `byxxx` is found.
+        """
+        accumulator = 0
+        for ii in range(1, base + 1):
+            # Using divmod() over % to account for negative intervals
+            div, value = divmod(value + self._interval, base)
+            accumulator += div
+            if value in byxxx:
+                return (accumulator, value)
+
+
+class _iterinfo(object):
+    __slots__ = ["rrule", "lastyear", "lastmonth",
+                 "yearlen", "nextyearlen", "yearordinal", "yearweekday",
+                 "mmask", "mrange", "mdaymask", "nmdaymask",
+                 "wdaymask", "wnomask", "nwdaymask", "eastermask"]
+
+    def __init__(self, rrule):
+        for attr in self.__slots__:
+            setattr(self, attr, None)
+        self.rrule = rrule
+
+    def rebuild(self, year, month):
+        # Every mask is 7 days longer to handle cross-year weekly periods.
+        rr = self.rrule
+        if year != self.lastyear:
+            self.yearlen = 365 + calendar.isleap(year)
+            self.nextyearlen = 365 + calendar.isleap(year + 1)
+            firstyday = datetime.date(year, 1, 1)
+            self.yearordinal = firstyday.toordinal()
+            self.yearweekday = firstyday.weekday()
+
+            wday = datetime.date(year, 1, 1).weekday()
+            if self.yearlen == 365:
+                self.mmask = M365MASK
+                self.mdaymask = MDAY365MASK
+                self.nmdaymask = NMDAY365MASK
+                self.wdaymask = WDAYMASK[wday:]
+                self.mrange = M365RANGE
+            else:
+                self.mmask = M366MASK
+                self.mdaymask = MDAY366MASK
+                self.nmdaymask = NMDAY366MASK
+                self.wdaymask = WDAYMASK[wday:]
+                self.mrange = M366RANGE
+
+            if not rr._byweekno:
+                self.wnomask = None
+            else:
+                self.wnomask = [0]*(self.yearlen+7)
+                # no1wkst = firstwkst = self.wdaymask.index(rr._wkst)
+                no1wkst = firstwkst = (7-self.yearweekday+rr._wkst) % 7
+                if no1wkst >= 4:
+                    no1wkst = 0
+                    # Number of days in the year, plus the days we got
+                    # from last year.
+                    wyearlen = self.yearlen+(self.yearweekday-rr._wkst) % 7
+                else:
+                    # Number of days in the year, minus the days we
+                    # left in last year.
+                    wyearlen = self.yearlen-no1wkst
+                div, mod = divmod(wyearlen, 7)
+                numweeks = div+mod//4
+                for n in rr._byweekno:
+                    if n < 0:
+                        n += numweeks+1
+                    if not (0 < n <= numweeks):
+                        continue
+                    if n > 1:
+                        i = no1wkst+(n-1)*7
+                        if no1wkst != firstwkst:
+                            i -= 7-firstwkst
+                    else:
+                        i = no1wkst
+                    for j in range(7):
+                        self.wnomask[i] = 1
+                        i += 1
+                        if self.wdaymask[i] == rr._wkst:
+                            break
+                if 1 in rr._byweekno:
+                    # Check week number 1 of next year as well
+                    # TODO: Check -numweeks for next year.
+                    i = no1wkst+numweeks*7
+                    if no1wkst != firstwkst:
+                        i -= 7-firstwkst
+                    if i < self.yearlen:
+                        # If week starts in next year, we
+                        # don't care about it.
+                        for j in range(7):
+                            self.wnomask[i] = 1
+                            i += 1
+                            if self.wdaymask[i] == rr._wkst:
+                                break
+                if no1wkst:
+                    # Check last week number of last year as
+                    # well. If no1wkst is 0, either the year
+                    # started on week start, or week number 1
+                    # got days from last year, so there are no
+                    # days from last year's last week number in
+                    # this year.
+                    if -1 not in rr._byweekno:
+                        lyearweekday = datetime.date(year-1, 1, 1).weekday()
+                        lno1wkst = (7-lyearweekday+rr._wkst) % 7
+                        lyearlen = 365+calendar.isleap(year-1)
+                        if lno1wkst >= 4:
+                            lno1wkst = 0
+                            lnumweeks = 52+(lyearlen +
+                                            (lyearweekday-rr._wkst) % 7) % 7//4
+                        else:
+                            lnumweeks = 52+(self.yearlen-no1wkst) % 7//4
+                    else:
+                        lnumweeks = -1
+                    if lnumweeks in rr._byweekno:
+                        for i in range(no1wkst):
+                            self.wnomask[i] = 1
+
+        if (rr._bynweekday and (month != self.lastmonth or
+                                year != self.lastyear)):
+            ranges = []
+            if rr._freq == YEARLY:
+                if rr._bymonth:
+                    for month in rr._bymonth:
+                        ranges.append(self.mrange[month-1:month+1])
+                else:
+                    ranges = [(0, self.yearlen)]
+            elif rr._freq == MONTHLY:
+                ranges = [self.mrange[month-1:month+1]]
+            if ranges:
+                # Weekly frequency won't get here, so we may not
+                # care about cross-year weekly periods.
+                self.nwdaymask = [0]*self.yearlen
+                for first, last in ranges:
+                    last -= 1
+                    for wday, n in rr._bynweekday:
+                        if n < 0:
+                            i = last+(n+1)*7
+                            i -= (self.wdaymask[i]-wday) % 7
+                        else:
+                            i = first+(n-1)*7
+                            i += (7-self.wdaymask[i]+wday) % 7
+                        if first <= i <= last:
+                            self.nwdaymask[i] = 1
+
+        if rr._byeaster:
+            self.eastermask = [0]*(self.yearlen+7)
+            eyday = easter.easter(year).toordinal()-self.yearordinal
+            for offset in rr._byeaster:
+                self.eastermask[eyday+offset] = 1
+
+        self.lastyear = year
+        self.lastmonth = month
+
+    def ydayset(self, year, month, day):
+        return list(range(self.yearlen)), 0, self.yearlen
+
+    def mdayset(self, year, month, day):
+        dset = [None]*self.yearlen
+        start, end = self.mrange[month-1:month+1]
+        for i in range(start, end):
+            dset[i] = i
+        return dset, start, end
+
+    def wdayset(self, year, month, day):
+        # We need to handle cross-year weeks here.
+        dset = [None]*(self.yearlen+7)
+        i = datetime.date(year, month, day).toordinal()-self.yearordinal
+        start = i
+        for j in range(7):
+            dset[i] = i
+            i += 1
+            # if (not (0 <= i < self.yearlen) or
+            #    self.wdaymask[i] == self.rrule._wkst):
+            # This will cross the year boundary, if necessary.
+            if self.wdaymask[i] == self.rrule._wkst:
+                break
+        return dset, start, i
+
+    def ddayset(self, year, month, day):
+        dset = [None] * self.yearlen
+        i = datetime.date(year, month, day).toordinal() - self.yearordinal
+        dset[i] = i
+        return dset, i, i + 1
+
+    def htimeset(self, hour, minute, second):
+        tset = []
+        rr = self.rrule
+        for minute in rr._byminute:
+            for second in rr._bysecond:
+                tset.append(datetime.time(hour, minute, second,
+                                          tzinfo=rr._tzinfo))
+        tset.sort()
+        return tset
+
+    def mtimeset(self, hour, minute, second):
+        tset = []
+        rr = self.rrule
+        for second in rr._bysecond:
+            tset.append(datetime.time(hour, minute, second, tzinfo=rr._tzinfo))
+        tset.sort()
+        return tset
+
+    def stimeset(self, hour, minute, second):
+        return (datetime.time(hour, minute, second,
+                tzinfo=self.rrule._tzinfo),)
+
+
+class rruleset(rrulebase):
+    """ The rruleset type allows more complex recurrence setups, mixing
+    multiple rules, dates, exclusion rules, and exclusion dates. The type
+    constructor takes the following keyword arguments:
+
+    :param cache: If True, caching of results will be enabled, improving
+                  performance of multiple queries considerably. """
+
+    class _genitem(object):
+        def __init__(self, genlist, gen):
+            try:
+                self.dt = advance_iterator(gen)
+                genlist.append(self)
+            except StopIteration:
+                pass
+            self.genlist = genlist
+            self.gen = gen
+
+        def __next__(self):
+            try:
+                self.dt = advance_iterator(self.gen)
+            except StopIteration:
+                if self.genlist[0] is self:
+                    heapq.heappop(self.genlist)
+                else:
+                    self.genlist.remove(self)
+                    heapq.heapify(self.genlist)
+
+        next = __next__
+
+        def __lt__(self, other):
+            return self.dt < other.dt
+
+        def __gt__(self, other):
+            return self.dt > other.dt
+
+        def __eq__(self, other):
+            return self.dt == other.dt
+
+        def __ne__(self, other):
+            return self.dt != other.dt
+
+    def __init__(self, cache=False):
+        super(rruleset, self).__init__(cache)
+        self._rrule = []
+        self._rdate = []
+        self._exrule = []
+        self._exdate = []
+
+    @_invalidates_cache
+    def rrule(self, rrule):
+        """ Include the given :py:class:`rrule` instance in the recurrence set
+            generation. """
+        self._rrule.append(rrule)
+
+    @_invalidates_cache
+    def rdate(self, rdate):
+        """ Include the given :py:class:`datetime` instance in the recurrence
+            set generation. """
+        self._rdate.append(rdate)
+
+    @_invalidates_cache
+    def exrule(self, exrule):
+        """ Include the given rrule instance in the recurrence set exclusion
+            list. Dates which are part of the given recurrence rules will not
+            be generated, even if some inclusive rrule or rdate matches them.
+        """
+        self._exrule.append(exrule)
+
+    @_invalidates_cache
+    def exdate(self, exdate):
+        """ Include the given datetime instance in the recurrence set
+            exclusion list. Dates included that way will not be generated,
+            even if some inclusive rrule or rdate matches them. """
+        self._exdate.append(exdate)
+
+    def _iter(self):
+        rlist = []
+        self._rdate.sort()
+        self._genitem(rlist, iter(self._rdate))
+        for gen in [iter(x) for x in self._rrule]:
+            self._genitem(rlist, gen)
+        exlist = []
+        self._exdate.sort()
+        self._genitem(exlist, iter(self._exdate))
+        for gen in [iter(x) for x in self._exrule]:
+            self._genitem(exlist, gen)
+        lastdt = None
+        total = 0
+        heapq.heapify(rlist)
+        heapq.heapify(exlist)
+        while rlist:
+            ritem = rlist[0]
+            if not lastdt or lastdt != ritem.dt:
+                while exlist and exlist[0] < ritem:
+                    exitem = exlist[0]
+                    advance_iterator(exitem)
+                    if exlist and exlist[0] is exitem:
+                        heapq.heapreplace(exlist, exitem)
+                if not exlist or ritem != exlist[0]:
+                    total += 1
+                    yield ritem.dt
+                lastdt = ritem.dt
+            advance_iterator(ritem)
+            if rlist and rlist[0] is ritem:
+                heapq.heapreplace(rlist, ritem)
+        self._len = total
+
+
+
+
+class _rrulestr(object):
+    """ Parses a string representation of a recurrence rule or set of
+    recurrence rules.
+
+    :param s:
+        Required, a string defining one or more recurrence rules.
+
+    :param dtstart:
+        If given, used as the default recurrence start if not specified in the
+        rule string.
+
+    :param cache:
+        If set ``True`` caching of results will be enabled, improving
+        performance of multiple queries considerably.
+
+    :param unfold:
+        If set ``True`` indicates that a rule string is split over more
+        than one line and should be joined before processing.
+
+    :param forceset:
+        If set ``True`` forces a :class:`dateutil.rrule.rruleset` to
+        be returned.
+
+    :param compatible:
+        If set ``True`` forces ``unfold`` and ``forceset`` to be ``True``.
+
+    :param ignoretz:
+        If set ``True``, time zones in parsed strings are ignored and a naive
+        :class:`datetime.datetime` object is returned.
+
+    :param tzids:
+        If given, a callable or mapping used to retrieve a
+        :class:`datetime.tzinfo` from a string representation.
+        Defaults to :func:`dateutil.tz.gettz`.
+
+    :param tzinfos:
+        Additional time zone names / aliases which may be present in a string
+        representation.  See :func:`dateutil.parser.parse` for more
+        information.
+
+    :return:
+        Returns a :class:`dateutil.rrule.rruleset` or
+        :class:`dateutil.rrule.rrule`
+    """
+
+    _freq_map = {"YEARLY": YEARLY,
+                 "MONTHLY": MONTHLY,
+                 "WEEKLY": WEEKLY,
+                 "DAILY": DAILY,
+                 "HOURLY": HOURLY,
+                 "MINUTELY": MINUTELY,
+                 "SECONDLY": SECONDLY}
+
+    _weekday_map = {"MO": 0, "TU": 1, "WE": 2, "TH": 3,
+                    "FR": 4, "SA": 5, "SU": 6}
+
+    def _handle_int(self, rrkwargs, name, value, **kwargs):
+        rrkwargs[name.lower()] = int(value)
+
+    def _handle_int_list(self, rrkwargs, name, value, **kwargs):
+        rrkwargs[name.lower()] = [int(x) for x in value.split(',')]
+
+    _handle_INTERVAL = _handle_int
+    _handle_COUNT = _handle_int
+    _handle_BYSETPOS = _handle_int_list
+    _handle_BYMONTH = _handle_int_list
+    _handle_BYMONTHDAY = _handle_int_list
+    _handle_BYYEARDAY = _handle_int_list
+    _handle_BYEASTER = _handle_int_list
+    _handle_BYWEEKNO = _handle_int_list
+    _handle_BYHOUR = _handle_int_list
+    _handle_BYMINUTE = _handle_int_list
+    _handle_BYSECOND = _handle_int_list
+
+    def _handle_FREQ(self, rrkwargs, name, value, **kwargs):
+        rrkwargs["freq"] = self._freq_map[value]
+
+    def _handle_UNTIL(self, rrkwargs, name, value, **kwargs):
+        global parser
+        if not parser:
+            from dateutil import parser
+        try:
+            rrkwargs["until"] = parser.parse(value,
+                                             ignoretz=kwargs.get("ignoretz"),
+                                             tzinfos=kwargs.get("tzinfos"))
+        except ValueError:
+            raise ValueError("invalid until date")
+
+    def _handle_WKST(self, rrkwargs, name, value, **kwargs):
+        rrkwargs["wkst"] = self._weekday_map[value]
+
+    def _handle_BYWEEKDAY(self, rrkwargs, name, value, **kwargs):
+        """
+        Two ways to specify this: +1MO or MO(+1)
+        """
+        l = []
+        for wday in value.split(','):
+            if '(' in wday:
+                # If it's of the form TH(+1), etc.
+                splt = wday.split('(')
+                w = splt[0]
+                n = int(splt[1][:-1])
+            elif len(wday):
+                # If it's of the form +1MO
+                for i in range(len(wday)):
+                    if wday[i] not in '+-0123456789':
+                        break
+                n = wday[:i] or None
+                w = wday[i:]
+                if n:
+                    n = int(n)
+            else:
+                raise ValueError("Invalid (empty) BYDAY specification.")
+
+            l.append(weekdays[self._weekday_map[w]](n))
+        rrkwargs["byweekday"] = l
+
+    _handle_BYDAY = _handle_BYWEEKDAY
+
+    def _parse_rfc_rrule(self, line,
+                         dtstart=None,
+                         cache=False,
+                         ignoretz=False,
+                         tzinfos=None):
+        if line.find(':') != -1:
+            name, value = line.split(':')
+            if name != "RRULE":
+                raise ValueError("unknown parameter name")
+        else:
+            value = line
+        rrkwargs = {}
+        for pair in value.split(';'):
+            name, value = pair.split('=')
+            name = name.upper()
+            value = value.upper()
+            try:
+                getattr(self, "_handle_"+name)(rrkwargs, name, value,
+                                               ignoretz=ignoretz,
+                                               tzinfos=tzinfos)
+            except AttributeError:
+                raise ValueError("unknown parameter '%s'" % name)
+            except (KeyError, ValueError):
+                raise ValueError("invalid '%s': %s" % (name, value))
+        return rrule(dtstart=dtstart, cache=cache, **rrkwargs)
+
+    def _parse_date_value(self, date_value, parms, rule_tzids,
+                          ignoretz, tzids, tzinfos):
+        global parser
+        if not parser:
+            from dateutil import parser
+
+        datevals = []
+        value_found = False
+        TZID = None
+
+        for parm in parms:
+            if parm.startswith("TZID="):
+                try:
+                    tzkey = rule_tzids[parm.split('TZID=')[-1]]
+                except KeyError:
+                    continue
+                if tzids is None:
+                    from . import tz
+                    tzlookup = tz.gettz
+                elif callable(tzids):
+                    tzlookup = tzids
+                else:
+                    tzlookup = getattr(tzids, 'get', None)
+                    if tzlookup is None:
+                        msg = ('tzids must be a callable, mapping, or None, '
+                               'not %s' % tzids)
+                        raise ValueError(msg)
+
+                TZID = tzlookup(tzkey)
+                continue
+
+            # RFC 5445 3.8.2.4: The VALUE parameter is optional, but may be found
+            # only once.
+            if parm not in {"VALUE=DATE-TIME", "VALUE=DATE"}:
+                raise ValueError("unsupported parm: " + parm)
+            else:
+                if value_found:
+                    msg = ("Duplicate value parameter found in: " + parm)
+                    raise ValueError(msg)
+                value_found = True
+
+        for datestr in date_value.split(','):
+            date = parser.parse(datestr, ignoretz=ignoretz, tzinfos=tzinfos)
+            if TZID is not None:
+                if date.tzinfo is None:
+                    date = date.replace(tzinfo=TZID)
+                else:
+                    raise ValueError('DTSTART/EXDATE specifies multiple timezone')
+            datevals.append(date)
+
+        return datevals
+
+    def _parse_rfc(self, s,
+                   dtstart=None,
+                   cache=False,
+                   unfold=False,
+                   forceset=False,
+                   compatible=False,
+                   ignoretz=False,
+                   tzids=None,
+                   tzinfos=None):
+        global parser
+        if compatible:
+            forceset = True
+            unfold = True
+
+        TZID_NAMES = dict(map(
+            lambda x: (x.upper(), x),
+            re.findall('TZID=(?P<name>[^:]+):', s)
+        ))
+        s = s.upper()
+        if not s.strip():
+            raise ValueError("empty string")
+        if unfold:
+            lines = s.splitlines()
+            i = 0
+            while i < len(lines):
+                line = lines[i].rstrip()
+                if not line:
+                    del lines[i]
+                elif i > 0 and line[0] == " ":
+                    lines[i-1] += line[1:]
+                    del lines[i]
+                else:
+                    i += 1
+        else:
+            lines = s.split()
+        if (not forceset and len(lines) == 1 and (s.find(':') == -1 or
+                                                  s.startswith('RRULE:'))):
+            return self._parse_rfc_rrule(lines[0], cache=cache,
+                                         dtstart=dtstart, ignoretz=ignoretz,
+                                         tzinfos=tzinfos)
+        else:
+            rrulevals = []
+            rdatevals = []
+            exrulevals = []
+            exdatevals = []
+            for line in lines:
+                if not line:
+                    continue
+                if line.find(':') == -1:
+                    name = "RRULE"
+                    value = line
+                else:
+                    name, value = line.split(':', 1)
+                parms = name.split(';')
+                if not parms:
+                    raise ValueError("empty property name")
+                name = parms[0]
+                parms = parms[1:]
+                if name == "RRULE":
+                    for parm in parms:
+                        raise ValueError("unsupported RRULE parm: "+parm)
+                    rrulevals.append(value)
+                elif name == "RDATE":
+                    for parm in parms:
+                        if parm != "VALUE=DATE-TIME":
+                            raise ValueError("unsupported RDATE parm: "+parm)
+                    rdatevals.append(value)
+                elif name == "EXRULE":
+                    for parm in parms:
+                        raise ValueError("unsupported EXRULE parm: "+parm)
+                    exrulevals.append(value)
+                elif name == "EXDATE":
+                    exdatevals.extend(
+                        self._parse_date_value(value, parms,
+                                               TZID_NAMES, ignoretz,
+                                               tzids, tzinfos)
+                    )
+                elif name == "DTSTART":
+                    dtvals = self._parse_date_value(value, parms, TZID_NAMES,
+                                                    ignoretz, tzids, tzinfos)
+                    if len(dtvals) != 1:
+                        raise ValueError("Multiple DTSTART values specified:" +
+                                         value)
+                    dtstart = dtvals[0]
+                else:
+                    raise ValueError("unsupported property: "+name)
+            if (forceset or len(rrulevals) > 1 or rdatevals
+                    or exrulevals or exdatevals):
+                if not parser and (rdatevals or exdatevals):
+                    from dateutil import parser
+                rset = rruleset(cache=cache)
+                for value in rrulevals:
+                    rset.rrule(self._parse_rfc_rrule(value, dtstart=dtstart,
+                                                     ignoretz=ignoretz,
+                                                     tzinfos=tzinfos))
+                for value in rdatevals:
+                    for datestr in value.split(','):
+                        rset.rdate(parser.parse(datestr,
+                                                ignoretz=ignoretz,
+                                                tzinfos=tzinfos))
+                for value in exrulevals:
+                    rset.exrule(self._parse_rfc_rrule(value, dtstart=dtstart,
+                                                      ignoretz=ignoretz,
+                                                      tzinfos=tzinfos))
+                for value in exdatevals:
+                    rset.exdate(value)
+                if compatible and dtstart:
+                    rset.rdate(dtstart)
+                return rset
+            else:
+                return self._parse_rfc_rrule(rrulevals[0],
+                                             dtstart=dtstart,
+                                             cache=cache,
+                                             ignoretz=ignoretz,
+                                             tzinfos=tzinfos)
+
+    def __call__(self, s, **kwargs):
+        return self._parse_rfc(s, **kwargs)
+
+
+rrulestr = _rrulestr()
+
+# vim:ts=4:sw=4:et
diff --git a/myvenv/Lib/site-packages/dateutil/tz/__init__.py b/myvenv/Lib/site-packages/dateutil/tz/__init__.py
new file mode 100644
index 0000000..af1352c
--- /dev/null
+++ b/myvenv/Lib/site-packages/dateutil/tz/__init__.py
@@ -0,0 +1,12 @@
+# -*- coding: utf-8 -*-
+from .tz import *
+from .tz import __doc__
+
+__all__ = ["tzutc", "tzoffset", "tzlocal", "tzfile", "tzrange",
+           "tzstr", "tzical", "tzwin", "tzwinlocal", "gettz",
+           "enfold", "datetime_ambiguous", "datetime_exists",
+           "resolve_imaginary", "UTC", "DeprecatedTzFormatWarning"]
+
+
+class DeprecatedTzFormatWarning(Warning):
+    """Warning raised when time zones are parsed from deprecated formats."""
diff --git a/myvenv/Lib/site-packages/dateutil/tz/__pycache__/__init__.cpython-39.pyc b/myvenv/Lib/site-packages/dateutil/tz/__pycache__/__init__.cpython-39.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..fb747dcd97cc329590795fd356baf47fe17fb92d
GIT binary patch
literal 692
zcmY*X&2H2%5Vn)eZnU(baO0M1khX;@La3rExS$G&El5@*%Z(?&UB^ysXP3<t?z{sx
z-hn5{l@k&YcTU*Zs=!Dddwx9gePgr3!#VQu>+?_k4I}hD82`$|8>fERM_zHnu|%t|
zM-nxdV2o<S<1d&*FA<;c<P+iv#2;fa;nO!LpZ)MPQH}@v(5o4xT$hyQM<j85=gJ{<
zy{;+?j?7#yb;%@|y1o(;g2OOXLrAsG1iuJzZ*GMm^Ksi>NosJeCsR<BmYm$@%z+aP
zP}W?Ey3?H{cW-_0L0D(WJp)$D4N%drS}10ALwvD18y+m7HBkBreAU0ureW?KGfJqs
z^i2MfK<(5od*l@$f;l1)$0X*FryiTBclXb4ZfAxG3q0Gt2bBeIS+5n?j2XyUW<sbk
zy2<!$`>Yzf+vD?mGNhC$<{8mpPHCfgC&T%G((8`NeZ<7R-&bV9dyeY&_1Tl+!h*5I
zQq;mRnY{(YJLQTc*tOGb@!IGsD4i{QFIL0is%^@J-NM2#yIwpln%xG}rg$YT3o9Hf
zT2`)oo-M*SJ169c>rW^ZN;pc7+ug|djt5{PuTnhP=Xo+j{xt)>@CTTb9{cQOFk{MJ
Y(EC#;F{DrTM4yFPHcT_c2T?lx1AHdQ(*OVf

literal 0
HcmV?d00001

diff --git a/myvenv/Lib/site-packages/dateutil/tz/__pycache__/_common.cpython-39.pyc b/myvenv/Lib/site-packages/dateutil/tz/__pycache__/_common.cpython-39.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..fa12f2a40e8fde6021230eb0bcde7eb61953c28a
GIT binary patch
literal 10788
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

literal 0
HcmV?d00001

diff --git a/myvenv/Lib/site-packages/dateutil/tz/__pycache__/_factories.cpython-39.pyc b/myvenv/Lib/site-packages/dateutil/tz/__pycache__/_factories.cpython-39.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..8c60432edc37c3ea807aace3d4ef4e6b8cc9d669
GIT binary patch
literal 2941
zcmb_e&5s*36t`z4lgU>J^n-pt2^66Qy4#i(flvj7R?DT@MQmwB6lpY!o$Mr&nP59D
z8%-~4MNd%9oU(`m`!D&*sS*-*F7TeSv-#L<Pk7`vetsVN`RDh0o}gAM6DWT_{fm{L
z^(QLx#R26eR5=8}2%|9>&=#fGwqmPg!P}1QfzxtKpA#1bZp)?Q3&IM_eN33ki#vA9
z1HH&R&^@D<KrgW}=w)64dl~c!tAbuNdWBh=q*;3gtCA+wB^3=g<FN|XL91*C#sz1$
zqfmib^wpN&0Sj^Pe6jZxc@Y|%v?wDj>j~*lMw#{4YuTo4GY8tv6XK9o0TwOjs(*L9
z871AAt27De+>|&YLh=$+*#N;vMtq{EvNEz`_3VsBB(r{}KO2ZP$sS#AI{MW7guWjo
zQUyuKbwQ4XT!;cpq&@79l<)7^+74r>oj`P@cKZ+Uy$2Zhei#Q*!U*z@y!CPWYsrOd
z-;TPG3gX5+p0H7(+PAsvt901@Qlvc|D%tL&BIxp!-f$4E$cKDI1+u?#wLRE=z>^2<
zJJGjo87aOp48lH)lWi6#K2lM9S&c9Iogh@Hh`3xGZi^E5iB%#5gt~Nma(-j0`3@E!
zL--IjtOl}-^Z>RI5odGQCibp@5iOfUxG=Kmh$6g%ha$%(4C2`Ln^aV=_ZW&gikDHm
z0-^?0;^%~xY5lN!`xCebb`lJ@@9VPf4^lRYv0e53??yp9wV2(SS#@n6`H<uK(>2Y)
z#s#xFx`@6SXgpeVjME{yGG8oEZbFqOK;#i=qLH+0W<&Hj;L+Xjnt^?L0mwY|Ht_q?
zAQb7*jC5&6f1_WKJnmo)I==Q<thh+vBpYE0(I!TCj19FFsD|KbBof&O8XdvqRwIwb
zrllRV4e^Lb3QP-gJH<_EFCU8DOWX^w#>Z#wuI6@#d2t-90tbqdD9)fTpv{Cq?o}}0
zSTmnT1?tbo?KQ9-#tj%uS`I_@y1EVyZFD-4tLLGJo*NY3frcUzYQoP__6~-j!vIyk
zpxjB(^m`0~a?e_ShUeQX>Ec5k^abze<M*L)FNjAR6H$~Vf!NmPmRFzAT?#xxeg5zW
zIG{A?`e6`maed*%c3(zgE|7t`27E|EIAkAQeO;MOV3ecI&qVZD_)y|bkRl#+t?`-V
z^=3RqfAf+@_$}y=e}GVs=oH<t#OaJ?*2LN+9qW;uc&K3u*lbUn%w}ZQdgNq|;rt!b
zTgbpVadG4>JYXfg;?vJ5z~A#GC9pcXkWhPGX5S#HjIA9wlwPIph#yhwRgpA5L6W@>
zxx|5I$EGByUnTO_D}<Wo8<3d;M`y3E!7brH?o`d1E=MvCQ-Oh?Ybu5O=}QhwVN$$-
zeRh{CU4{^1yc3LKH4WbjU=j^uAErZX$2<{lqFMwMa_FF0FsVs9m_oFhnkdwEpKmY6
z|3S*a?<F1zp2soEvyQ>3c(nYl<9PIhU8k3hKA~wUTi+`z6Acsel)^KjnU+}+S3)Z8
z=P9o!uqTANQ1IYyLY3!19O7G%0oNW=V4Mq#^B_OMeW}F%NH=i~)@_!=>+lljgFd~m
z#vxK6?Pf0c{sN;KFEGyNB;LYxkPY(_8BV^KQXj#0i<C0={Q)2cd|C?;*Sstc>KEvp
zBM#)GCE{F%uqPAC5C{G;=7{6$6Q=-#%83I61L73nn}Q*Z2gFHG>y@5MoFA5nBi;t5
znq~1myu?KmO%x`Re}JuPDBeZ!9*XNIE`i8tKxL~sOl9=FKV^crj3btAf&(Ue3PyPf
z1cCSmCM>hy5UBeUXwo%t1t&f#-mik;L#VTO$DU?Yd-$7!f0ZT)m_XB&FpXpQXM$8d
z&DE_EIKMhbA8=_huE1;8-0bF>GTae3;ZbXA@5c1c;uHJ@lK8Jsg*{cRs$H+t-TL|e
E01ju9rvLx|

literal 0
HcmV?d00001

diff --git a/myvenv/Lib/site-packages/dateutil/tz/__pycache__/tz.cpython-39.pyc b/myvenv/Lib/site-packages/dateutil/tz/__pycache__/tz.cpython-39.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..10ee9011cc4cd1e491674c31db261197b6c4fbfe
GIT binary patch
literal 44958
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

literal 0
HcmV?d00001

diff --git a/myvenv/Lib/site-packages/dateutil/tz/__pycache__/win.cpython-39.pyc b/myvenv/Lib/site-packages/dateutil/tz/__pycache__/win.cpython-39.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..aa545a394a59975cd51f3795d19f73a780dcd82e
GIT binary patch
literal 11430
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

literal 0
HcmV?d00001

diff --git a/myvenv/Lib/site-packages/dateutil/tz/_common.py b/myvenv/Lib/site-packages/dateutil/tz/_common.py
new file mode 100644
index 0000000..e6ac118
--- /dev/null
+++ b/myvenv/Lib/site-packages/dateutil/tz/_common.py
@@ -0,0 +1,419 @@
+from six import PY2
+
+from functools import wraps
+
+from datetime import datetime, timedelta, tzinfo
+
+
+ZERO = timedelta(0)
+
+__all__ = ['tzname_in_python2', 'enfold']
+
+
+def tzname_in_python2(namefunc):
+    """Change unicode output into bytestrings in Python 2
+
+    tzname() API changed in Python 3. It used to return bytes, but was changed
+    to unicode strings
+    """
+    if PY2:
+        @wraps(namefunc)
+        def adjust_encoding(*args, **kwargs):
+            name = namefunc(*args, **kwargs)
+            if name is not None:
+                name = name.encode()
+
+            return name
+
+        return adjust_encoding
+    else:
+        return namefunc
+
+
+# The following is adapted from Alexander Belopolsky's tz library
+# https://github.com/abalkin/tz
+if hasattr(datetime, 'fold'):
+    # This is the pre-python 3.6 fold situation
+    def enfold(dt, fold=1):
+        """
+        Provides a unified interface for assigning the ``fold`` attribute to
+        datetimes both before and after the implementation of PEP-495.
+
+        :param fold:
+            The value for the ``fold`` attribute in the returned datetime. This
+            should be either 0 or 1.
+
+        :return:
+            Returns an object for which ``getattr(dt, 'fold', 0)`` returns
+            ``fold`` for all versions of Python. In versions prior to
+            Python 3.6, this is a ``_DatetimeWithFold`` object, which is a
+            subclass of :py:class:`datetime.datetime` with the ``fold``
+            attribute added, if ``fold`` is 1.
+
+        .. versionadded:: 2.6.0
+        """
+        return dt.replace(fold=fold)
+
+else:
+    class _DatetimeWithFold(datetime):
+        """
+        This is a class designed to provide a PEP 495-compliant interface for
+        Python versions before 3.6. It is used only for dates in a fold, so
+        the ``fold`` attribute is fixed at ``1``.
+
+        .. versionadded:: 2.6.0
+        """
+        __slots__ = ()
+
+        def replace(self, *args, **kwargs):
+            """
+            Return a datetime with the same attributes, except for those
+            attributes given new values by whichever keyword arguments are
+            specified. Note that tzinfo=None can be specified to create a naive
+            datetime from an aware datetime with no conversion of date and time
+            data.
+
+            This is reimplemented in ``_DatetimeWithFold`` because pypy3 will
+            return a ``datetime.datetime`` even if ``fold`` is unchanged.
+            """
+            argnames = (
+                'year', 'month', 'day', 'hour', 'minute', 'second',
+                'microsecond', 'tzinfo'
+            )
+
+            for arg, argname in zip(args, argnames):
+                if argname in kwargs:
+                    raise TypeError('Duplicate argument: {}'.format(argname))
+
+                kwargs[argname] = arg
+
+            for argname in argnames:
+                if argname not in kwargs:
+                    kwargs[argname] = getattr(self, argname)
+
+            dt_class = self.__class__ if kwargs.get('fold', 1) else datetime
+
+            return dt_class(**kwargs)
+
+        @property
+        def fold(self):
+            return 1
+
+    def enfold(dt, fold=1):
+        """
+        Provides a unified interface for assigning the ``fold`` attribute to
+        datetimes both before and after the implementation of PEP-495.
+
+        :param fold:
+            The value for the ``fold`` attribute in the returned datetime. This
+            should be either 0 or 1.
+
+        :return:
+            Returns an object for which ``getattr(dt, 'fold', 0)`` returns
+            ``fold`` for all versions of Python. In versions prior to
+            Python 3.6, this is a ``_DatetimeWithFold`` object, which is a
+            subclass of :py:class:`datetime.datetime` with the ``fold``
+            attribute added, if ``fold`` is 1.
+
+        .. versionadded:: 2.6.0
+        """
+        if getattr(dt, 'fold', 0) == fold:
+            return dt
+
+        args = dt.timetuple()[:6]
+        args += (dt.microsecond, dt.tzinfo)
+
+        if fold:
+            return _DatetimeWithFold(*args)
+        else:
+            return datetime(*args)
+
+
+def _validate_fromutc_inputs(f):
+    """
+    The CPython version of ``fromutc`` checks that the input is a ``datetime``
+    object and that ``self`` is attached as its ``tzinfo``.
+    """
+    @wraps(f)
+    def fromutc(self, dt):
+        if not isinstance(dt, datetime):
+            raise TypeError("fromutc() requires a datetime argument")
+        if dt.tzinfo is not self:
+            raise ValueError("dt.tzinfo is not self")
+
+        return f(self, dt)
+
+    return fromutc
+
+
+class _tzinfo(tzinfo):
+    """
+    Base class for all ``dateutil`` ``tzinfo`` objects.
+    """
+
+    def is_ambiguous(self, dt):
+        """
+        Whether or not the "wall time" of a given datetime is ambiguous in this
+        zone.
+
+        :param dt:
+            A :py:class:`datetime.datetime`, naive or time zone aware.
+
+
+        :return:
+            Returns ``True`` if ambiguous, ``False`` otherwise.
+
+        .. versionadded:: 2.6.0
+        """
+
+        dt = dt.replace(tzinfo=self)
+
+        wall_0 = enfold(dt, fold=0)
+        wall_1 = enfold(dt, fold=1)
+
+        same_offset = wall_0.utcoffset() == wall_1.utcoffset()
+        same_dt = wall_0.replace(tzinfo=None) == wall_1.replace(tzinfo=None)
+
+        return same_dt and not same_offset
+
+    def _fold_status(self, dt_utc, dt_wall):
+        """
+        Determine the fold status of a "wall" datetime, given a representation
+        of the same datetime as a (naive) UTC datetime. This is calculated based
+        on the assumption that ``dt.utcoffset() - dt.dst()`` is constant for all
+        datetimes, and that this offset is the actual number of hours separating
+        ``dt_utc`` and ``dt_wall``.
+
+        :param dt_utc:
+            Representation of the datetime as UTC
+
+        :param dt_wall:
+            Representation of the datetime as "wall time". This parameter must
+            either have a `fold` attribute or have a fold-naive
+            :class:`datetime.tzinfo` attached, otherwise the calculation may
+            fail.
+        """
+        if self.is_ambiguous(dt_wall):
+            delta_wall = dt_wall - dt_utc
+            _fold = int(delta_wall == (dt_utc.utcoffset() - dt_utc.dst()))
+        else:
+            _fold = 0
+
+        return _fold
+
+    def _fold(self, dt):
+        return getattr(dt, 'fold', 0)
+
+    def _fromutc(self, dt):
+        """
+        Given a timezone-aware datetime in a given timezone, calculates a
+        timezone-aware datetime in a new timezone.
+
+        Since this is the one time that we *know* we have an unambiguous
+        datetime object, we take this opportunity to determine whether the
+        datetime is ambiguous and in a "fold" state (e.g. if it's the first
+        occurrence, chronologically, of the ambiguous datetime).
+
+        :param dt:
+            A timezone-aware :class:`datetime.datetime` object.
+        """
+
+        # Re-implement the algorithm from Python's datetime.py
+        dtoff = dt.utcoffset()
+        if dtoff is None:
+            raise ValueError("fromutc() requires a non-None utcoffset() "
+                             "result")
+
+        # The original datetime.py code assumes that `dst()` defaults to
+        # zero during ambiguous times. PEP 495 inverts this presumption, so
+        # for pre-PEP 495 versions of python, we need to tweak the algorithm.
+        dtdst = dt.dst()
+        if dtdst is None:
+            raise ValueError("fromutc() requires a non-None dst() result")
+        delta = dtoff - dtdst
+
+        dt += delta
+        # Set fold=1 so we can default to being in the fold for
+        # ambiguous dates.
+        dtdst = enfold(dt, fold=1).dst()
+        if dtdst is None:
+            raise ValueError("fromutc(): dt.dst gave inconsistent "
+                             "results; cannot convert")
+        return dt + dtdst
+
+    @_validate_fromutc_inputs
+    def fromutc(self, dt):
+        """
+        Given a timezone-aware datetime in a given timezone, calculates a
+        timezone-aware datetime in a new timezone.
+
+        Since this is the one time that we *know* we have an unambiguous
+        datetime object, we take this opportunity to determine whether the
+        datetime is ambiguous and in a "fold" state (e.g. if it's the first
+        occurrence, chronologically, of the ambiguous datetime).
+
+        :param dt:
+            A timezone-aware :class:`datetime.datetime` object.
+        """
+        dt_wall = self._fromutc(dt)
+
+        # Calculate the fold status given the two datetimes.
+        _fold = self._fold_status(dt, dt_wall)
+
+        # Set the default fold value for ambiguous dates
+        return enfold(dt_wall, fold=_fold)
+
+
+class tzrangebase(_tzinfo):
+    """
+    This is an abstract base class for time zones represented by an annual
+    transition into and out of DST. Child classes should implement the following
+    methods:
+
+        * ``__init__(self, *args, **kwargs)``
+        * ``transitions(self, year)`` - this is expected to return a tuple of
+          datetimes representing the DST on and off transitions in standard
+          time.
+
+    A fully initialized ``tzrangebase`` subclass should also provide the
+    following attributes:
+        * ``hasdst``: Boolean whether or not the zone uses DST.
+        * ``_dst_offset`` / ``_std_offset``: :class:`datetime.timedelta` objects
+          representing the respective UTC offsets.
+        * ``_dst_abbr`` / ``_std_abbr``: Strings representing the timezone short
+          abbreviations in DST and STD, respectively.
+        * ``_hasdst``: Whether or not the zone has DST.
+
+    .. versionadded:: 2.6.0
+    """
+    def __init__(self):
+        raise NotImplementedError('tzrangebase is an abstract base class')
+
+    def utcoffset(self, dt):
+        isdst = self._isdst(dt)
+
+        if isdst is None:
+            return None
+        elif isdst:
+            return self._dst_offset
+        else:
+            return self._std_offset
+
+    def dst(self, dt):
+        isdst = self._isdst(dt)
+
+        if isdst is None:
+            return None
+        elif isdst:
+            return self._dst_base_offset
+        else:
+            return ZERO
+
+    @tzname_in_python2
+    def tzname(self, dt):
+        if self._isdst(dt):
+            return self._dst_abbr
+        else:
+            return self._std_abbr
+
+    def fromutc(self, dt):
+        """ Given a datetime in UTC, return local time """
+        if not isinstance(dt, datetime):
+            raise TypeError("fromutc() requires a datetime argument")
+
+        if dt.tzinfo is not self:
+            raise ValueError("dt.tzinfo is not self")
+
+        # Get transitions - if there are none, fixed offset
+        transitions = self.transitions(dt.year)
+        if transitions is None:
+            return dt + self.utcoffset(dt)
+
+        # Get the transition times in UTC
+        dston, dstoff = transitions
+
+        dston -= self._std_offset
+        dstoff -= self._std_offset
+
+        utc_transitions = (dston, dstoff)
+        dt_utc = dt.replace(tzinfo=None)
+
+        isdst = self._naive_isdst(dt_utc, utc_transitions)
+
+        if isdst:
+            dt_wall = dt + self._dst_offset
+        else:
+            dt_wall = dt + self._std_offset
+
+        _fold = int(not isdst and self.is_ambiguous(dt_wall))
+
+        return enfold(dt_wall, fold=_fold)
+
+    def is_ambiguous(self, dt):
+        """
+        Whether or not the "wall time" of a given datetime is ambiguous in this
+        zone.
+
+        :param dt:
+            A :py:class:`datetime.datetime`, naive or time zone aware.
+
+
+        :return:
+            Returns ``True`` if ambiguous, ``False`` otherwise.
+
+        .. versionadded:: 2.6.0
+        """
+        if not self.hasdst:
+            return False
+
+        start, end = self.transitions(dt.year)
+
+        dt = dt.replace(tzinfo=None)
+        return (end <= dt < end + self._dst_base_offset)
+
+    def _isdst(self, dt):
+        if not self.hasdst:
+            return False
+        elif dt is None:
+            return None
+
+        transitions = self.transitions(dt.year)
+
+        if transitions is None:
+            return False
+
+        dt = dt.replace(tzinfo=None)
+
+        isdst = self._naive_isdst(dt, transitions)
+
+        # Handle ambiguous dates
+        if not isdst and self.is_ambiguous(dt):
+            return not self._fold(dt)
+        else:
+            return isdst
+
+    def _naive_isdst(self, dt, transitions):
+        dston, dstoff = transitions
+
+        dt = dt.replace(tzinfo=None)
+
+        if dston < dstoff:
+            isdst = dston <= dt < dstoff
+        else:
+            isdst = not dstoff <= dt < dston
+
+        return isdst
+
+    @property
+    def _dst_base_offset(self):
+        return self._dst_offset - self._std_offset
+
+    __hash__ = None
+
+    def __ne__(self, other):
+        return not (self == other)
+
+    def __repr__(self):
+        return "%s(...)" % self.__class__.__name__
+
+    __reduce__ = object.__reduce__
diff --git a/myvenv/Lib/site-packages/dateutil/tz/_factories.py b/myvenv/Lib/site-packages/dateutil/tz/_factories.py
new file mode 100644
index 0000000..f8a6589
--- /dev/null
+++ b/myvenv/Lib/site-packages/dateutil/tz/_factories.py
@@ -0,0 +1,80 @@
+from datetime import timedelta
+import weakref
+from collections import OrderedDict
+
+from six.moves import _thread
+
+
+class _TzSingleton(type):
+    def __init__(cls, *args, **kwargs):
+        cls.__instance = None
+        super(_TzSingleton, cls).__init__(*args, **kwargs)
+
+    def __call__(cls):
+        if cls.__instance is None:
+            cls.__instance = super(_TzSingleton, cls).__call__()
+        return cls.__instance
+
+
+class _TzFactory(type):
+    def instance(cls, *args, **kwargs):
+        """Alternate constructor that returns a fresh instance"""
+        return type.__call__(cls, *args, **kwargs)
+
+
+class _TzOffsetFactory(_TzFactory):
+    def __init__(cls, *args, **kwargs):
+        cls.__instances = weakref.WeakValueDictionary()
+        cls.__strong_cache = OrderedDict()
+        cls.__strong_cache_size = 8
+
+        cls._cache_lock = _thread.allocate_lock()
+
+    def __call__(cls, name, offset):
+        if isinstance(offset, timedelta):
+            key = (name, offset.total_seconds())
+        else:
+            key = (name, offset)
+
+        instance = cls.__instances.get(key, None)
+        if instance is None:
+            instance = cls.__instances.setdefault(key,
+                                                  cls.instance(name, offset))
+
+        # This lock may not be necessary in Python 3. See GH issue #901
+        with cls._cache_lock:
+            cls.__strong_cache[key] = cls.__strong_cache.pop(key, instance)
+
+            # Remove an item if the strong cache is overpopulated
+            if len(cls.__strong_cache) > cls.__strong_cache_size:
+                cls.__strong_cache.popitem(last=False)
+
+        return instance
+
+
+class _TzStrFactory(_TzFactory):
+    def __init__(cls, *args, **kwargs):
+        cls.__instances = weakref.WeakValueDictionary()
+        cls.__strong_cache = OrderedDict()
+        cls.__strong_cache_size = 8
+
+        cls.__cache_lock = _thread.allocate_lock()
+
+    def __call__(cls, s, posix_offset=False):
+        key = (s, posix_offset)
+        instance = cls.__instances.get(key, None)
+
+        if instance is None:
+            instance = cls.__instances.setdefault(key,
+                cls.instance(s, posix_offset))
+
+        # This lock may not be necessary in Python 3. See GH issue #901
+        with cls.__cache_lock:
+            cls.__strong_cache[key] = cls.__strong_cache.pop(key, instance)
+
+            # Remove an item if the strong cache is overpopulated
+            if len(cls.__strong_cache) > cls.__strong_cache_size:
+                cls.__strong_cache.popitem(last=False)
+
+        return instance
+
diff --git a/myvenv/Lib/site-packages/dateutil/tz/tz.py b/myvenv/Lib/site-packages/dateutil/tz/tz.py
new file mode 100644
index 0000000..c67f56d
--- /dev/null
+++ b/myvenv/Lib/site-packages/dateutil/tz/tz.py
@@ -0,0 +1,1849 @@
+# -*- coding: utf-8 -*-
+"""
+This module offers timezone implementations subclassing the abstract
+:py:class:`datetime.tzinfo` type. There are classes to handle tzfile format
+files (usually are in :file:`/etc/localtime`, :file:`/usr/share/zoneinfo`,
+etc), TZ environment string (in all known formats), given ranges (with help
+from relative deltas), local machine timezone, fixed offset timezone, and UTC
+timezone.
+"""
+import datetime
+import struct
+import time
+import sys
+import os
+import bisect
+import weakref
+from collections import OrderedDict
+
+import six
+from six import string_types
+from six.moves import _thread
+from ._common import tzname_in_python2, _tzinfo
+from ._common import tzrangebase, enfold
+from ._common import _validate_fromutc_inputs
+
+from ._factories import _TzSingleton, _TzOffsetFactory
+from ._factories import _TzStrFactory
+try:
+    from .win import tzwin, tzwinlocal
+except ImportError:
+    tzwin = tzwinlocal = None
+
+# For warning about rounding tzinfo
+from warnings import warn
+
+ZERO = datetime.timedelta(0)
+EPOCH = datetime.datetime.utcfromtimestamp(0)
+EPOCHORDINAL = EPOCH.toordinal()
+
+
+@six.add_metaclass(_TzSingleton)
+class tzutc(datetime.tzinfo):
+    """
+    This is a tzinfo object that represents the UTC time zone.
+
+    **Examples:**
+
+    .. doctest::
+
+        >>> from datetime import *
+        >>> from dateutil.tz import *
+
+        >>> datetime.now()
+        datetime.datetime(2003, 9, 27, 9, 40, 1, 521290)
+
+        >>> datetime.now(tzutc())
+        datetime.datetime(2003, 9, 27, 12, 40, 12, 156379, tzinfo=tzutc())
+
+        >>> datetime.now(tzutc()).tzname()
+        'UTC'
+
+    .. versionchanged:: 2.7.0
+        ``tzutc()`` is now a singleton, so the result of ``tzutc()`` will
+        always return the same object.
+
+        .. doctest::
+
+            >>> from dateutil.tz import tzutc, UTC
+            >>> tzutc() is tzutc()
+            True
+            >>> tzutc() is UTC
+            True
+    """
+    def utcoffset(self, dt):
+        return ZERO
+
+    def dst(self, dt):
+        return ZERO
+
+    @tzname_in_python2
+    def tzname(self, dt):
+        return "UTC"
+
+    def is_ambiguous(self, dt):
+        """
+        Whether or not the "wall time" of a given datetime is ambiguous in this
+        zone.
+
+        :param dt:
+            A :py:class:`datetime.datetime`, naive or time zone aware.
+
+
+        :return:
+            Returns ``True`` if ambiguous, ``False`` otherwise.
+
+        .. versionadded:: 2.6.0
+        """
+        return False
+
+    @_validate_fromutc_inputs
+    def fromutc(self, dt):
+        """
+        Fast track version of fromutc() returns the original ``dt`` object for
+        any valid :py:class:`datetime.datetime` object.
+        """
+        return dt
+
+    def __eq__(self, other):
+        if not isinstance(other, (tzutc, tzoffset)):
+            return NotImplemented
+
+        return (isinstance(other, tzutc) or
+                (isinstance(other, tzoffset) and other._offset == ZERO))
+
+    __hash__ = None
+
+    def __ne__(self, other):
+        return not (self == other)
+
+    def __repr__(self):
+        return "%s()" % self.__class__.__name__
+
+    __reduce__ = object.__reduce__
+
+
+#: Convenience constant providing a :class:`tzutc()` instance
+#:
+#: .. versionadded:: 2.7.0
+UTC = tzutc()
+
+
+@six.add_metaclass(_TzOffsetFactory)
+class tzoffset(datetime.tzinfo):
+    """
+    A simple class for representing a fixed offset from UTC.
+
+    :param name:
+        The timezone name, to be returned when ``tzname()`` is called.
+    :param offset:
+        The time zone offset in seconds, or (since version 2.6.0, represented
+        as a :py:class:`datetime.timedelta` object).
+    """
+    def __init__(self, name, offset):
+        self._name = name
+
+        try:
+            # Allow a timedelta
+            offset = offset.total_seconds()
+        except (TypeError, AttributeError):
+            pass
+
+        self._offset = datetime.timedelta(seconds=_get_supported_offset(offset))
+
+    def utcoffset(self, dt):
+        return self._offset
+
+    def dst(self, dt):
+        return ZERO
+
+    @tzname_in_python2
+    def tzname(self, dt):
+        return self._name
+
+    @_validate_fromutc_inputs
+    def fromutc(self, dt):
+        return dt + self._offset
+
+    def is_ambiguous(self, dt):
+        """
+        Whether or not the "wall time" of a given datetime is ambiguous in this
+        zone.
+
+        :param dt:
+            A :py:class:`datetime.datetime`, naive or time zone aware.
+        :return:
+            Returns ``True`` if ambiguous, ``False`` otherwise.
+
+        .. versionadded:: 2.6.0
+        """
+        return False
+
+    def __eq__(self, other):
+        if not isinstance(other, tzoffset):
+            return NotImplemented
+
+        return self._offset == other._offset
+
+    __hash__ = None
+
+    def __ne__(self, other):
+        return not (self == other)
+
+    def __repr__(self):
+        return "%s(%s, %s)" % (self.__class__.__name__,
+                               repr(self._name),
+                               int(self._offset.total_seconds()))
+
+    __reduce__ = object.__reduce__
+
+
+class tzlocal(_tzinfo):
+    """
+    A :class:`tzinfo` subclass built around the ``time`` timezone functions.
+    """
+    def __init__(self):
+        super(tzlocal, self).__init__()
+
+        self._std_offset = datetime.timedelta(seconds=-time.timezone)
+        if time.daylight:
+            self._dst_offset = datetime.timedelta(seconds=-time.altzone)
+        else:
+            self._dst_offset = self._std_offset
+
+        self._dst_saved = self._dst_offset - self._std_offset
+        self._hasdst = bool(self._dst_saved)
+        self._tznames = tuple(time.tzname)
+
+    def utcoffset(self, dt):
+        if dt is None and self._hasdst:
+            return None
+
+        if self._isdst(dt):
+            return self._dst_offset
+        else:
+            return self._std_offset
+
+    def dst(self, dt):
+        if dt is None and self._hasdst:
+            return None
+
+        if self._isdst(dt):
+            return self._dst_offset - self._std_offset
+        else:
+            return ZERO
+
+    @tzname_in_python2
+    def tzname(self, dt):
+        return self._tznames[self._isdst(dt)]
+
+    def is_ambiguous(self, dt):
+        """
+        Whether or not the "wall time" of a given datetime is ambiguous in this
+        zone.
+
+        :param dt:
+            A :py:class:`datetime.datetime`, naive or time zone aware.
+
+
+        :return:
+            Returns ``True`` if ambiguous, ``False`` otherwise.
+
+        .. versionadded:: 2.6.0
+        """
+        naive_dst = self._naive_is_dst(dt)
+        return (not naive_dst and
+                (naive_dst != self._naive_is_dst(dt - self._dst_saved)))
+
+    def _naive_is_dst(self, dt):
+        timestamp = _datetime_to_timestamp(dt)
+        return time.localtime(timestamp + time.timezone).tm_isdst
+
+    def _isdst(self, dt, fold_naive=True):
+        # We can't use mktime here. It is unstable when deciding if
+        # the hour near to a change is DST or not.
+        #
+        # timestamp = time.mktime((dt.year, dt.month, dt.day, dt.hour,
+        #                         dt.minute, dt.second, dt.weekday(), 0, -1))
+        # return time.localtime(timestamp).tm_isdst
+        #
+        # The code above yields the following result:
+        #
+        # >>> import tz, datetime
+        # >>> t = tz.tzlocal()
+        # >>> datetime.datetime(2003,2,15,23,tzinfo=t).tzname()
+        # 'BRDT'
+        # >>> datetime.datetime(2003,2,16,0,tzinfo=t).tzname()
+        # 'BRST'
+        # >>> datetime.datetime(2003,2,15,23,tzinfo=t).tzname()
+        # 'BRST'
+        # >>> datetime.datetime(2003,2,15,22,tzinfo=t).tzname()
+        # 'BRDT'
+        # >>> datetime.datetime(2003,2,15,23,tzinfo=t).tzname()
+        # 'BRDT'
+        #
+        # Here is a more stable implementation:
+        #
+        if not self._hasdst:
+            return False
+
+        # Check for ambiguous times:
+        dstval = self._naive_is_dst(dt)
+        fold = getattr(dt, 'fold', None)
+
+        if self.is_ambiguous(dt):
+            if fold is not None:
+                return not self._fold(dt)
+            else:
+                return True
+
+        return dstval
+
+    def __eq__(self, other):
+        if isinstance(other, tzlocal):
+            return (self._std_offset == other._std_offset and
+                    self._dst_offset == other._dst_offset)
+        elif isinstance(other, tzutc):
+            return (not self._hasdst and
+                    self._tznames[0] in {'UTC', 'GMT'} and
+                    self._std_offset == ZERO)
+        elif isinstance(other, tzoffset):
+            return (not self._hasdst and
+                    self._tznames[0] == other._name and
+                    self._std_offset == other._offset)
+        else:
+            return NotImplemented
+
+    __hash__ = None
+
+    def __ne__(self, other):
+        return not (self == other)
+
+    def __repr__(self):
+        return "%s()" % self.__class__.__name__
+
+    __reduce__ = object.__reduce__
+
+
+class _ttinfo(object):
+    __slots__ = ["offset", "delta", "isdst", "abbr",
+                 "isstd", "isgmt", "dstoffset"]
+
+    def __init__(self):
+        for attr in self.__slots__:
+            setattr(self, attr, None)
+
+    def __repr__(self):
+        l = []
+        for attr in self.__slots__:
+            value = getattr(self, attr)
+            if value is not None:
+                l.append("%s=%s" % (attr, repr(value)))
+        return "%s(%s)" % (self.__class__.__name__, ", ".join(l))
+
+    def __eq__(self, other):
+        if not isinstance(other, _ttinfo):
+            return NotImplemented
+
+        return (self.offset == other.offset and
+                self.delta == other.delta and
+                self.isdst == other.isdst and
+                self.abbr == other.abbr and
+                self.isstd == other.isstd and
+                self.isgmt == other.isgmt and
+                self.dstoffset == other.dstoffset)
+
+    __hash__ = None
+
+    def __ne__(self, other):
+        return not (self == other)
+
+    def __getstate__(self):
+        state = {}
+        for name in self.__slots__:
+            state[name] = getattr(self, name, None)
+        return state
+
+    def __setstate__(self, state):
+        for name in self.__slots__:
+            if name in state:
+                setattr(self, name, state[name])
+
+
+class _tzfile(object):
+    """
+    Lightweight class for holding the relevant transition and time zone
+    information read from binary tzfiles.
+    """
+    attrs = ['trans_list', 'trans_list_utc', 'trans_idx', 'ttinfo_list',
+             'ttinfo_std', 'ttinfo_dst', 'ttinfo_before', 'ttinfo_first']
+
+    def __init__(self, **kwargs):
+        for attr in self.attrs:
+            setattr(self, attr, kwargs.get(attr, None))
+
+
+class tzfile(_tzinfo):
+    """
+    This is a ``tzinfo`` subclass that allows one to use the ``tzfile(5)``
+    format timezone files to extract current and historical zone information.
+
+    :param fileobj:
+        This can be an opened file stream or a file name that the time zone
+        information can be read from.
+
+    :param filename:
+        This is an optional parameter specifying the source of the time zone
+        information in the event that ``fileobj`` is a file object. If omitted
+        and ``fileobj`` is a file stream, this parameter will be set either to
+        ``fileobj``'s ``name`` attribute or to ``repr(fileobj)``.
+
+    See `Sources for Time Zone and Daylight Saving Time Data
+    <https://data.iana.org/time-zones/tz-link.html>`_ for more information.
+    Time zone files can be compiled from the `IANA Time Zone database files
+    <https://www.iana.org/time-zones>`_ with the `zic time zone compiler
+    <https://www.freebsd.org/cgi/man.cgi?query=zic&sektion=8>`_
+
+    .. note::
+
+        Only construct a ``tzfile`` directly if you have a specific timezone
+        file on disk that you want to read into a Python ``tzinfo`` object.
+        If you want to get a ``tzfile`` representing a specific IANA zone,
+        (e.g. ``'America/New_York'``), you should call
+        :func:`dateutil.tz.gettz` with the zone identifier.
+
+
+    **Examples:**
+
+    Using the US Eastern time zone as an example, we can see that a ``tzfile``
+    provides time zone information for the standard Daylight Saving offsets:
+
+    .. testsetup:: tzfile
+
+        from dateutil.tz import gettz
+        from datetime import datetime
+
+    .. doctest:: tzfile
+
+        >>> NYC = gettz('America/New_York')
+        >>> NYC
+        tzfile('/usr/share/zoneinfo/America/New_York')
+
+        >>> print(datetime(2016, 1, 3, tzinfo=NYC))     # EST
+        2016-01-03 00:00:00-05:00
+
+        >>> print(datetime(2016, 7, 7, tzinfo=NYC))     # EDT
+        2016-07-07 00:00:00-04:00
+
+
+    The ``tzfile`` structure contains a fully history of the time zone,
+    so historical dates will also have the right offsets. For example, before
+    the adoption of the UTC standards, New York used local solar  mean time:
+
+    .. doctest:: tzfile
+
+       >>> print(datetime(1901, 4, 12, tzinfo=NYC))    # LMT
+       1901-04-12 00:00:00-04:56
+
+    And during World War II, New York was on "Eastern War Time", which was a
+    state of permanent daylight saving time:
+
+    .. doctest:: tzfile
+
+        >>> print(datetime(1944, 2, 7, tzinfo=NYC))    # EWT
+        1944-02-07 00:00:00-04:00
+
+    """
+
+    def __init__(self, fileobj, filename=None):
+        super(tzfile, self).__init__()
+
+        file_opened_here = False
+        if isinstance(fileobj, string_types):
+            self._filename = fileobj
+            fileobj = open(fileobj, 'rb')
+            file_opened_here = True
+        elif filename is not None:
+            self._filename = filename
+        elif hasattr(fileobj, "name"):
+            self._filename = fileobj.name
+        else:
+            self._filename = repr(fileobj)
+
+        if fileobj is not None:
+            if not file_opened_here:
+                fileobj = _nullcontext(fileobj)
+
+            with fileobj as file_stream:
+                tzobj = self._read_tzfile(file_stream)
+
+            self._set_tzdata(tzobj)
+
+    def _set_tzdata(self, tzobj):
+        """ Set the time zone data of this object from a _tzfile object """
+        # Copy the relevant attributes over as private attributes
+        for attr in _tzfile.attrs:
+            setattr(self, '_' + attr, getattr(tzobj, attr))
+
+    def _read_tzfile(self, fileobj):
+        out = _tzfile()
+
+        # From tzfile(5):
+        #
+        # The time zone information files used by tzset(3)
+        # begin with the magic characters "TZif" to identify
+        # them as time zone information files, followed by
+        # sixteen bytes reserved for future use, followed by
+        # six four-byte values of type long, written in a
+        # ``standard'' byte order (the high-order  byte
+        # of the value is written first).
+        if fileobj.read(4).decode() != "TZif":
+            raise ValueError("magic not found")
+
+        fileobj.read(16)
+
+        (
+            # The number of UTC/local indicators stored in the file.
+            ttisgmtcnt,
+
+            # The number of standard/wall indicators stored in the file.
+            ttisstdcnt,
+
+            # The number of leap seconds for which data is
+            # stored in the file.
+            leapcnt,
+
+            # The number of "transition times" for which data
+            # is stored in the file.
+            timecnt,
+
+            # The number of "local time types" for which data
+            # is stored in the file (must not be zero).
+            typecnt,
+
+            # The  number  of  characters  of "time zone
+            # abbreviation strings" stored in the file.
+            charcnt,
+
+        ) = struct.unpack(">6l", fileobj.read(24))
+
+        # The above header is followed by tzh_timecnt four-byte
+        # values  of  type long,  sorted  in ascending order.
+        # These values are written in ``standard'' byte order.
+        # Each is used as a transition time (as  returned  by
+        # time(2)) at which the rules for computing local time
+        # change.
+
+        if timecnt:
+            out.trans_list_utc = list(struct.unpack(">%dl" % timecnt,
+                                                    fileobj.read(timecnt*4)))
+        else:
+            out.trans_list_utc = []
+
+        # Next come tzh_timecnt one-byte values of type unsigned
+        # char; each one tells which of the different types of
+        # ``local time'' types described in the file is associated
+        # with the same-indexed transition time. These values
+        # serve as indices into an array of ttinfo structures that
+        # appears next in the file.
+
+        if timecnt:
+            out.trans_idx = struct.unpack(">%dB" % timecnt,
+                                          fileobj.read(timecnt))
+        else:
+            out.trans_idx = []
+
+        # Each ttinfo structure is written as a four-byte value
+        # for tt_gmtoff  of  type long,  in  a  standard  byte
+        # order, followed  by a one-byte value for tt_isdst
+        # and a one-byte  value  for  tt_abbrind.   In  each
+        # structure, tt_gmtoff  gives  the  number  of
+        # seconds to be added to UTC, tt_isdst tells whether
+        # tm_isdst should be set by  localtime(3),  and
+        # tt_abbrind serves  as an index into the array of
+        # time zone abbreviation characters that follow the
+        # ttinfo structure(s) in the file.
+
+        ttinfo = []
+
+        for i in range(typecnt):
+            ttinfo.append(struct.unpack(">lbb", fileobj.read(6)))
+
+        abbr = fileobj.read(charcnt).decode()
+
+        # Then there are tzh_leapcnt pairs of four-byte
+        # values, written in  standard byte  order;  the
+        # first  value  of  each pair gives the time (as
+        # returned by time(2)) at which a leap second
+        # occurs;  the  second  gives the  total  number of
+        # leap seconds to be applied after the given time.
+        # The pairs of values are sorted in ascending order
+        # by time.
+
+        # Not used, for now (but seek for correct file position)
+        if leapcnt:
+            fileobj.seek(leapcnt * 8, os.SEEK_CUR)
+
+        # Then there are tzh_ttisstdcnt standard/wall
+        # indicators, each stored as a one-byte value;
+        # they tell whether the transition times associated
+        # with local time types were specified as standard
+        # time or wall clock time, and are used when
+        # a time zone file is used in handling POSIX-style
+        # time zone environment variables.
+
+        if ttisstdcnt:
+            isstd = struct.unpack(">%db" % ttisstdcnt,
+                                  fileobj.read(ttisstdcnt))
+
+        # Finally, there are tzh_ttisgmtcnt UTC/local
+        # indicators, each stored as a one-byte value;
+        # they tell whether the transition times associated
+        # with local time types were specified as UTC or
+        # local time, and are used when a time zone file
+        # is used in handling POSIX-style time zone envi-
+        # ronment variables.
+
+        if ttisgmtcnt:
+            isgmt = struct.unpack(">%db" % ttisgmtcnt,
+                                  fileobj.read(ttisgmtcnt))
+
+        # Build ttinfo list
+        out.ttinfo_list = []
+        for i in range(typecnt):
+            gmtoff, isdst, abbrind = ttinfo[i]
+            gmtoff = _get_supported_offset(gmtoff)
+            tti = _ttinfo()
+            tti.offset = gmtoff
+            tti.dstoffset = datetime.timedelta(0)
+            tti.delta = datetime.timedelta(seconds=gmtoff)
+            tti.isdst = isdst
+            tti.abbr = abbr[abbrind:abbr.find('\x00', abbrind)]
+            tti.isstd = (ttisstdcnt > i and isstd[i] != 0)
+            tti.isgmt = (ttisgmtcnt > i and isgmt[i] != 0)
+            out.ttinfo_list.append(tti)
+
+        # Replace ttinfo indexes for ttinfo objects.
+        out.trans_idx = [out.ttinfo_list[idx] for idx in out.trans_idx]
+
+        # Set standard, dst, and before ttinfos. before will be
+        # used when a given time is before any transitions,
+        # and will be set to the first non-dst ttinfo, or to
+        # the first dst, if all of them are dst.
+        out.ttinfo_std = None
+        out.ttinfo_dst = None
+        out.ttinfo_before = None
+        if out.ttinfo_list:
+            if not out.trans_list_utc:
+                out.ttinfo_std = out.ttinfo_first = out.ttinfo_list[0]
+            else:
+                for i in range(timecnt-1, -1, -1):
+                    tti = out.trans_idx[i]
+                    if not out.ttinfo_std and not tti.isdst:
+                        out.ttinfo_std = tti
+                    elif not out.ttinfo_dst and tti.isdst:
+                        out.ttinfo_dst = tti
+
+                    if out.ttinfo_std and out.ttinfo_dst:
+                        break
+                else:
+                    if out.ttinfo_dst and not out.ttinfo_std:
+                        out.ttinfo_std = out.ttinfo_dst
+
+                for tti in out.ttinfo_list:
+                    if not tti.isdst:
+                        out.ttinfo_before = tti
+                        break
+                else:
+                    out.ttinfo_before = out.ttinfo_list[0]
+
+        # Now fix transition times to become relative to wall time.
+        #
+        # I'm not sure about this. In my tests, the tz source file
+        # is setup to wall time, and in the binary file isstd and
+        # isgmt are off, so it should be in wall time. OTOH, it's
+        # always in gmt time. Let me know if you have comments
+        # about this.
+        lastdst = None
+        lastoffset = None
+        lastdstoffset = None
+        lastbaseoffset = None
+        out.trans_list = []
+
+        for i, tti in enumerate(out.trans_idx):
+            offset = tti.offset
+            dstoffset = 0
+
+            if lastdst is not None:
+                if tti.isdst:
+                    if not lastdst:
+                        dstoffset = offset - lastoffset
+
+                    if not dstoffset and lastdstoffset:
+                        dstoffset = lastdstoffset
+
+                    tti.dstoffset = datetime.timedelta(seconds=dstoffset)
+                    lastdstoffset = dstoffset
+
+            # If a time zone changes its base offset during a DST transition,
+            # then you need to adjust by the previous base offset to get the
+            # transition time in local time. Otherwise you use the current
+            # base offset. Ideally, I would have some mathematical proof of
+            # why this is true, but I haven't really thought about it enough.
+            baseoffset = offset - dstoffset
+            adjustment = baseoffset
+            if (lastbaseoffset is not None and baseoffset != lastbaseoffset
+                    and tti.isdst != lastdst):
+                # The base DST has changed
+                adjustment = lastbaseoffset
+
+            lastdst = tti.isdst
+            lastoffset = offset
+            lastbaseoffset = baseoffset
+
+            out.trans_list.append(out.trans_list_utc[i] + adjustment)
+
+        out.trans_idx = tuple(out.trans_idx)
+        out.trans_list = tuple(out.trans_list)
+        out.trans_list_utc = tuple(out.trans_list_utc)
+
+        return out
+
+    def _find_last_transition(self, dt, in_utc=False):
+        # If there's no list, there are no transitions to find
+        if not self._trans_list:
+            return None
+
+        timestamp = _datetime_to_timestamp(dt)
+
+        # Find where the timestamp fits in the transition list - if the
+        # timestamp is a transition time, it's part of the "after" period.
+        trans_list = self._trans_list_utc if in_utc else self._trans_list
+        idx = bisect.bisect_right(trans_list, timestamp)
+
+        # We want to know when the previous transition was, so subtract off 1
+        return idx - 1
+
+    def _get_ttinfo(self, idx):
+        # For no list or after the last transition, default to _ttinfo_std
+        if idx is None or (idx + 1) >= len(self._trans_list):
+            return self._ttinfo_std
+
+        # If there is a list and the time is before it, return _ttinfo_before
+        if idx < 0:
+            return self._ttinfo_before
+
+        return self._trans_idx[idx]
+
+    def _find_ttinfo(self, dt):
+        idx = self._resolve_ambiguous_time(dt)
+
+        return self._get_ttinfo(idx)
+
+    def fromutc(self, dt):
+        """
+        The ``tzfile`` implementation of :py:func:`datetime.tzinfo.fromutc`.
+
+        :param dt:
+            A :py:class:`datetime.datetime` object.
+
+        :raises TypeError:
+            Raised if ``dt`` is not a :py:class:`datetime.datetime` object.
+
+        :raises ValueError:
+            Raised if this is called with a ``dt`` which does not have this
+            ``tzinfo`` attached.
+
+        :return:
+            Returns a :py:class:`datetime.datetime` object representing the
+            wall time in ``self``'s time zone.
+        """
+        # These isinstance checks are in datetime.tzinfo, so we'll preserve
+        # them, even if we don't care about duck typing.
+        if not isinstance(dt, datetime.datetime):
+            raise TypeError("fromutc() requires a datetime argument")
+
+        if dt.tzinfo is not self:
+            raise ValueError("dt.tzinfo is not self")
+
+        # First treat UTC as wall time and get the transition we're in.
+        idx = self._find_last_transition(dt, in_utc=True)
+        tti = self._get_ttinfo(idx)
+
+        dt_out = dt + datetime.timedelta(seconds=tti.offset)
+
+        fold = self.is_ambiguous(dt_out, idx=idx)
+
+        return enfold(dt_out, fold=int(fold))
+
+    def is_ambiguous(self, dt, idx=None):
+        """
+        Whether or not the "wall time" of a given datetime is ambiguous in this
+        zone.
+
+        :param dt:
+            A :py:class:`datetime.datetime`, naive or time zone aware.
+
+
+        :return:
+            Returns ``True`` if ambiguous, ``False`` otherwise.
+
+        .. versionadded:: 2.6.0
+        """
+        if idx is None:
+            idx = self._find_last_transition(dt)
+
+        # Calculate the difference in offsets from current to previous
+        timestamp = _datetime_to_timestamp(dt)
+        tti = self._get_ttinfo(idx)
+
+        if idx is None or idx <= 0:
+            return False
+
+        od = self._get_ttinfo(idx - 1).offset - tti.offset
+        tt = self._trans_list[idx]          # Transition time
+
+        return timestamp < tt + od
+
+    def _resolve_ambiguous_time(self, dt):
+        idx = self._find_last_transition(dt)
+
+        # If we have no transitions, return the index
+        _fold = self._fold(dt)
+        if idx is None or idx == 0:
+            return idx
+
+        # If it's ambiguous and we're in a fold, shift to a different index.
+        idx_offset = int(not _fold and self.is_ambiguous(dt, idx))
+
+        return idx - idx_offset
+
+    def utcoffset(self, dt):
+        if dt is None:
+            return None
+
+        if not self._ttinfo_std:
+            return ZERO
+
+        return self._find_ttinfo(dt).delta
+
+    def dst(self, dt):
+        if dt is None:
+            return None
+
+        if not self._ttinfo_dst:
+            return ZERO
+
+        tti = self._find_ttinfo(dt)
+
+        if not tti.isdst:
+            return ZERO
+
+        # The documentation says that utcoffset()-dst() must
+        # be constant for every dt.
+        return tti.dstoffset
+
+    @tzname_in_python2
+    def tzname(self, dt):
+        if not self._ttinfo_std or dt is None:
+            return None
+        return self._find_ttinfo(dt).abbr
+
+    def __eq__(self, other):
+        if not isinstance(other, tzfile):
+            return NotImplemented
+        return (self._trans_list == other._trans_list and
+                self._trans_idx == other._trans_idx and
+                self._ttinfo_list == other._ttinfo_list)
+
+    __hash__ = None
+
+    def __ne__(self, other):
+        return not (self == other)
+
+    def __repr__(self):
+        return "%s(%s)" % (self.__class__.__name__, repr(self._filename))
+
+    def __reduce__(self):
+        return self.__reduce_ex__(None)
+
+    def __reduce_ex__(self, protocol):
+        return (self.__class__, (None, self._filename), self.__dict__)
+
+
+class tzrange(tzrangebase):
+    """
+    The ``tzrange`` object is a time zone specified by a set of offsets and
+    abbreviations, equivalent to the way the ``TZ`` variable can be specified
+    in POSIX-like systems, but using Python delta objects to specify DST
+    start, end and offsets.
+
+    :param stdabbr:
+        The abbreviation for standard time (e.g. ``'EST'``).
+
+    :param stdoffset:
+        An integer or :class:`datetime.timedelta` object or equivalent
+        specifying the base offset from UTC.
+
+        If unspecified, +00:00 is used.
+
+    :param dstabbr:
+        The abbreviation for DST / "Summer" time (e.g. ``'EDT'``).
+
+        If specified, with no other DST information, DST is assumed to occur
+        and the default behavior or ``dstoffset``, ``start`` and ``end`` is
+        used. If unspecified and no other DST information is specified, it
+        is assumed that this zone has no DST.
+
+        If this is unspecified and other DST information is *is* specified,
+        DST occurs in the zone but the time zone abbreviation is left
+        unchanged.
+
+    :param dstoffset:
+        A an integer or :class:`datetime.timedelta` object or equivalent
+        specifying the UTC offset during DST. If unspecified and any other DST
+        information is specified, it is assumed to be the STD offset +1 hour.
+
+    :param start:
+        A :class:`relativedelta.relativedelta` object or equivalent specifying
+        the time and time of year that daylight savings time starts. To
+        specify, for example, that DST starts at 2AM on the 2nd Sunday in
+        March, pass:
+
+            ``relativedelta(hours=2, month=3, day=1, weekday=SU(+2))``
+
+        If unspecified and any other DST information is specified, the default
+        value is 2 AM on the first Sunday in April.
+
+    :param end:
+        A :class:`relativedelta.relativedelta` object or equivalent
+        representing the time and time of year that daylight savings time
+        ends, with the same specification method as in ``start``. One note is
+        that this should point to the first time in the *standard* zone, so if
+        a transition occurs at 2AM in the DST zone and the clocks are set back
+        1 hour to 1AM, set the ``hours`` parameter to +1.
+
+
+    **Examples:**
+
+    .. testsetup:: tzrange
+
+        from dateutil.tz import tzrange, tzstr
+
+    .. doctest:: tzrange
+
+        >>> tzstr('EST5EDT') == tzrange("EST", -18000, "EDT")
+        True
+
+        >>> from dateutil.relativedelta import *
+        >>> range1 = tzrange("EST", -18000, "EDT")
+        >>> range2 = tzrange("EST", -18000, "EDT", -14400,
+        ...                  relativedelta(hours=+2, month=4, day=1,
+        ...                                weekday=SU(+1)),
+        ...                  relativedelta(hours=+1, month=10, day=31,
+        ...                                weekday=SU(-1)))
+        >>> tzstr('EST5EDT') == range1 == range2
+        True
+
+    """
+    def __init__(self, stdabbr, stdoffset=None,
+                 dstabbr=None, dstoffset=None,
+                 start=None, end=None):
+
+        global relativedelta
+        from dateutil import relativedelta
+
+        self._std_abbr = stdabbr
+        self._dst_abbr = dstabbr
+
+        try:
+            stdoffset = stdoffset.total_seconds()
+        except (TypeError, AttributeError):
+            pass
+
+        try:
+            dstoffset = dstoffset.total_seconds()
+        except (TypeError, AttributeError):
+            pass
+
+        if stdoffset is not None:
+            self._std_offset = datetime.timedelta(seconds=stdoffset)
+        else:
+            self._std_offset = ZERO
+
+        if dstoffset is not None:
+            self._dst_offset = datetime.timedelta(seconds=dstoffset)
+        elif dstabbr and stdoffset is not None:
+            self._dst_offset = self._std_offset + datetime.timedelta(hours=+1)
+        else:
+            self._dst_offset = ZERO
+
+        if dstabbr and start is None:
+            self._start_delta = relativedelta.relativedelta(
+                hours=+2, month=4, day=1, weekday=relativedelta.SU(+1))
+        else:
+            self._start_delta = start
+
+        if dstabbr and end is None:
+            self._end_delta = relativedelta.relativedelta(
+                hours=+1, month=10, day=31, weekday=relativedelta.SU(-1))
+        else:
+            self._end_delta = end
+
+        self._dst_base_offset_ = self._dst_offset - self._std_offset
+        self.hasdst = bool(self._start_delta)
+
+    def transitions(self, year):
+        """
+        For a given year, get the DST on and off transition times, expressed
+        always on the standard time side. For zones with no transitions, this
+        function returns ``None``.
+
+        :param year:
+            The year whose transitions you would like to query.
+
+        :return:
+            Returns a :class:`tuple` of :class:`datetime.datetime` objects,
+            ``(dston, dstoff)`` for zones with an annual DST transition, or
+            ``None`` for fixed offset zones.
+        """
+        if not self.hasdst:
+            return None
+
+        base_year = datetime.datetime(year, 1, 1)
+
+        start = base_year + self._start_delta
+        end = base_year + self._end_delta
+
+        return (start, end)
+
+    def __eq__(self, other):
+        if not isinstance(other, tzrange):
+            return NotImplemented
+
+        return (self._std_abbr == other._std_abbr and
+                self._dst_abbr == other._dst_abbr and
+                self._std_offset == other._std_offset and
+                self._dst_offset == other._dst_offset and
+                self._start_delta == other._start_delta and
+                self._end_delta == other._end_delta)
+
+    @property
+    def _dst_base_offset(self):
+        return self._dst_base_offset_
+
+
+@six.add_metaclass(_TzStrFactory)
+class tzstr(tzrange):
+    """
+    ``tzstr`` objects are time zone objects specified by a time-zone string as
+    it would be passed to a ``TZ`` variable on POSIX-style systems (see
+    the `GNU C Library: TZ Variable`_ for more details).
+
+    There is one notable exception, which is that POSIX-style time zones use an
+    inverted offset format, so normally ``GMT+3`` would be parsed as an offset
+    3 hours *behind* GMT. The ``tzstr`` time zone object will parse this as an
+    offset 3 hours *ahead* of GMT. If you would like to maintain the POSIX
+    behavior, pass a ``True`` value to ``posix_offset``.
+
+    The :class:`tzrange` object provides the same functionality, but is
+    specified using :class:`relativedelta.relativedelta` objects. rather than
+    strings.
+
+    :param s:
+        A time zone string in ``TZ`` variable format. This can be a
+        :class:`bytes` (2.x: :class:`str`), :class:`str` (2.x:
+        :class:`unicode`) or a stream emitting unicode characters
+        (e.g. :class:`StringIO`).
+
+    :param posix_offset:
+        Optional. If set to ``True``, interpret strings such as ``GMT+3`` or
+        ``UTC+3`` as being 3 hours *behind* UTC rather than ahead, per the
+        POSIX standard.
+
+    .. caution::
+
+        Prior to version 2.7.0, this function also supported time zones
+        in the format:
+
+            * ``EST5EDT,4,0,6,7200,10,0,26,7200,3600``
+            * ``EST5EDT,4,1,0,7200,10,-1,0,7200,3600``
+
+        This format is non-standard and has been deprecated; this function
+        will raise a :class:`DeprecatedTZFormatWarning` until
+        support is removed in a future version.
+
+    .. _`GNU C Library: TZ Variable`:
+        https://www.gnu.org/software/libc/manual/html_node/TZ-Variable.html
+    """
+    def __init__(self, s, posix_offset=False):
+        global parser
+        from dateutil.parser import _parser as parser
+
+        self._s = s
+
+        res = parser._parsetz(s)
+        if res is None or res.any_unused_tokens:
+            raise ValueError("unknown string format")
+
+        # Here we break the compatibility with the TZ variable handling.
+        # GMT-3 actually *means* the timezone -3.
+        if res.stdabbr in ("GMT", "UTC") and not posix_offset:
+            res.stdoffset *= -1
+
+        # We must initialize it first, since _delta() needs
+        # _std_offset and _dst_offset set. Use False in start/end
+        # to avoid building it two times.
+        tzrange.__init__(self, res.stdabbr, res.stdoffset,
+                         res.dstabbr, res.dstoffset,
+                         start=False, end=False)
+
+        if not res.dstabbr:
+            self._start_delta = None
+            self._end_delta = None
+        else:
+            self._start_delta = self._delta(res.start)
+            if self._start_delta:
+                self._end_delta = self._delta(res.end, isend=1)
+
+        self.hasdst = bool(self._start_delta)
+
+    def _delta(self, x, isend=0):
+        from dateutil import relativedelta
+        kwargs = {}
+        if x.month is not None:
+            kwargs["month"] = x.month
+            if x.weekday is not None:
+                kwargs["weekday"] = relativedelta.weekday(x.weekday, x.week)
+                if x.week > 0:
+                    kwargs["day"] = 1
+                else:
+                    kwargs["day"] = 31
+            elif x.day:
+                kwargs["day"] = x.day
+        elif x.yday is not None:
+            kwargs["yearday"] = x.yday
+        elif x.jyday is not None:
+            kwargs["nlyearday"] = x.jyday
+        if not kwargs:
+            # Default is to start on first sunday of april, and end
+            # on last sunday of october.
+            if not isend:
+                kwargs["month"] = 4
+                kwargs["day"] = 1
+                kwargs["weekday"] = relativedelta.SU(+1)
+            else:
+                kwargs["month"] = 10
+                kwargs["day"] = 31
+                kwargs["weekday"] = relativedelta.SU(-1)
+        if x.time is not None:
+            kwargs["seconds"] = x.time
+        else:
+            # Default is 2AM.
+            kwargs["seconds"] = 7200
+        if isend:
+            # Convert to standard time, to follow the documented way
+            # of working with the extra hour. See the documentation
+            # of the tzinfo class.
+            delta = self._dst_offset - self._std_offset
+            kwargs["seconds"] -= delta.seconds + delta.days * 86400
+        return relativedelta.relativedelta(**kwargs)
+
+    def __repr__(self):
+        return "%s(%s)" % (self.__class__.__name__, repr(self._s))
+
+
+class _tzicalvtzcomp(object):
+    def __init__(self, tzoffsetfrom, tzoffsetto, isdst,
+                 tzname=None, rrule=None):
+        self.tzoffsetfrom = datetime.timedelta(seconds=tzoffsetfrom)
+        self.tzoffsetto = datetime.timedelta(seconds=tzoffsetto)
+        self.tzoffsetdiff = self.tzoffsetto - self.tzoffsetfrom
+        self.isdst = isdst
+        self.tzname = tzname
+        self.rrule = rrule
+
+
+class _tzicalvtz(_tzinfo):
+    def __init__(self, tzid, comps=[]):
+        super(_tzicalvtz, self).__init__()
+
+        self._tzid = tzid
+        self._comps = comps
+        self._cachedate = []
+        self._cachecomp = []
+        self._cache_lock = _thread.allocate_lock()
+
+    def _find_comp(self, dt):
+        if len(self._comps) == 1:
+            return self._comps[0]
+
+        dt = dt.replace(tzinfo=None)
+
+        try:
+            with self._cache_lock:
+                return self._cachecomp[self._cachedate.index(
+                    (dt, self._fold(dt)))]
+        except ValueError:
+            pass
+
+        lastcompdt = None
+        lastcomp = None
+
+        for comp in self._comps:
+            compdt = self._find_compdt(comp, dt)
+
+            if compdt and (not lastcompdt or lastcompdt < compdt):
+                lastcompdt = compdt
+                lastcomp = comp
+
+        if not lastcomp:
+            # RFC says nothing about what to do when a given
+            # time is before the first onset date. We'll look for the
+            # first standard component, or the first component, if
+            # none is found.
+            for comp in self._comps:
+                if not comp.isdst:
+                    lastcomp = comp
+                    break
+            else:
+                lastcomp = comp[0]
+
+        with self._cache_lock:
+            self._cachedate.insert(0, (dt, self._fold(dt)))
+            self._cachecomp.insert(0, lastcomp)
+
+            if len(self._cachedate) > 10:
+                self._cachedate.pop()
+                self._cachecomp.pop()
+
+        return lastcomp
+
+    def _find_compdt(self, comp, dt):
+        if comp.tzoffsetdiff < ZERO and self._fold(dt):
+            dt -= comp.tzoffsetdiff
+
+        compdt = comp.rrule.before(dt, inc=True)
+
+        return compdt
+
+    def utcoffset(self, dt):
+        if dt is None:
+            return None
+
+        return self._find_comp(dt).tzoffsetto
+
+    def dst(self, dt):
+        comp = self._find_comp(dt)
+        if comp.isdst:
+            return comp.tzoffsetdiff
+        else:
+            return ZERO
+
+    @tzname_in_python2
+    def tzname(self, dt):
+        return self._find_comp(dt).tzname
+
+    def __repr__(self):
+        return "<tzicalvtz %s>" % repr(self._tzid)
+
+    __reduce__ = object.__reduce__
+
+
+class tzical(object):
+    """
+    This object is designed to parse an iCalendar-style ``VTIMEZONE`` structure
+    as set out in `RFC 5545`_ Section 4.6.5 into one or more `tzinfo` objects.
+
+    :param `fileobj`:
+        A file or stream in iCalendar format, which should be UTF-8 encoded
+        with CRLF endings.
+
+    .. _`RFC 5545`: https://tools.ietf.org/html/rfc5545
+    """
+    def __init__(self, fileobj):
+        global rrule
+        from dateutil import rrule
+
+        if isinstance(fileobj, string_types):
+            self._s = fileobj
+            # ical should be encoded in UTF-8 with CRLF
+            fileobj = open(fileobj, 'r')
+        else:
+            self._s = getattr(fileobj, 'name', repr(fileobj))
+            fileobj = _nullcontext(fileobj)
+
+        self._vtz = {}
+
+        with fileobj as fobj:
+            self._parse_rfc(fobj.read())
+
+    def keys(self):
+        """
+        Retrieves the available time zones as a list.
+        """
+        return list(self._vtz.keys())
+
+    def get(self, tzid=None):
+        """
+        Retrieve a :py:class:`datetime.tzinfo` object by its ``tzid``.
+
+        :param tzid:
+            If there is exactly one time zone available, omitting ``tzid``
+            or passing :py:const:`None` value returns it. Otherwise a valid
+            key (which can be retrieved from :func:`keys`) is required.
+
+        :raises ValueError:
+            Raised if ``tzid`` is not specified but there are either more
+            or fewer than 1 zone defined.
+
+        :returns:
+            Returns either a :py:class:`datetime.tzinfo` object representing
+            the relevant time zone or :py:const:`None` if the ``tzid`` was
+            not found.
+        """
+        if tzid is None:
+            if len(self._vtz) == 0:
+                raise ValueError("no timezones defined")
+            elif len(self._vtz) > 1:
+                raise ValueError("more than one timezone available")
+            tzid = next(iter(self._vtz))
+
+        return self._vtz.get(tzid)
+
+    def _parse_offset(self, s):
+        s = s.strip()
+        if not s:
+            raise ValueError("empty offset")
+        if s[0] in ('+', '-'):
+            signal = (-1, +1)[s[0] == '+']
+            s = s[1:]
+        else:
+            signal = +1
+        if len(s) == 4:
+            return (int(s[:2]) * 3600 + int(s[2:]) * 60) * signal
+        elif len(s) == 6:
+            return (int(s[:2]) * 3600 + int(s[2:4]) * 60 + int(s[4:])) * signal
+        else:
+            raise ValueError("invalid offset: " + s)
+
+    def _parse_rfc(self, s):
+        lines = s.splitlines()
+        if not lines:
+            raise ValueError("empty string")
+
+        # Unfold
+        i = 0
+        while i < len(lines):
+            line = lines[i].rstrip()
+            if not line:
+                del lines[i]
+            elif i > 0 and line[0] == " ":
+                lines[i-1] += line[1:]
+                del lines[i]
+            else:
+                i += 1
+
+        tzid = None
+        comps = []
+        invtz = False
+        comptype = None
+        for line in lines:
+            if not line:
+                continue
+            name, value = line.split(':', 1)
+            parms = name.split(';')
+            if not parms:
+                raise ValueError("empty property name")
+            name = parms[0].upper()
+            parms = parms[1:]
+            if invtz:
+                if name == "BEGIN":
+                    if value in ("STANDARD", "DAYLIGHT"):
+                        # Process component
+                        pass
+                    else:
+                        raise ValueError("unknown component: "+value)
+                    comptype = value
+                    founddtstart = False
+                    tzoffsetfrom = None
+                    tzoffsetto = None
+                    rrulelines = []
+                    tzname = None
+                elif name == "END":
+                    if value == "VTIMEZONE":
+                        if comptype:
+                            raise ValueError("component not closed: "+comptype)
+                        if not tzid:
+                            raise ValueError("mandatory TZID not found")
+                        if not comps:
+                            raise ValueError(
+                                "at least one component is needed")
+                        # Process vtimezone
+                        self._vtz[tzid] = _tzicalvtz(tzid, comps)
+                        invtz = False
+                    elif value == comptype:
+                        if not founddtstart:
+                            raise ValueError("mandatory DTSTART not found")
+                        if tzoffsetfrom is None:
+                            raise ValueError(
+                                "mandatory TZOFFSETFROM not found")
+                        if tzoffsetto is None:
+                            raise ValueError(
+                                "mandatory TZOFFSETFROM not found")
+                        # Process component
+                        rr = None
+                        if rrulelines:
+                            rr = rrule.rrulestr("\n".join(rrulelines),
+                                                compatible=True,
+                                                ignoretz=True,
+                                                cache=True)
+                        comp = _tzicalvtzcomp(tzoffsetfrom, tzoffsetto,
+                                              (comptype == "DAYLIGHT"),
+                                              tzname, rr)
+                        comps.append(comp)
+                        comptype = None
+                    else:
+                        raise ValueError("invalid component end: "+value)
+                elif comptype:
+                    if name == "DTSTART":
+                        # DTSTART in VTIMEZONE takes a subset of valid RRULE
+                        # values under RFC 5545.
+                        for parm in parms:
+                            if parm != 'VALUE=DATE-TIME':
+                                msg = ('Unsupported DTSTART param in ' +
+                                       'VTIMEZONE: ' + parm)
+                                raise ValueError(msg)
+                        rrulelines.append(line)
+                        founddtstart = True
+                    elif name in ("RRULE", "RDATE", "EXRULE", "EXDATE"):
+                        rrulelines.append(line)
+                    elif name == "TZOFFSETFROM":
+                        if parms:
+                            raise ValueError(
+                                "unsupported %s parm: %s " % (name, parms[0]))
+                        tzoffsetfrom = self._parse_offset(value)
+                    elif name == "TZOFFSETTO":
+                        if parms:
+                            raise ValueError(
+                                "unsupported TZOFFSETTO parm: "+parms[0])
+                        tzoffsetto = self._parse_offset(value)
+                    elif name == "TZNAME":
+                        if parms:
+                            raise ValueError(
+                                "unsupported TZNAME parm: "+parms[0])
+                        tzname = value
+                    elif name == "COMMENT":
+                        pass
+                    else:
+                        raise ValueError("unsupported property: "+name)
+                else:
+                    if name == "TZID":
+                        if parms:
+                            raise ValueError(
+                                "unsupported TZID parm: "+parms[0])
+                        tzid = value
+                    elif name in ("TZURL", "LAST-MODIFIED", "COMMENT"):
+                        pass
+                    else:
+                        raise ValueError("unsupported property: "+name)
+            elif name == "BEGIN" and value == "VTIMEZONE":
+                tzid = None
+                comps = []
+                invtz = True
+
+    def __repr__(self):
+        return "%s(%s)" % (self.__class__.__name__, repr(self._s))
+
+
+if sys.platform != "win32":
+    TZFILES = ["/etc/localtime", "localtime"]
+    TZPATHS = ["/usr/share/zoneinfo",
+               "/usr/lib/zoneinfo",
+               "/usr/share/lib/zoneinfo",
+               "/etc/zoneinfo"]
+else:
+    TZFILES = []
+    TZPATHS = []
+
+
+def __get_gettz():
+    tzlocal_classes = (tzlocal,)
+    if tzwinlocal is not None:
+        tzlocal_classes += (tzwinlocal,)
+
+    class GettzFunc(object):
+        """
+        Retrieve a time zone object from a string representation
+
+        This function is intended to retrieve the :py:class:`tzinfo` subclass
+        that best represents the time zone that would be used if a POSIX
+        `TZ variable`_ were set to the same value.
+
+        If no argument or an empty string is passed to ``gettz``, local time
+        is returned:
+
+        .. code-block:: python3
+
+            >>> gettz()
+            tzfile('/etc/localtime')
+
+        This function is also the preferred way to map IANA tz database keys
+        to :class:`tzfile` objects:
+
+        .. code-block:: python3
+
+            >>> gettz('Pacific/Kiritimati')
+            tzfile('/usr/share/zoneinfo/Pacific/Kiritimati')
+
+        On Windows, the standard is extended to include the Windows-specific
+        zone names provided by the operating system:
+
+        .. code-block:: python3
+
+            >>> gettz('Egypt Standard Time')
+            tzwin('Egypt Standard Time')
+
+        Passing a GNU ``TZ`` style string time zone specification returns a
+        :class:`tzstr` object:
+
+        .. code-block:: python3
+
+            >>> gettz('AEST-10AEDT-11,M10.1.0/2,M4.1.0/3')
+            tzstr('AEST-10AEDT-11,M10.1.0/2,M4.1.0/3')
+
+        :param name:
+            A time zone name (IANA, or, on Windows, Windows keys), location of
+            a ``tzfile(5)`` zoneinfo file or ``TZ`` variable style time zone
+            specifier. An empty string, no argument or ``None`` is interpreted
+            as local time.
+
+        :return:
+            Returns an instance of one of ``dateutil``'s :py:class:`tzinfo`
+            subclasses.
+
+        .. versionchanged:: 2.7.0
+
+            After version 2.7.0, any two calls to ``gettz`` using the same
+            input strings will return the same object:
+
+            .. code-block:: python3
+
+                >>> tz.gettz('America/Chicago') is tz.gettz('America/Chicago')
+                True
+
+            In addition to improving performance, this ensures that
+            `"same zone" semantics`_ are used for datetimes in the same zone.
+
+
+        .. _`TZ variable`:
+            https://www.gnu.org/software/libc/manual/html_node/TZ-Variable.html
+
+        .. _`"same zone" semantics`:
+            https://blog.ganssle.io/articles/2018/02/aware-datetime-arithmetic.html
+        """
+        def __init__(self):
+
+            self.__instances = weakref.WeakValueDictionary()
+            self.__strong_cache_size = 8
+            self.__strong_cache = OrderedDict()
+            self._cache_lock = _thread.allocate_lock()
+
+        def __call__(self, name=None):
+            with self._cache_lock:
+                rv = self.__instances.get(name, None)
+
+                if rv is None:
+                    rv = self.nocache(name=name)
+                    if not (name is None
+                            or isinstance(rv, tzlocal_classes)
+                            or rv is None):
+                        # tzlocal is slightly more complicated than the other
+                        # time zone providers because it depends on environment
+                        # at construction time, so don't cache that.
+                        #
+                        # We also cannot store weak references to None, so we
+                        # will also not store that.
+                        self.__instances[name] = rv
+                    else:
+                        # No need for strong caching, return immediately
+                        return rv
+
+                self.__strong_cache[name] = self.__strong_cache.pop(name, rv)
+
+                if len(self.__strong_cache) > self.__strong_cache_size:
+                    self.__strong_cache.popitem(last=False)
+
+            return rv
+
+        def set_cache_size(self, size):
+            with self._cache_lock:
+                self.__strong_cache_size = size
+                while len(self.__strong_cache) > size:
+                    self.__strong_cache.popitem(last=False)
+
+        def cache_clear(self):
+            with self._cache_lock:
+                self.__instances = weakref.WeakValueDictionary()
+                self.__strong_cache.clear()
+
+        @staticmethod
+        def nocache(name=None):
+            """A non-cached version of gettz"""
+            tz = None
+            if not name:
+                try:
+                    name = os.environ["TZ"]
+                except KeyError:
+                    pass
+            if name is None or name in ("", ":"):
+                for filepath in TZFILES:
+                    if not os.path.isabs(filepath):
+                        filename = filepath
+                        for path in TZPATHS:
+                            filepath = os.path.join(path, filename)
+                            if os.path.isfile(filepath):
+                                break
+                        else:
+                            continue
+                    if os.path.isfile(filepath):
+                        try:
+                            tz = tzfile(filepath)
+                            break
+                        except (IOError, OSError, ValueError):
+                            pass
+                else:
+                    tz = tzlocal()
+            else:
+                try:
+                    if name.startswith(":"):
+                        name = name[1:]
+                except TypeError as e:
+                    if isinstance(name, bytes):
+                        new_msg = "gettz argument should be str, not bytes"
+                        six.raise_from(TypeError(new_msg), e)
+                    else:
+                        raise
+                if os.path.isabs(name):
+                    if os.path.isfile(name):
+                        tz = tzfile(name)
+                    else:
+                        tz = None
+                else:
+                    for path in TZPATHS:
+                        filepath = os.path.join(path, name)
+                        if not os.path.isfile(filepath):
+                            filepath = filepath.replace(' ', '_')
+                            if not os.path.isfile(filepath):
+                                continue
+                        try:
+                            tz = tzfile(filepath)
+                            break
+                        except (IOError, OSError, ValueError):
+                            pass
+                    else:
+                        tz = None
+                        if tzwin is not None:
+                            try:
+                                tz = tzwin(name)
+                            except (WindowsError, UnicodeEncodeError):
+                                # UnicodeEncodeError is for Python 2.7 compat
+                                tz = None
+
+                        if not tz:
+                            from dateutil.zoneinfo import get_zonefile_instance
+                            tz = get_zonefile_instance().get(name)
+
+                        if not tz:
+                            for c in name:
+                                # name is not a tzstr unless it has at least
+                                # one offset. For short values of "name", an
+                                # explicit for loop seems to be the fastest way
+                                # To determine if a string contains a digit
+                                if c in "0123456789":
+                                    try:
+                                        tz = tzstr(name)
+                                    except ValueError:
+                                        pass
+                                    break
+                            else:
+                                if name in ("GMT", "UTC"):
+                                    tz = UTC
+                                elif name in time.tzname:
+                                    tz = tzlocal()
+            return tz
+
+    return GettzFunc()
+
+
+gettz = __get_gettz()
+del __get_gettz
+
+
+def datetime_exists(dt, tz=None):
+    """
+    Given a datetime and a time zone, determine whether or not a given datetime
+    would fall in a gap.
+
+    :param dt:
+        A :class:`datetime.datetime` (whose time zone will be ignored if ``tz``
+        is provided.)
+
+    :param tz:
+        A :class:`datetime.tzinfo` with support for the ``fold`` attribute. If
+        ``None`` or not provided, the datetime's own time zone will be used.
+
+    :return:
+        Returns a boolean value whether or not the "wall time" exists in
+        ``tz``.
+
+    .. versionadded:: 2.7.0
+    """
+    if tz is None:
+        if dt.tzinfo is None:
+            raise ValueError('Datetime is naive and no time zone provided.')
+        tz = dt.tzinfo
+
+    dt = dt.replace(tzinfo=None)
+
+    # This is essentially a test of whether or not the datetime can survive
+    # a round trip to UTC.
+    dt_rt = dt.replace(tzinfo=tz).astimezone(UTC).astimezone(tz)
+    dt_rt = dt_rt.replace(tzinfo=None)
+
+    return dt == dt_rt
+
+
+def datetime_ambiguous(dt, tz=None):
+    """
+    Given a datetime and a time zone, determine whether or not a given datetime
+    is ambiguous (i.e if there are two times differentiated only by their DST
+    status).
+
+    :param dt:
+        A :class:`datetime.datetime` (whose time zone will be ignored if ``tz``
+        is provided.)
+
+    :param tz:
+        A :class:`datetime.tzinfo` with support for the ``fold`` attribute. If
+        ``None`` or not provided, the datetime's own time zone will be used.
+
+    :return:
+        Returns a boolean value whether or not the "wall time" is ambiguous in
+        ``tz``.
+
+    .. versionadded:: 2.6.0
+    """
+    if tz is None:
+        if dt.tzinfo is None:
+            raise ValueError('Datetime is naive and no time zone provided.')
+
+        tz = dt.tzinfo
+
+    # If a time zone defines its own "is_ambiguous" function, we'll use that.
+    is_ambiguous_fn = getattr(tz, 'is_ambiguous', None)
+    if is_ambiguous_fn is not None:
+        try:
+            return tz.is_ambiguous(dt)
+        except Exception:
+            pass
+
+    # If it doesn't come out and tell us it's ambiguous, we'll just check if
+    # the fold attribute has any effect on this particular date and time.
+    dt = dt.replace(tzinfo=tz)
+    wall_0 = enfold(dt, fold=0)
+    wall_1 = enfold(dt, fold=1)
+
+    same_offset = wall_0.utcoffset() == wall_1.utcoffset()
+    same_dst = wall_0.dst() == wall_1.dst()
+
+    return not (same_offset and same_dst)
+
+
+def resolve_imaginary(dt):
+    """
+    Given a datetime that may be imaginary, return an existing datetime.
+
+    This function assumes that an imaginary datetime represents what the
+    wall time would be in a zone had the offset transition not occurred, so
+    it will always fall forward by the transition's change in offset.
+
+    .. doctest::
+
+        >>> from dateutil import tz
+        >>> from datetime import datetime
+        >>> NYC = tz.gettz('America/New_York')
+        >>> print(tz.resolve_imaginary(datetime(2017, 3, 12, 2, 30, tzinfo=NYC)))
+        2017-03-12 03:30:00-04:00
+
+        >>> KIR = tz.gettz('Pacific/Kiritimati')
+        >>> print(tz.resolve_imaginary(datetime(1995, 1, 1, 12, 30, tzinfo=KIR)))
+        1995-01-02 12:30:00+14:00
+
+    As a note, :func:`datetime.astimezone` is guaranteed to produce a valid,
+    existing datetime, so a round-trip to and from UTC is sufficient to get
+    an extant datetime, however, this generally "falls back" to an earlier time
+    rather than falling forward to the STD side (though no guarantees are made
+    about this behavior).
+
+    :param dt:
+        A :class:`datetime.datetime` which may or may not exist.
+
+    :return:
+        Returns an existing :class:`datetime.datetime`. If ``dt`` was not
+        imaginary, the datetime returned is guaranteed to be the same object
+        passed to the function.
+
+    .. versionadded:: 2.7.0
+    """
+    if dt.tzinfo is not None and not datetime_exists(dt):
+
+        curr_offset = (dt + datetime.timedelta(hours=24)).utcoffset()
+        old_offset = (dt - datetime.timedelta(hours=24)).utcoffset()
+
+        dt += curr_offset - old_offset
+
+    return dt
+
+
+def _datetime_to_timestamp(dt):
+    """
+    Convert a :class:`datetime.datetime` object to an epoch timestamp in
+    seconds since January 1, 1970, ignoring the time zone.
+    """
+    return (dt.replace(tzinfo=None) - EPOCH).total_seconds()
+
+
+if sys.version_info >= (3, 6):
+    def _get_supported_offset(second_offset):
+        return second_offset
+else:
+    def _get_supported_offset(second_offset):
+        # For python pre-3.6, round to full-minutes if that's not the case.
+        # Python's datetime doesn't accept sub-minute timezones. Check
+        # http://python.org/sf/1447945 or https://bugs.python.org/issue5288
+        # for some information.
+        old_offset = second_offset
+        calculated_offset = 60 * ((second_offset + 30) // 60)
+        return calculated_offset
+
+
+try:
+    # Python 3.7 feature
+    from contextlib import nullcontext as _nullcontext
+except ImportError:
+    class _nullcontext(object):
+        """
+        Class for wrapping contexts so that they are passed through in a
+        with statement.
+        """
+        def __init__(self, context):
+            self.context = context
+
+        def __enter__(self):
+            return self.context
+
+        def __exit__(*args, **kwargs):
+            pass
+
+# vim:ts=4:sw=4:et
diff --git a/myvenv/Lib/site-packages/dateutil/tz/win.py b/myvenv/Lib/site-packages/dateutil/tz/win.py
new file mode 100644
index 0000000..cde07ba
--- /dev/null
+++ b/myvenv/Lib/site-packages/dateutil/tz/win.py
@@ -0,0 +1,370 @@
+# -*- coding: utf-8 -*-
+"""
+This module provides an interface to the native time zone data on Windows,
+including :py:class:`datetime.tzinfo` implementations.
+
+Attempting to import this module on a non-Windows platform will raise an
+:py:obj:`ImportError`.
+"""
+# This code was originally contributed by Jeffrey Harris.
+import datetime
+import struct
+
+from six.moves import winreg
+from six import text_type
+
+try:
+    import ctypes
+    from ctypes import wintypes
+except ValueError:
+    # ValueError is raised on non-Windows systems for some horrible reason.
+    raise ImportError("Running tzwin on non-Windows system")
+
+from ._common import tzrangebase
+
+__all__ = ["tzwin", "tzwinlocal", "tzres"]
+
+ONEWEEK = datetime.timedelta(7)
+
+TZKEYNAMENT = r"SOFTWARE\Microsoft\Windows NT\CurrentVersion\Time Zones"
+TZKEYNAME9X = r"SOFTWARE\Microsoft\Windows\CurrentVersion\Time Zones"
+TZLOCALKEYNAME = r"SYSTEM\CurrentControlSet\Control\TimeZoneInformation"
+
+
+def _settzkeyname():
+    handle = winreg.ConnectRegistry(None, winreg.HKEY_LOCAL_MACHINE)
+    try:
+        winreg.OpenKey(handle, TZKEYNAMENT).Close()
+        TZKEYNAME = TZKEYNAMENT
+    except WindowsError:
+        TZKEYNAME = TZKEYNAME9X
+    handle.Close()
+    return TZKEYNAME
+
+
+TZKEYNAME = _settzkeyname()
+
+
+class tzres(object):
+    """
+    Class for accessing ``tzres.dll``, which contains timezone name related
+    resources.
+
+    .. versionadded:: 2.5.0
+    """
+    p_wchar = ctypes.POINTER(wintypes.WCHAR)        # Pointer to a wide char
+
+    def __init__(self, tzres_loc='tzres.dll'):
+        # Load the user32 DLL so we can load strings from tzres
+        user32 = ctypes.WinDLL('user32')
+
+        # Specify the LoadStringW function
+        user32.LoadStringW.argtypes = (wintypes.HINSTANCE,
+                                       wintypes.UINT,
+                                       wintypes.LPWSTR,
+                                       ctypes.c_int)
+
+        self.LoadStringW = user32.LoadStringW
+        self._tzres = ctypes.WinDLL(tzres_loc)
+        self.tzres_loc = tzres_loc
+
+    def load_name(self, offset):
+        """
+        Load a timezone name from a DLL offset (integer).
+
+        >>> from dateutil.tzwin import tzres
+        >>> tzr = tzres()
+        >>> print(tzr.load_name(112))
+        'Eastern Standard Time'
+
+        :param offset:
+            A positive integer value referring to a string from the tzres dll.
+
+        .. note::
+
+            Offsets found in the registry are generally of the form
+            ``@tzres.dll,-114``. The offset in this case is 114, not -114.
+
+        """
+        resource = self.p_wchar()
+        lpBuffer = ctypes.cast(ctypes.byref(resource), wintypes.LPWSTR)
+        nchar = self.LoadStringW(self._tzres._handle, offset, lpBuffer, 0)
+        return resource[:nchar]
+
+    def name_from_string(self, tzname_str):
+        """
+        Parse strings as returned from the Windows registry into the time zone
+        name as defined in the registry.
+
+        >>> from dateutil.tzwin import tzres
+        >>> tzr = tzres()
+        >>> print(tzr.name_from_string('@tzres.dll,-251'))
+        'Dateline Daylight Time'
+        >>> print(tzr.name_from_string('Eastern Standard Time'))
+        'Eastern Standard Time'
+
+        :param tzname_str:
+            A timezone name string as returned from a Windows registry key.
+
+        :return:
+            Returns the localized timezone string from tzres.dll if the string
+            is of the form `@tzres.dll,-offset`, else returns the input string.
+        """
+        if not tzname_str.startswith('@'):
+            return tzname_str
+
+        name_splt = tzname_str.split(',-')
+        try:
+            offset = int(name_splt[1])
+        except:
+            raise ValueError("Malformed timezone string.")
+
+        return self.load_name(offset)
+
+
+class tzwinbase(tzrangebase):
+    """tzinfo class based on win32's timezones available in the registry."""
+    def __init__(self):
+        raise NotImplementedError('tzwinbase is an abstract base class')
+
+    def __eq__(self, other):
+        # Compare on all relevant dimensions, including name.
+        if not isinstance(other, tzwinbase):
+            return NotImplemented
+
+        return  (self._std_offset == other._std_offset and
+                 self._dst_offset == other._dst_offset and
+                 self._stddayofweek == other._stddayofweek and
+                 self._dstdayofweek == other._dstdayofweek and
+                 self._stdweeknumber == other._stdweeknumber and
+                 self._dstweeknumber == other._dstweeknumber and
+                 self._stdhour == other._stdhour and
+                 self._dsthour == other._dsthour and
+                 self._stdminute == other._stdminute and
+                 self._dstminute == other._dstminute and
+                 self._std_abbr == other._std_abbr and
+                 self._dst_abbr == other._dst_abbr)
+
+    @staticmethod
+    def list():
+        """Return a list of all time zones known to the system."""
+        with winreg.ConnectRegistry(None, winreg.HKEY_LOCAL_MACHINE) as handle:
+            with winreg.OpenKey(handle, TZKEYNAME) as tzkey:
+                result = [winreg.EnumKey(tzkey, i)
+                          for i in range(winreg.QueryInfoKey(tzkey)[0])]
+        return result
+
+    def display(self):
+        """
+        Return the display name of the time zone.
+        """
+        return self._display
+
+    def transitions(self, year):
+        """
+        For a given year, get the DST on and off transition times, expressed
+        always on the standard time side. For zones with no transitions, this
+        function returns ``None``.
+
+        :param year:
+            The year whose transitions you would like to query.
+
+        :return:
+            Returns a :class:`tuple` of :class:`datetime.datetime` objects,
+            ``(dston, dstoff)`` for zones with an annual DST transition, or
+            ``None`` for fixed offset zones.
+        """
+
+        if not self.hasdst:
+            return None
+
+        dston = picknthweekday(year, self._dstmonth, self._dstdayofweek,
+                               self._dsthour, self._dstminute,
+                               self._dstweeknumber)
+
+        dstoff = picknthweekday(year, self._stdmonth, self._stddayofweek,
+                                self._stdhour, self._stdminute,
+                                self._stdweeknumber)
+
+        # Ambiguous dates default to the STD side
+        dstoff -= self._dst_base_offset
+
+        return dston, dstoff
+
+    def _get_hasdst(self):
+        return self._dstmonth != 0
+
+    @property
+    def _dst_base_offset(self):
+        return self._dst_base_offset_
+
+
+class tzwin(tzwinbase):
+    """
+    Time zone object created from the zone info in the Windows registry
+
+    These are similar to :py:class:`dateutil.tz.tzrange` objects in that
+    the time zone data is provided in the format of a single offset rule
+    for either 0 or 2 time zone transitions per year.
+
+    :param: name
+        The name of a Windows time zone key, e.g. "Eastern Standard Time".
+        The full list of keys can be retrieved with :func:`tzwin.list`.
+    """
+
+    def __init__(self, name):
+        self._name = name
+
+        with winreg.ConnectRegistry(None, winreg.HKEY_LOCAL_MACHINE) as handle:
+            tzkeyname = text_type("{kn}\\{name}").format(kn=TZKEYNAME, name=name)
+            with winreg.OpenKey(handle, tzkeyname) as tzkey:
+                keydict = valuestodict(tzkey)
+
+        self._std_abbr = keydict["Std"]
+        self._dst_abbr = keydict["Dlt"]
+
+        self._display = keydict["Display"]
+
+        # See http://ww_winreg.jsiinc.com/SUBA/tip0300/rh0398.htm
+        tup = struct.unpack("=3l16h", keydict["TZI"])
+        stdoffset = -tup[0]-tup[1]          # Bias + StandardBias * -1
+        dstoffset = stdoffset-tup[2]        # + DaylightBias * -1
+        self._std_offset = datetime.timedelta(minutes=stdoffset)
+        self._dst_offset = datetime.timedelta(minutes=dstoffset)
+
+        # for the meaning see the win32 TIME_ZONE_INFORMATION structure docs
+        # http://msdn.microsoft.com/en-us/library/windows/desktop/ms725481(v=vs.85).aspx
+        (self._stdmonth,
+         self._stddayofweek,   # Sunday = 0
+         self._stdweeknumber,  # Last = 5
+         self._stdhour,
+         self._stdminute) = tup[4:9]
+
+        (self._dstmonth,
+         self._dstdayofweek,   # Sunday = 0
+         self._dstweeknumber,  # Last = 5
+         self._dsthour,
+         self._dstminute) = tup[12:17]
+
+        self._dst_base_offset_ = self._dst_offset - self._std_offset
+        self.hasdst = self._get_hasdst()
+
+    def __repr__(self):
+        return "tzwin(%s)" % repr(self._name)
+
+    def __reduce__(self):
+        return (self.__class__, (self._name,))
+
+
+class tzwinlocal(tzwinbase):
+    """
+    Class representing the local time zone information in the Windows registry
+
+    While :class:`dateutil.tz.tzlocal` makes system calls (via the :mod:`time`
+    module) to retrieve time zone information, ``tzwinlocal`` retrieves the
+    rules directly from the Windows registry and creates an object like
+    :class:`dateutil.tz.tzwin`.
+
+    Because Windows does not have an equivalent of :func:`time.tzset`, on
+    Windows, :class:`dateutil.tz.tzlocal` instances will always reflect the
+    time zone settings *at the time that the process was started*, meaning
+    changes to the machine's time zone settings during the run of a program
+    on Windows will **not** be reflected by :class:`dateutil.tz.tzlocal`.
+    Because ``tzwinlocal`` reads the registry directly, it is unaffected by
+    this issue.
+    """
+    def __init__(self):
+        with winreg.ConnectRegistry(None, winreg.HKEY_LOCAL_MACHINE) as handle:
+            with winreg.OpenKey(handle, TZLOCALKEYNAME) as tzlocalkey:
+                keydict = valuestodict(tzlocalkey)
+
+            self._std_abbr = keydict["StandardName"]
+            self._dst_abbr = keydict["DaylightName"]
+
+            try:
+                tzkeyname = text_type('{kn}\\{sn}').format(kn=TZKEYNAME,
+                                                          sn=self._std_abbr)
+                with winreg.OpenKey(handle, tzkeyname) as tzkey:
+                    _keydict = valuestodict(tzkey)
+                    self._display = _keydict["Display"]
+            except OSError:
+                self._display = None
+
+        stdoffset = -keydict["Bias"]-keydict["StandardBias"]
+        dstoffset = stdoffset-keydict["DaylightBias"]
+
+        self._std_offset = datetime.timedelta(minutes=stdoffset)
+        self._dst_offset = datetime.timedelta(minutes=dstoffset)
+
+        # For reasons unclear, in this particular key, the day of week has been
+        # moved to the END of the SYSTEMTIME structure.
+        tup = struct.unpack("=8h", keydict["StandardStart"])
+
+        (self._stdmonth,
+         self._stdweeknumber,  # Last = 5
+         self._stdhour,
+         self._stdminute) = tup[1:5]
+
+        self._stddayofweek = tup[7]
+
+        tup = struct.unpack("=8h", keydict["DaylightStart"])
+
+        (self._dstmonth,
+         self._dstweeknumber,  # Last = 5
+         self._dsthour,
+         self._dstminute) = tup[1:5]
+
+        self._dstdayofweek = tup[7]
+
+        self._dst_base_offset_ = self._dst_offset - self._std_offset
+        self.hasdst = self._get_hasdst()
+
+    def __repr__(self):
+        return "tzwinlocal()"
+
+    def __str__(self):
+        # str will return the standard name, not the daylight name.
+        return "tzwinlocal(%s)" % repr(self._std_abbr)
+
+    def __reduce__(self):
+        return (self.__class__, ())
+
+
+def picknthweekday(year, month, dayofweek, hour, minute, whichweek):
+    """ dayofweek == 0 means Sunday, whichweek 5 means last instance """
+    first = datetime.datetime(year, month, 1, hour, minute)
+
+    # This will work if dayofweek is ISO weekday (1-7) or Microsoft-style (0-6),
+    # Because 7 % 7 = 0
+    weekdayone = first.replace(day=((dayofweek - first.isoweekday()) % 7) + 1)
+    wd = weekdayone + ((whichweek - 1) * ONEWEEK)
+    if (wd.month != month):
+        wd -= ONEWEEK
+
+    return wd
+
+
+def valuestodict(key):
+    """Convert a registry key's values to a dictionary."""
+    dout = {}
+    size = winreg.QueryInfoKey(key)[1]
+    tz_res = None
+
+    for i in range(size):
+        key_name, value, dtype = winreg.EnumValue(key, i)
+        if dtype == winreg.REG_DWORD or dtype == winreg.REG_DWORD_LITTLE_ENDIAN:
+            # If it's a DWORD (32-bit integer), it's stored as unsigned - convert
+            # that to a proper signed integer
+            if value & (1 << 31):
+                value = value - (1 << 32)
+        elif dtype == winreg.REG_SZ:
+            # If it's a reference to the tzres DLL, load the actual string
+            if value.startswith('@tzres'):
+                tz_res = tz_res or tzres()
+                value = tz_res.name_from_string(value)
+
+            value = value.rstrip('\x00')    # Remove trailing nulls
+
+        dout[key_name] = value
+
+    return dout
diff --git a/myvenv/Lib/site-packages/dateutil/tzwin.py b/myvenv/Lib/site-packages/dateutil/tzwin.py
new file mode 100644
index 0000000..cebc673
--- /dev/null
+++ b/myvenv/Lib/site-packages/dateutil/tzwin.py
@@ -0,0 +1,2 @@
+# tzwin has moved to dateutil.tz.win
+from .tz.win import *
diff --git a/myvenv/Lib/site-packages/dateutil/utils.py b/myvenv/Lib/site-packages/dateutil/utils.py
new file mode 100644
index 0000000..dd2d245
--- /dev/null
+++ b/myvenv/Lib/site-packages/dateutil/utils.py
@@ -0,0 +1,71 @@
+# -*- coding: utf-8 -*-
+"""
+This module offers general convenience and utility functions for dealing with
+datetimes.
+
+.. versionadded:: 2.7.0
+"""
+from __future__ import unicode_literals
+
+from datetime import datetime, time
+
+
+def today(tzinfo=None):
+    """
+    Returns a :py:class:`datetime` representing the current day at midnight
+
+    :param tzinfo:
+        The time zone to attach (also used to determine the current day).
+
+    :return:
+        A :py:class:`datetime.datetime` object representing the current day
+        at midnight.
+    """
+
+    dt = datetime.now(tzinfo)
+    return datetime.combine(dt.date(), time(0, tzinfo=tzinfo))
+
+
+def default_tzinfo(dt, tzinfo):
+    """
+    Sets the ``tzinfo`` parameter on naive datetimes only
+
+    This is useful for example when you are provided a datetime that may have
+    either an implicit or explicit time zone, such as when parsing a time zone
+    string.
+
+    .. doctest::
+
+        >>> from dateutil.tz import tzoffset
+        >>> from dateutil.parser import parse
+        >>> from dateutil.utils import default_tzinfo
+        >>> dflt_tz = tzoffset("EST", -18000)
+        >>> print(default_tzinfo(parse('2014-01-01 12:30 UTC'), dflt_tz))
+        2014-01-01 12:30:00+00:00
+        >>> print(default_tzinfo(parse('2014-01-01 12:30'), dflt_tz))
+        2014-01-01 12:30:00-05:00
+
+    :param dt:
+        The datetime on which to replace the time zone
+
+    :param tzinfo:
+        The :py:class:`datetime.tzinfo` subclass instance to assign to
+        ``dt`` if (and only if) it is naive.
+
+    :return:
+        Returns an aware :py:class:`datetime.datetime`.
+    """
+    if dt.tzinfo is not None:
+        return dt
+    else:
+        return dt.replace(tzinfo=tzinfo)
+
+
+def within_delta(dt1, dt2, delta):
+    """
+    Useful for comparing two datetimes that may have a negligible difference
+    to be considered equal.
+    """
+    delta = abs(delta)
+    difference = dt1 - dt2
+    return -delta <= difference <= delta
diff --git a/myvenv/Lib/site-packages/dateutil/zoneinfo/__init__.py b/myvenv/Lib/site-packages/dateutil/zoneinfo/__init__.py
new file mode 100644
index 0000000..34f11ad
--- /dev/null
+++ b/myvenv/Lib/site-packages/dateutil/zoneinfo/__init__.py
@@ -0,0 +1,167 @@
+# -*- coding: utf-8 -*-
+import warnings
+import json
+
+from tarfile import TarFile
+from pkgutil import get_data
+from io import BytesIO
+
+from dateutil.tz import tzfile as _tzfile
+
+__all__ = ["get_zonefile_instance", "gettz", "gettz_db_metadata"]
+
+ZONEFILENAME = "dateutil-zoneinfo.tar.gz"
+METADATA_FN = 'METADATA'
+
+
+class tzfile(_tzfile):
+    def __reduce__(self):
+        return (gettz, (self._filename,))
+
+
+def getzoneinfofile_stream():
+    try:
+        return BytesIO(get_data(__name__, ZONEFILENAME))
+    except IOError as e:  # TODO  switch to FileNotFoundError?
+        warnings.warn("I/O error({0}): {1}".format(e.errno, e.strerror))
+        return None
+
+
+class ZoneInfoFile(object):
+    def __init__(self, zonefile_stream=None):
+        if zonefile_stream is not None:
+            with TarFile.open(fileobj=zonefile_stream) as tf:
+                self.zones = {zf.name: tzfile(tf.extractfile(zf), filename=zf.name)
+                              for zf in tf.getmembers()
+                              if zf.isfile() and zf.name != METADATA_FN}
+                # deal with links: They'll point to their parent object. Less
+                # waste of memory
+                links = {zl.name: self.zones[zl.linkname]
+                         for zl in tf.getmembers() if
+                         zl.islnk() or zl.issym()}
+                self.zones.update(links)
+                try:
+                    metadata_json = tf.extractfile(tf.getmember(METADATA_FN))
+                    metadata_str = metadata_json.read().decode('UTF-8')
+                    self.metadata = json.loads(metadata_str)
+                except KeyError:
+                    # no metadata in tar file
+                    self.metadata = None
+        else:
+            self.zones = {}
+            self.metadata = None
+
+    def get(self, name, default=None):
+        """
+        Wrapper for :func:`ZoneInfoFile.zones.get`. This is a convenience method
+        for retrieving zones from the zone dictionary.
+
+        :param name:
+            The name of the zone to retrieve. (Generally IANA zone names)
+
+        :param default:
+            The value to return in the event of a missing key.
+
+        .. versionadded:: 2.6.0
+
+        """
+        return self.zones.get(name, default)
+
+
+# The current API has gettz as a module function, although in fact it taps into
+# a stateful class. So as a workaround for now, without changing the API, we
+# will create a new "global" class instance the first time a user requests a
+# timezone. Ugly, but adheres to the api.
+#
+# TODO: Remove after deprecation period.
+_CLASS_ZONE_INSTANCE = []
+
+
+def get_zonefile_instance(new_instance=False):
+    """
+    This is a convenience function which provides a :class:`ZoneInfoFile`
+    instance using the data provided by the ``dateutil`` package. By default, it
+    caches a single instance of the ZoneInfoFile object and returns that.
+
+    :param new_instance:
+        If ``True``, a new instance of :class:`ZoneInfoFile` is instantiated and
+        used as the cached instance for the next call. Otherwise, new instances
+        are created only as necessary.
+
+    :return:
+        Returns a :class:`ZoneInfoFile` object.
+
+    .. versionadded:: 2.6
+    """
+    if new_instance:
+        zif = None
+    else:
+        zif = getattr(get_zonefile_instance, '_cached_instance', None)
+
+    if zif is None:
+        zif = ZoneInfoFile(getzoneinfofile_stream())
+
+        get_zonefile_instance._cached_instance = zif
+
+    return zif
+
+
+def gettz(name):
+    """
+    This retrieves a time zone from the local zoneinfo tarball that is packaged
+    with dateutil.
+
+    :param name:
+        An IANA-style time zone name, as found in the zoneinfo file.
+
+    :return:
+        Returns a :class:`dateutil.tz.tzfile` time zone object.
+
+    .. warning::
+        It is generally inadvisable to use this function, and it is only
+        provided for API compatibility with earlier versions. This is *not*
+        equivalent to ``dateutil.tz.gettz()``, which selects an appropriate
+        time zone based on the inputs, favoring system zoneinfo. This is ONLY
+        for accessing the dateutil-specific zoneinfo (which may be out of
+        date compared to the system zoneinfo).
+
+    .. deprecated:: 2.6
+        If you need to use a specific zoneinfofile over the system zoneinfo,
+        instantiate a :class:`dateutil.zoneinfo.ZoneInfoFile` object and call
+        :func:`dateutil.zoneinfo.ZoneInfoFile.get(name)` instead.
+
+        Use :func:`get_zonefile_instance` to retrieve an instance of the
+        dateutil-provided zoneinfo.
+    """
+    warnings.warn("zoneinfo.gettz() will be removed in future versions, "
+                  "to use the dateutil-provided zoneinfo files, instantiate a "
+                  "ZoneInfoFile object and use ZoneInfoFile.zones.get() "
+                  "instead. See the documentation for details.",
+                  DeprecationWarning)
+
+    if len(_CLASS_ZONE_INSTANCE) == 0:
+        _CLASS_ZONE_INSTANCE.append(ZoneInfoFile(getzoneinfofile_stream()))
+    return _CLASS_ZONE_INSTANCE[0].zones.get(name)
+
+
+def gettz_db_metadata():
+    """ Get the zonefile metadata
+
+    See `zonefile_metadata`_
+
+    :returns:
+        A dictionary with the database metadata
+
+    .. deprecated:: 2.6
+        See deprecation warning in :func:`zoneinfo.gettz`. To get metadata,
+        query the attribute ``zoneinfo.ZoneInfoFile.metadata``.
+    """
+    warnings.warn("zoneinfo.gettz_db_metadata() will be removed in future "
+                  "versions, to use the dateutil-provided zoneinfo files, "
+                  "ZoneInfoFile object and query the 'metadata' attribute "
+                  "instead. See the documentation for details.",
+                  DeprecationWarning)
+
+    if len(_CLASS_ZONE_INSTANCE) == 0:
+        _CLASS_ZONE_INSTANCE.append(ZoneInfoFile(getzoneinfofile_stream()))
+    return _CLASS_ZONE_INSTANCE[0].metadata
diff --git a/myvenv/Lib/site-packages/dateutil/zoneinfo/__pycache__/__init__.cpython-39.pyc b/myvenv/Lib/site-packages/dateutil/zoneinfo/__pycache__/__init__.cpython-39.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..f45a02abfc16acd75fc5d1b9ebd755c205d7aac8
GIT binary patch
literal 5742
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

literal 0
HcmV?d00001

diff --git a/myvenv/Lib/site-packages/dateutil/zoneinfo/__pycache__/rebuild.cpython-39.pyc b/myvenv/Lib/site-packages/dateutil/zoneinfo/__pycache__/rebuild.cpython-39.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..2660e91ff1abbbbdc40683759836b86c88fc6b4a
GIT binary patch
literal 2694
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
Hdbj=yUBKSP

literal 0
HcmV?d00001

diff --git a/myvenv/Lib/site-packages/dateutil/zoneinfo/dateutil-zoneinfo.tar.gz b/myvenv/Lib/site-packages/dateutil/zoneinfo/dateutil-zoneinfo.tar.gz
new file mode 100644
index 0000000000000000000000000000000000000000..524c48e12db7dfe159f282e4664f71ce249e1970
GIT binary patch
literal 174394
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

literal 0
HcmV?d00001

diff --git a/myvenv/Lib/site-packages/dateutil/zoneinfo/rebuild.py b/myvenv/Lib/site-packages/dateutil/zoneinfo/rebuild.py
new file mode 100644
index 0000000..684c658
--- /dev/null
+++ b/myvenv/Lib/site-packages/dateutil/zoneinfo/rebuild.py
@@ -0,0 +1,75 @@
+import logging
+import os
+import tempfile
+import shutil
+import json
+from subprocess import check_call, check_output
+from tarfile import TarFile
+
+from dateutil.zoneinfo import METADATA_FN, ZONEFILENAME
+
+
+def rebuild(filename, tag=None, format="gz", zonegroups=[], metadata=None):
+    """Rebuild the internal timezone info in dateutil/zoneinfo/zoneinfo*tar*
+
+    filename is the timezone tarball from ``ftp.iana.org/tz``.
+
+    """
+    tmpdir = tempfile.mkdtemp()
+    zonedir = os.path.join(tmpdir, "zoneinfo")
+    moduledir = os.path.dirname(__file__)
+    try:
+        with TarFile.open(filename) as tf:
+            for name in zonegroups:
+                tf.extract(name, tmpdir)
+            filepaths = [os.path.join(tmpdir, n) for n in zonegroups]
+
+            _run_zic(zonedir, filepaths)
+
+        # write metadata file
+        with open(os.path.join(zonedir, METADATA_FN), 'w') as f:
+            json.dump(metadata, f, indent=4, sort_keys=True)
+        target = os.path.join(moduledir, ZONEFILENAME)
+        with TarFile.open(target, "w:%s" % format) as tf:
+            for entry in os.listdir(zonedir):
+                entrypath = os.path.join(zonedir, entry)
+                tf.add(entrypath, entry)
+    finally:
+        shutil.rmtree(tmpdir)
+
+
+def _run_zic(zonedir, filepaths):
+    """Calls the ``zic`` compiler in a compatible way to get a "fat" binary.
+
+    Recent versions of ``zic`` default to ``-b slim``, while older versions
+    don't even have the ``-b`` option (but default to "fat" binaries). The
+    current version of dateutil does not support Version 2+ TZif files, which
+    causes problems when used in conjunction with "slim" binaries, so this
+    function is used to ensure that we always get a "fat" binary.
+    """
+
+    try:
+        help_text = check_output(["zic", "--help"])
+    except OSError as e:
+        _print_on_nosuchfile(e)
+        raise
+
+    if b"-b " in help_text:
+        bloat_args = ["-b", "fat"]
+    else:
+        bloat_args = []
+
+    check_call(["zic"] + bloat_args + ["-d", zonedir] + filepaths)
+
+
+def _print_on_nosuchfile(e):
+    """Print helpful troubleshooting message
+
+    e is an exception raised by subprocess.check_call()
+
+    """
+    if e.errno == 2:
+        logging.error(
+            "Could not find zic. Perhaps you need to install "
+            "libc-bin or some other package that provides it, "
+            "or it's not in your PATH?")
diff --git a/myvenv/Lib/site-packages/python_dateutil-2.8.2.dist-info/INSTALLER b/myvenv/Lib/site-packages/python_dateutil-2.8.2.dist-info/INSTALLER
new file mode 100644
index 0000000..a1b589e
--- /dev/null
+++ b/myvenv/Lib/site-packages/python_dateutil-2.8.2.dist-info/INSTALLER
@@ -0,0 +1 @@
+pip
diff --git a/myvenv/Lib/site-packages/python_dateutil-2.8.2.dist-info/LICENSE b/myvenv/Lib/site-packages/python_dateutil-2.8.2.dist-info/LICENSE
new file mode 100644
index 0000000..1e65815
--- /dev/null
+++ b/myvenv/Lib/site-packages/python_dateutil-2.8.2.dist-info/LICENSE
@@ -0,0 +1,54 @@
+Copyright 2017- Paul Ganssle <paul@ganssle.io>
+Copyright 2017- dateutil contributors (see AUTHORS file)
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+
+The above license applies to all contributions after 2017-12-01, as well as
+all contributions that have been re-licensed (see AUTHORS file for the list of
+contributors who have re-licensed their code).
+--------------------------------------------------------------------------------
+dateutil - Extensions to the standard Python datetime module.
+
+Copyright (c) 2003-2011 - Gustavo Niemeyer <gustavo@niemeyer.net>
+Copyright (c) 2012-2014 - Tomi Pieviläinen <tomi.pievilainen@iki.fi>
+Copyright (c) 2014-2016 - Yaron de Leeuw <me@jarondl.net>
+Copyright (c) 2015-     - Paul Ganssle <paul@ganssle.io>
+Copyright (c) 2015-     - dateutil contributors (see AUTHORS file)
+
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright notice,
+      this list of conditions and the following disclaimer in the documentation
+      and/or other materials provided with the distribution.
+    * Neither the name of the copyright holder nor the names of its
+      contributors may be used to endorse or promote products derived from
+      this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+The above BSD License Applies to all code, even that also covered by Apache 2.0.
\ No newline at end of file
diff --git a/myvenv/Lib/site-packages/python_dateutil-2.8.2.dist-info/METADATA b/myvenv/Lib/site-packages/python_dateutil-2.8.2.dist-info/METADATA
new file mode 100644
index 0000000..1e46c96
--- /dev/null
+++ b/myvenv/Lib/site-packages/python_dateutil-2.8.2.dist-info/METADATA
@@ -0,0 +1,204 @@
+Metadata-Version: 2.1
+Name: python-dateutil
+Version: 2.8.2
+Summary: Extensions to the standard Python datetime module
+Home-page: https://github.com/dateutil/dateutil
+Author: Gustavo Niemeyer
+Author-email: gustavo@niemeyer.net
+Maintainer: Paul Ganssle
+Maintainer-email: dateutil@python.org
+License: Dual License
+Project-URL: Documentation, https://dateutil.readthedocs.io/en/stable/
+Project-URL: Source, https://github.com/dateutil/dateutil
+Platform: UNKNOWN
+Classifier: Development Status :: 5 - Production/Stable
+Classifier: Intended Audience :: Developers
+Classifier: License :: OSI Approved :: BSD License
+Classifier: License :: OSI Approved :: Apache Software License
+Classifier: Programming Language :: Python
+Classifier: Programming Language :: Python :: 2
+Classifier: Programming Language :: Python :: 2.7
+Classifier: Programming Language :: Python :: 3
+Classifier: Programming Language :: Python :: 3.3
+Classifier: Programming Language :: Python :: 3.4
+Classifier: Programming Language :: Python :: 3.5
+Classifier: Programming Language :: Python :: 3.6
+Classifier: Programming Language :: Python :: 3.7
+Classifier: Programming Language :: Python :: 3.8
+Classifier: Programming Language :: Python :: 3.9
+Classifier: Topic :: Software Development :: Libraries
+Requires-Python: !=3.0.*,!=3.1.*,!=3.2.*,>=2.7
+Description-Content-Type: text/x-rst
+License-File: LICENSE
+Requires-Dist: six (>=1.5)
+
+dateutil - powerful extensions to datetime
+==========================================
+
+|pypi| |support| |licence|
+
+|gitter| |readthedocs|
+
+|travis| |appveyor| |pipelines| |coverage|
+
+.. |pypi| image:: https://img.shields.io/pypi/v/python-dateutil.svg?style=flat-square
+    :target: https://pypi.org/project/python-dateutil/
+    :alt: pypi version
+
+.. |support| image:: https://img.shields.io/pypi/pyversions/python-dateutil.svg?style=flat-square
+    :target: https://pypi.org/project/python-dateutil/
+    :alt: supported Python version
+
+.. |travis| image:: https://img.shields.io/travis/dateutil/dateutil/master.svg?style=flat-square&label=Travis%20Build
+    :target: https://travis-ci.org/dateutil/dateutil
+    :alt: travis build status
+
+.. |appveyor| image:: https://img.shields.io/appveyor/ci/dateutil/dateutil/master.svg?style=flat-square&logo=appveyor
+    :target: https://ci.appveyor.com/project/dateutil/dateutil
+    :alt: appveyor build status
+
+.. |pipelines| image:: https://dev.azure.com/pythondateutilazure/dateutil/_apis/build/status/dateutil.dateutil?branchName=master
+    :target: https://dev.azure.com/pythondateutilazure/dateutil/_build/latest?definitionId=1&branchName=master
+    :alt: azure pipelines build status
+
+.. |coverage| image:: https://codecov.io/gh/dateutil/dateutil/branch/master/graphs/badge.svg?branch=master
+    :target: https://codecov.io/gh/dateutil/dateutil?branch=master
+    :alt: Code coverage
+
+.. |gitter| image:: https://badges.gitter.im/dateutil/dateutil.svg
+   :alt: Join the chat at https://gitter.im/dateutil/dateutil
+   :target: https://gitter.im/dateutil/dateutil
+
+.. |licence| image:: https://img.shields.io/pypi/l/python-dateutil.svg?style=flat-square
+    :target: https://pypi.org/project/python-dateutil/
+    :alt: licence
+
+.. |readthedocs| image:: https://img.shields.io/readthedocs/dateutil/latest.svg?style=flat-square&label=Read%20the%20Docs
+   :alt: Read the documentation at https://dateutil.readthedocs.io/en/latest/
+   :target: https://dateutil.readthedocs.io/en/latest/
+
+The `dateutil` module provides powerful extensions to
+the standard `datetime` module, available in Python.
+
+Installation
+============
+`dateutil` can be installed from PyPI using `pip` (note that the package name is
+different from the importable name)::
+
+    pip install python-dateutil
+
+Download
+========
+dateutil is available on PyPI
+https://pypi.org/project/python-dateutil/
+
+The documentation is hosted at:
+https://dateutil.readthedocs.io/en/stable/
+
+Code
+====
+The code and issue tracker are hosted on GitHub:
+https://github.com/dateutil/dateutil/
+
+Features
+========
+
+* Computing of relative deltas (next month, next year,
+  next Monday, last week of month, etc);
+* Computing of relative deltas between two given
+  date and/or datetime objects;
+* Computing of dates based on very flexible recurrence rules,
+  using a superset of the `iCalendar <https://www.ietf.org/rfc/rfc2445.txt>`_
+  specification. Parsing of RFC strings is supported as well.
+* Generic parsing of dates in almost any string format;
+* Timezone (tzinfo) implementations for tzfile(5) format
+  files (/etc/localtime, /usr/share/zoneinfo, etc), TZ
+  environment string (in all known formats), iCalendar
+  format files, given ranges (with help from relative deltas),
+  local machine timezone, fixed offset timezone, UTC timezone,
+  and Windows registry-based time zones.
+* Internal up-to-date world timezone information based on
+  Olson's database.
+* Computing of Easter Sunday dates for any given year,
+  using Western, Orthodox or Julian algorithms;
+* A comprehensive test suite.
+
+Quick example
+=============
+Here's a snapshot, just to give an idea about the power of the
+package. For more examples, look at the documentation.
+
+Suppose you want to know how much time is left, in
+years/months/days/etc, before the next easter happening on a
+year with a Friday 13th in August, and you want to get today's
+date out of the "date" unix system command. Here is the code:
+
+.. code-block:: python3
+
+    >>> from dateutil.relativedelta import *
+    >>> from dateutil.easter import *
+    >>> from dateutil.rrule import *
+    >>> from dateutil.parser import *
+    >>> from datetime import *
+    >>> now = parse("Sat Oct 11 17:13:46 UTC 2003")
+    >>> today = now.date()
+    >>> year = rrule(YEARLY,dtstart=now,bymonth=8,bymonthday=13,byweekday=FR)[0].year
+    >>> rdelta = relativedelta(easter(year), today)
+    >>> print("Today is: %s" % today)
+    Today is: 2003-10-11
+    >>> print("Year with next Aug 13th on a Friday is: %s" % year)
+    Year with next Aug 13th on a Friday is: 2004
+    >>> print("How far is the Easter of that year: %s" % rdelta)
+    How far is the Easter of that year: relativedelta(months=+6)
+    >>> print("And the Easter of that year is: %s" % (today+rdelta))
+    And the Easter of that year is: 2004-04-11
+
+Being exactly 6 months ahead was **really** a coincidence :)
+
+Contributing
+============
+
+We welcome many types of contributions - bug reports, pull requests (code, infrastructure or documentation fixes). For more information about how to contribute to the project, see the ``CONTRIBUTING.md`` file in the repository.
+
+
+Author
+======
+The dateutil module was written by Gustavo Niemeyer <gustavo@niemeyer.net>
+in 2003.
+
+It is maintained by:
+
+* Gustavo Niemeyer <gustavo@niemeyer.net> 2003-2011
+* Tomi Pieviläinen <tomi.pievilainen@iki.fi> 2012-2014
+* Yaron de Leeuw <me@jarondl.net> 2014-2016
+* Paul Ganssle <paul@ganssle.io> 2015-
+
+Starting with version 2.4.1 and running until 2.8.2, all source and binary
+distributions will be signed by a PGP key that has, at the very least, been
+signed by the key which made the previous release. A table of release signing
+keys can be found below:
+
+===========  ============================
+Releases     Signing key fingerprint
+===========  ============================
+2.4.1-2.8.2  `6B49 ACBA DCF6 BD1C A206 67AB CD54 FCE3 D964 BEFB`_ 
+===========  ============================
+
+New releases *may* have signed tags, but binary and source distributions
+uploaded to PyPI will no longer have GPG signatures attached.
+
+Contact
+=======
+Our mailing list is available at `dateutil@python.org <https://mail.python.org/mailman/listinfo/dateutil>`_. As it is hosted by the PSF, it is subject to the `PSF code of
+conduct <https://www.python.org/psf/conduct/>`_.
+
+License
+=======
+
+All contributions after December 1, 2017 released under dual license - either `Apache 2.0 License <https://www.apache.org/licenses/LICENSE-2.0>`_ or the `BSD 3-Clause License <https://opensource.org/licenses/BSD-3-Clause>`_. Contributions before December 1, 2017 - except those those explicitly relicensed - are released only under the BSD 3-Clause License.
+
+
+.. _6B49 ACBA DCF6 BD1C A206 67AB CD54 FCE3 D964 BEFB:
+   https://pgp.mit.edu/pks/lookup?op=vindex&search=0xCD54FCE3D964BEFB
+
+
diff --git a/myvenv/Lib/site-packages/python_dateutil-2.8.2.dist-info/RECORD b/myvenv/Lib/site-packages/python_dateutil-2.8.2.dist-info/RECORD
new file mode 100644
index 0000000..e1c2fe1
--- /dev/null
+++ b/myvenv/Lib/site-packages/python_dateutil-2.8.2.dist-info/RECORD
@@ -0,0 +1,45 @@
+dateutil/__init__.py,sha256=lXElASqwYGwqlrSWSeX19JwF5Be9tNecDa9ebk-0gmk,222
+dateutil/__pycache__/__init__.cpython-39.pyc,,
+dateutil/__pycache__/_common.cpython-39.pyc,,
+dateutil/__pycache__/_version.cpython-39.pyc,,
+dateutil/__pycache__/easter.cpython-39.pyc,,
+dateutil/__pycache__/relativedelta.cpython-39.pyc,,
+dateutil/__pycache__/rrule.cpython-39.pyc,,
+dateutil/__pycache__/tzwin.cpython-39.pyc,,
+dateutil/__pycache__/utils.cpython-39.pyc,,
+dateutil/_common.py,sha256=77w0yytkrxlYbSn--lDVPUMabUXRR9I3lBv_vQRUqUY,932
+dateutil/_version.py,sha256=awyHv2PYvDR84dxjrHyzmm8nieFwMjcuuShPh-QNkM4,142
+dateutil/easter.py,sha256=dyBi-lKvimH1u_k6p7Z0JJK72QhqVtVBsqByvpEPKvc,2678
+dateutil/parser/__init__.py,sha256=wWk6GFuxTpjoggCGtgkceJoti4pVjl4_fHQXpNOaSYg,1766
+dateutil/parser/__pycache__/__init__.cpython-39.pyc,,
+dateutil/parser/__pycache__/_parser.cpython-39.pyc,,
+dateutil/parser/__pycache__/isoparser.cpython-39.pyc,,
+dateutil/parser/_parser.py,sha256=7klDdyicksQB_Xgl-3UAmBwzCYor1AIZqklIcT6dH_8,58796
+dateutil/parser/isoparser.py,sha256=EtLY7w22HWx-XJpTWxJD3XNs6LBHRCps77tCdLnYad8,13247
+dateutil/relativedelta.py,sha256=GjVxqpAVWnG67rdbf7pkoIlJvQqmju9NSfGCcqblc7U,24904
+dateutil/rrule.py,sha256=b6GVV4MpZDbBhJ5qitQKRyx8-_OKyeAbk57or2A8AYU,66556
+dateutil/tz/__init__.py,sha256=F-Mz13v6jYseklQf9Te9J6nzcLDmq47gORa61K35_FA,444
+dateutil/tz/__pycache__/__init__.cpython-39.pyc,,
+dateutil/tz/__pycache__/_common.cpython-39.pyc,,
+dateutil/tz/__pycache__/_factories.cpython-39.pyc,,
+dateutil/tz/__pycache__/tz.cpython-39.pyc,,
+dateutil/tz/__pycache__/win.cpython-39.pyc,,
+dateutil/tz/_common.py,sha256=cgzDTANsOXvEc86cYF77EsliuSab8Puwpsl5-bX3_S4,12977
+dateutil/tz/_factories.py,sha256=unb6XQNXrPMveksTCU-Ag8jmVZs4SojoPUcAHpWnrvU,2569
+dateutil/tz/tz.py,sha256=JotVjDcF16hzoouQ0kZW-5mCYu7Xj67NI-VQgnWapKE,62857
+dateutil/tz/win.py,sha256=xJszWgSwE1xPx_HJj4ZkepyukC_hNy016WMcXhbRaB8,12935
+dateutil/tzwin.py,sha256=7Ar4vdQCnnM0mKR3MUjbIKsZrBVfHgdwsJZc_mGYRew,59
+dateutil/utils.py,sha256=dKCchEw8eObi0loGTx91unBxm_7UGlU3v_FjFMdqwYM,1965
+dateutil/zoneinfo/__init__.py,sha256=KYg0pthCMjcp5MXSEiBJn3nMjZeNZav7rlJw5-tz1S4,5889
+dateutil/zoneinfo/__pycache__/__init__.cpython-39.pyc,,
+dateutil/zoneinfo/__pycache__/rebuild.cpython-39.pyc,,
+dateutil/zoneinfo/dateutil-zoneinfo.tar.gz,sha256=AkcdBx3XkEZwMSpS_TmOEfrEFHLvgxPNDVIwGVxTVaI,174394
+dateutil/zoneinfo/rebuild.py,sha256=MiqYzCIHvNbMH-LdRYLv-4T0EIA7hDKt5GLR0IRTLdI,2392
+python_dateutil-2.8.2.dist-info/INSTALLER,sha256=zuuue4knoyJ-UwPPXg8fezS7VCrXJQrAP7zeNuwvFQg,4
+python_dateutil-2.8.2.dist-info/LICENSE,sha256=ugD1Gg2SgjtaHN4n2LW50jIeZ-2NqbwWPv-W1eF-V34,2889
+python_dateutil-2.8.2.dist-info/METADATA,sha256=RDHtGo7BnYRjmYxot_wlu_W3N2CyvPtvchbtyIlKKPA,8218
+python_dateutil-2.8.2.dist-info/RECORD,,
+python_dateutil-2.8.2.dist-info/REQUESTED,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+python_dateutil-2.8.2.dist-info/WHEEL,sha256=Z-nyYpwrcSqxfdux5Mbn_DQ525iP7J2DG3JgGvOYyTQ,110
+python_dateutil-2.8.2.dist-info/top_level.txt,sha256=4tjdWkhRZvF7LA_BYe_L9gB2w_p2a-z5y6ArjaRkot8,9
+python_dateutil-2.8.2.dist-info/zip-safe,sha256=AbpHGcgLb-kRsJGnwFEktk7uzpZOCcBY74-YBdrKVGs,1
diff --git a/myvenv/Lib/site-packages/python_dateutil-2.8.2.dist-info/REQUESTED b/myvenv/Lib/site-packages/python_dateutil-2.8.2.dist-info/REQUESTED
new file mode 100644
index 0000000..e69de29
diff --git a/myvenv/Lib/site-packages/python_dateutil-2.8.2.dist-info/WHEEL b/myvenv/Lib/site-packages/python_dateutil-2.8.2.dist-info/WHEEL
new file mode 100644
index 0000000..01b8fc7
--- /dev/null
+++ b/myvenv/Lib/site-packages/python_dateutil-2.8.2.dist-info/WHEEL
@@ -0,0 +1,6 @@
+Wheel-Version: 1.0
+Generator: bdist_wheel (0.36.2)
+Root-Is-Purelib: true
+Tag: py2-none-any
+Tag: py3-none-any
+
diff --git a/myvenv/Lib/site-packages/python_dateutil-2.8.2.dist-info/top_level.txt b/myvenv/Lib/site-packages/python_dateutil-2.8.2.dist-info/top_level.txt
new file mode 100644
index 0000000..6650148
--- /dev/null
+++ b/myvenv/Lib/site-packages/python_dateutil-2.8.2.dist-info/top_level.txt
@@ -0,0 +1 @@
+dateutil
diff --git a/myvenv/Lib/site-packages/python_dateutil-2.8.2.dist-info/zip-safe b/myvenv/Lib/site-packages/python_dateutil-2.8.2.dist-info/zip-safe
new file mode 100644
index 0000000..8b13789
--- /dev/null
+++ b/myvenv/Lib/site-packages/python_dateutil-2.8.2.dist-info/zip-safe
@@ -0,0 +1 @@
+
diff --git a/myvenv/Lib/site-packages/six-1.16.0.dist-info/INSTALLER b/myvenv/Lib/site-packages/six-1.16.0.dist-info/INSTALLER
new file mode 100644
index 0000000..a1b589e
--- /dev/null
+++ b/myvenv/Lib/site-packages/six-1.16.0.dist-info/INSTALLER
@@ -0,0 +1 @@
+pip
diff --git a/myvenv/Lib/site-packages/six-1.16.0.dist-info/LICENSE b/myvenv/Lib/site-packages/six-1.16.0.dist-info/LICENSE
new file mode 100644
index 0000000..de66331
--- /dev/null
+++ b/myvenv/Lib/site-packages/six-1.16.0.dist-info/LICENSE
@@ -0,0 +1,18 @@
+Copyright (c) 2010-2020 Benjamin Peterson
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of
+this software and associated documentation files (the "Software"), to deal in
+the Software without restriction, including without limitation the rights to
+use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+the Software, and to permit persons to whom the Software is furnished to do so,
+subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
diff --git a/myvenv/Lib/site-packages/six-1.16.0.dist-info/METADATA b/myvenv/Lib/site-packages/six-1.16.0.dist-info/METADATA
new file mode 100644
index 0000000..6d7525c
--- /dev/null
+++ b/myvenv/Lib/site-packages/six-1.16.0.dist-info/METADATA
@@ -0,0 +1,49 @@
+Metadata-Version: 2.1
+Name: six
+Version: 1.16.0
+Summary: Python 2 and 3 compatibility utilities
+Home-page: https://github.com/benjaminp/six
+Author: Benjamin Peterson
+Author-email: benjamin@python.org
+License: MIT
+Platform: UNKNOWN
+Classifier: Development Status :: 5 - Production/Stable
+Classifier: Programming Language :: Python :: 2
+Classifier: Programming Language :: Python :: 3
+Classifier: Intended Audience :: Developers
+Classifier: License :: OSI Approved :: MIT License
+Classifier: Topic :: Software Development :: Libraries
+Classifier: Topic :: Utilities
+Requires-Python: >=2.7, !=3.0.*, !=3.1.*, !=3.2.*
+
+.. image:: https://img.shields.io/pypi/v/six.svg
+   :target: https://pypi.org/project/six/
+   :alt: six on PyPI
+
+.. image:: https://travis-ci.org/benjaminp/six.svg?branch=master
+   :target: https://travis-ci.org/benjaminp/six
+   :alt: six on TravisCI
+
+.. image:: https://readthedocs.org/projects/six/badge/?version=latest
+   :target: https://six.readthedocs.io/
+   :alt: six's documentation on Read the Docs
+
+.. image:: https://img.shields.io/badge/license-MIT-green.svg
+   :target: https://github.com/benjaminp/six/blob/master/LICENSE
+   :alt: MIT License badge
+
+Six is a Python 2 and 3 compatibility library.  It provides utility functions
+for smoothing over the differences between the Python versions with the goal of
+writing Python code that is compatible on both Python versions.  See the
+documentation for more information on what is provided.
+
+Six supports Python 2.7 and 3.3+.  It is contained in only one Python
+file, so it can be easily copied into your project. (The copyright and license
+notice must be retained.)
+
+Online documentation is at https://six.readthedocs.io/.
+
+Bugs can be reported to https://github.com/benjaminp/six.  The code can also
+be found there.
+
+
diff --git a/myvenv/Lib/site-packages/six-1.16.0.dist-info/RECORD b/myvenv/Lib/site-packages/six-1.16.0.dist-info/RECORD
new file mode 100644
index 0000000..3c18f0a
--- /dev/null
+++ b/myvenv/Lib/site-packages/six-1.16.0.dist-info/RECORD
@@ -0,0 +1,8 @@
+__pycache__/six.cpython-39.pyc,,
+six-1.16.0.dist-info/INSTALLER,sha256=zuuue4knoyJ-UwPPXg8fezS7VCrXJQrAP7zeNuwvFQg,4
+six-1.16.0.dist-info/LICENSE,sha256=i7hQxWWqOJ_cFvOkaWWtI9gq3_YPI5P8J2K2MYXo5sk,1066
+six-1.16.0.dist-info/METADATA,sha256=VQcGIFCAEmfZcl77E5riPCN4v2TIsc_qtacnjxKHJoI,1795
+six-1.16.0.dist-info/RECORD,,
+six-1.16.0.dist-info/WHEEL,sha256=Z-nyYpwrcSqxfdux5Mbn_DQ525iP7J2DG3JgGvOYyTQ,110
+six-1.16.0.dist-info/top_level.txt,sha256=_iVH_iYEtEXnD8nYGQYpYFUvkUW9sEO1GYbkeKSAais,4
+six.py,sha256=TOOfQi7nFGfMrIvtdr6wX4wyHH8M7aknmuLfo2cBBrM,34549
diff --git a/myvenv/Lib/site-packages/six-1.16.0.dist-info/WHEEL b/myvenv/Lib/site-packages/six-1.16.0.dist-info/WHEEL
new file mode 100644
index 0000000..01b8fc7
--- /dev/null
+++ b/myvenv/Lib/site-packages/six-1.16.0.dist-info/WHEEL
@@ -0,0 +1,6 @@
+Wheel-Version: 1.0
+Generator: bdist_wheel (0.36.2)
+Root-Is-Purelib: true
+Tag: py2-none-any
+Tag: py3-none-any
+
diff --git a/myvenv/Lib/site-packages/six-1.16.0.dist-info/top_level.txt b/myvenv/Lib/site-packages/six-1.16.0.dist-info/top_level.txt
new file mode 100644
index 0000000..ffe2fce
--- /dev/null
+++ b/myvenv/Lib/site-packages/six-1.16.0.dist-info/top_level.txt
@@ -0,0 +1 @@
+six
diff --git a/myvenv/Lib/site-packages/six.py b/myvenv/Lib/site-packages/six.py
new file mode 100644
index 0000000..4e15675
--- /dev/null
+++ b/myvenv/Lib/site-packages/six.py
@@ -0,0 +1,998 @@
+# Copyright (c) 2010-2020 Benjamin Peterson
+#
+# Permission is hereby granted, free of charge, to any person obtaining a copy
+# of this software and associated documentation files (the "Software"), to deal
+# in the Software without restriction, including without limitation the rights
+# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+# copies of the Software, and to permit persons to whom the Software is
+# furnished to do so, subject to the following conditions:
+#
+# The above copyright notice and this permission notice shall be included in all
+# copies or substantial portions of the Software.
+#
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+# SOFTWARE.
+
+"""Utilities for writing code that runs on Python 2 and 3"""
+
+from __future__ import absolute_import
+
+import functools
+import itertools
+import operator
+import sys
+import types
+
+__author__ = "Benjamin Peterson <benjamin@python.org>"
+__version__ = "1.16.0"
+
+
+# Useful for very coarse version differentiation.
+PY2 = sys.version_info[0] == 2
+PY3 = sys.version_info[0] == 3
+PY34 = sys.version_info[0:2] >= (3, 4)
+
+if PY3:
+    string_types = str,
+    integer_types = int,
+    class_types = type,
+    text_type = str
+    binary_type = bytes
+
+    MAXSIZE = sys.maxsize
+else:
+    string_types = basestring,
+    integer_types = (int, long)
+    class_types = (type, types.ClassType)
+    text_type = unicode
+    binary_type = str
+
+    if sys.platform.startswith("java"):
+        # Jython always uses 32 bits.
+        MAXSIZE = int((1 << 31) - 1)
+    else:
+        # It's possible to have sizeof(long) != sizeof(Py_ssize_t).
+        class X(object):
+
+            def __len__(self):
+                return 1 << 31
+        try:
+            len(X())
+        except OverflowError:
+            # 32-bit
+            MAXSIZE = int((1 << 31) - 1)
+        else:
+            # 64-bit
+            MAXSIZE = int((1 << 63) - 1)
+        del X
+
+if PY34:
+    from importlib.util import spec_from_loader
+else:
+    spec_from_loader = None
+
+
+def _add_doc(func, doc):
+    """Add documentation to a function."""
+    func.__doc__ = doc
+
+
+def _import_module(name):
+    """Import module, returning the module after the last dot."""
+    __import__(name)
+    return sys.modules[name]
+
+
+class _LazyDescr(object):
+
+    def __init__(self, name):
+        self.name = name
+
+    def __get__(self, obj, tp):
+        result = self._resolve()
+        setattr(obj, self.name, result)  # Invokes __set__.
+        try:
+            # This is a bit ugly, but it avoids running this again by
+            # removing this descriptor.
+            delattr(obj.__class__, self.name)
+        except AttributeError:
+            pass
+        return result
+
+
+class MovedModule(_LazyDescr):
+
+    def __init__(self, name, old, new=None):
+        super(MovedModule, self).__init__(name)
+        if PY3:
+            if new is None:
+                new = name
+            self.mod = new
+        else:
+            self.mod = old
+
+    def _resolve(self):
+        return _import_module(self.mod)
+
+    def __getattr__(self, attr):
+        _module = self._resolve()
+        value = getattr(_module, attr)
+        setattr(self, attr, value)
+        return value
+
+
+class _LazyModule(types.ModuleType):
+
+    def __init__(self, name):
+        super(_LazyModule, self).__init__(name)
+        self.__doc__ = self.__class__.__doc__
+
+    def __dir__(self):
+        attrs = ["__doc__", "__name__"]
+        attrs += [attr.name for attr in self._moved_attributes]
+        return attrs
+
+    # Subclasses should override this
+    _moved_attributes = []
+
+
+class MovedAttribute(_LazyDescr):
+
+    def __init__(self, name, old_mod, new_mod, old_attr=None, new_attr=None):
+        super(MovedAttribute, self).__init__(name)
+        if PY3:
+            if new_mod is None:
+                new_mod = name
+            self.mod = new_mod
+            if new_attr is None:
+                if old_attr is None:
+                    new_attr = name
+                else:
+                    new_attr = old_attr
+            self.attr = new_attr
+        else:
+            self.mod = old_mod
+            if old_attr is None:
+                old_attr = name
+            self.attr = old_attr
+
+    def _resolve(self):
+        module = _import_module(self.mod)
+        return getattr(module, self.attr)
+
+
+class _SixMetaPathImporter(object):
+
+    """
+    A meta path importer to import six.moves and its submodules.
+
+    This class implements a PEP302 finder and loader. It should be compatible
+    with Python 2.5 and all existing versions of Python3
+    """
+
+    def __init__(self, six_module_name):
+        self.name = six_module_name
+        self.known_modules = {}
+
+    def _add_module(self, mod, *fullnames):
+        for fullname in fullnames:
+            self.known_modules[self.name + "." + fullname] = mod
+
+    def _get_module(self, fullname):
+        return self.known_modules[self.name + "." + fullname]
+
+    def find_module(self, fullname, path=None):
+        if fullname in self.known_modules:
+            return self
+        return None
+
+    def find_spec(self, fullname, path, target=None):
+        if fullname in self.known_modules:
+            return spec_from_loader(fullname, self)
+        return None
+
+    def __get_module(self, fullname):
+        try:
+            return self.known_modules[fullname]
+        except KeyError:
+            raise ImportError("This loader does not know module " + fullname)
+
+    def load_module(self, fullname):
+        try:
+            # in case of a reload
+            return sys.modules[fullname]
+        except KeyError:
+            pass
+        mod = self.__get_module(fullname)
+        if isinstance(mod, MovedModule):
+            mod = mod._resolve()
+        else:
+            mod.__loader__ = self
+        sys.modules[fullname] = mod
+        return mod
+
+    def is_package(self, fullname):
+        """
+        Return true, if the named module is a package.
+
+        We need this method to get correct spec objects with
+        Python 3.4 (see PEP451)
+        """
+        return hasattr(self.__get_module(fullname), "__path__")
+
+    def get_code(self, fullname):
+        """Return None
+
+        Required, if is_package is implemented"""
+        self.__get_module(fullname)  # eventually raises ImportError
+        return None
+    get_source = get_code  # same as get_code
+
+    def create_module(self, spec):
+        return self.load_module(spec.name)
+
+    def exec_module(self, module):
+        pass
+
+_importer = _SixMetaPathImporter(__name__)
+
+
+class _MovedItems(_LazyModule):
+
+    """Lazy loading of moved objects"""
+    __path__ = []  # mark as package
+
+
+_moved_attributes = [
+    MovedAttribute("cStringIO", "cStringIO", "io", "StringIO"),
+    MovedAttribute("filter", "itertools", "builtins", "ifilter", "filter"),
+    MovedAttribute("filterfalse", "itertools", "itertools", "ifilterfalse", "filterfalse"),
+    MovedAttribute("input", "__builtin__", "builtins", "raw_input", "input"),
+    MovedAttribute("intern", "__builtin__", "sys"),
+    MovedAttribute("map", "itertools", "builtins", "imap", "map"),
+    MovedAttribute("getcwd", "os", "os", "getcwdu", "getcwd"),
+    MovedAttribute("getcwdb", "os", "os", "getcwd", "getcwdb"),
+    MovedAttribute("getoutput", "commands", "subprocess"),
+    MovedAttribute("range", "__builtin__", "builtins", "xrange", "range"),
+    MovedAttribute("reload_module", "__builtin__", "importlib" if PY34 else "imp", "reload"),
+    MovedAttribute("reduce", "__builtin__", "functools"),
+    MovedAttribute("shlex_quote", "pipes", "shlex", "quote"),
+    MovedAttribute("StringIO", "StringIO", "io"),
+    MovedAttribute("UserDict", "UserDict", "collections"),
+    MovedAttribute("UserList", "UserList", "collections"),
+    MovedAttribute("UserString", "UserString", "collections"),
+    MovedAttribute("xrange", "__builtin__", "builtins", "xrange", "range"),
+    MovedAttribute("zip", "itertools", "builtins", "izip", "zip"),
+    MovedAttribute("zip_longest", "itertools", "itertools", "izip_longest", "zip_longest"),
+    MovedModule("builtins", "__builtin__"),
+    MovedModule("configparser", "ConfigParser"),
+    MovedModule("collections_abc", "collections", "collections.abc" if sys.version_info >= (3, 3) else "collections"),
+    MovedModule("copyreg", "copy_reg"),
+    MovedModule("dbm_gnu", "gdbm", "dbm.gnu"),
+    MovedModule("dbm_ndbm", "dbm", "dbm.ndbm"),
+    MovedModule("_dummy_thread", "dummy_thread", "_dummy_thread" if sys.version_info < (3, 9) else "_thread"),
+    MovedModule("http_cookiejar", "cookielib", "http.cookiejar"),
+    MovedModule("http_cookies", "Cookie", "http.cookies"),
+    MovedModule("html_entities", "htmlentitydefs", "html.entities"),
+    MovedModule("html_parser", "HTMLParser", "html.parser"),
+    MovedModule("http_client", "httplib", "http.client"),
+    MovedModule("email_mime_base", "email.MIMEBase", "email.mime.base"),
+    MovedModule("email_mime_image", "email.MIMEImage", "email.mime.image"),
+    MovedModule("email_mime_multipart", "email.MIMEMultipart", "email.mime.multipart"),
+    MovedModule("email_mime_nonmultipart", "email.MIMENonMultipart", "email.mime.nonmultipart"),
+    MovedModule("email_mime_text", "email.MIMEText", "email.mime.text"),
+    MovedModule("BaseHTTPServer", "BaseHTTPServer", "http.server"),
+    MovedModule("CGIHTTPServer", "CGIHTTPServer", "http.server"),
+    MovedModule("SimpleHTTPServer", "SimpleHTTPServer", "http.server"),
+    MovedModule("cPickle", "cPickle", "pickle"),
+    MovedModule("queue", "Queue"),
+    MovedModule("reprlib", "repr"),
+    MovedModule("socketserver", "SocketServer"),
+    MovedModule("_thread", "thread", "_thread"),
+    MovedModule("tkinter", "Tkinter"),
+    MovedModule("tkinter_dialog", "Dialog", "tkinter.dialog"),
+    MovedModule("tkinter_filedialog", "FileDialog", "tkinter.filedialog"),
+    MovedModule("tkinter_scrolledtext", "ScrolledText", "tkinter.scrolledtext"),
+    MovedModule("tkinter_simpledialog", "SimpleDialog", "tkinter.simpledialog"),
+    MovedModule("tkinter_tix", "Tix", "tkinter.tix"),
+    MovedModule("tkinter_ttk", "ttk", "tkinter.ttk"),
+    MovedModule("tkinter_constants", "Tkconstants", "tkinter.constants"),
+    MovedModule("tkinter_dnd", "Tkdnd", "tkinter.dnd"),
+    MovedModule("tkinter_colorchooser", "tkColorChooser",
+                "tkinter.colorchooser"),
+    MovedModule("tkinter_commondialog", "tkCommonDialog",
+                "tkinter.commondialog"),
+    MovedModule("tkinter_tkfiledialog", "tkFileDialog", "tkinter.filedialog"),
+    MovedModule("tkinter_font", "tkFont", "tkinter.font"),
+    MovedModule("tkinter_messagebox", "tkMessageBox", "tkinter.messagebox"),
+    MovedModule("tkinter_tksimpledialog", "tkSimpleDialog",
+                "tkinter.simpledialog"),
+    MovedModule("urllib_parse", __name__ + ".moves.urllib_parse", "urllib.parse"),
+    MovedModule("urllib_error", __name__ + ".moves.urllib_error", "urllib.error"),
+    MovedModule("urllib", __name__ + ".moves.urllib", __name__ + ".moves.urllib"),
+    MovedModule("urllib_robotparser", "robotparser", "urllib.robotparser"),
+    MovedModule("xmlrpc_client", "xmlrpclib", "xmlrpc.client"),
+    MovedModule("xmlrpc_server", "SimpleXMLRPCServer", "xmlrpc.server"),
+]
+# Add windows specific modules.
+if sys.platform == "win32":
+    _moved_attributes += [
+        MovedModule("winreg", "_winreg"),
+    ]
+
+for attr in _moved_attributes:
+    setattr(_MovedItems, attr.name, attr)
+    if isinstance(attr, MovedModule):
+        _importer._add_module(attr, "moves." + attr.name)
+del attr
+
+_MovedItems._moved_attributes = _moved_attributes
+
+moves = _MovedItems(__name__ + ".moves")
+_importer._add_module(moves, "moves")
+
+
+class Module_six_moves_urllib_parse(_LazyModule):
+
+    """Lazy loading of moved objects in six.moves.urllib_parse"""
+
+
+_urllib_parse_moved_attributes = [
+    MovedAttribute("ParseResult", "urlparse", "urllib.parse"),
+    MovedAttribute("SplitResult", "urlparse", "urllib.parse"),
+    MovedAttribute("parse_qs", "urlparse", "urllib.parse"),
+    MovedAttribute("parse_qsl", "urlparse", "urllib.parse"),
+    MovedAttribute("urldefrag", "urlparse", "urllib.parse"),
+    MovedAttribute("urljoin", "urlparse", "urllib.parse"),
+    MovedAttribute("urlparse", "urlparse", "urllib.parse"),
+    MovedAttribute("urlsplit", "urlparse", "urllib.parse"),
+    MovedAttribute("urlunparse", "urlparse", "urllib.parse"),
+    MovedAttribute("urlunsplit", "urlparse", "urllib.parse"),
+    MovedAttribute("quote", "urllib", "urllib.parse"),
+    MovedAttribute("quote_plus", "urllib", "urllib.parse"),
+    MovedAttribute("unquote", "urllib", "urllib.parse"),
+    MovedAttribute("unquote_plus", "urllib", "urllib.parse"),
+    MovedAttribute("unquote_to_bytes", "urllib", "urllib.parse", "unquote", "unquote_to_bytes"),
+    MovedAttribute("urlencode", "urllib", "urllib.parse"),
+    MovedAttribute("splitquery", "urllib", "urllib.parse"),
+    MovedAttribute("splittag", "urllib", "urllib.parse"),
+    MovedAttribute("splituser", "urllib", "urllib.parse"),
+    MovedAttribute("splitvalue", "urllib", "urllib.parse"),
+    MovedAttribute("uses_fragment", "urlparse", "urllib.parse"),
+    MovedAttribute("uses_netloc", "urlparse", "urllib.parse"),
+    MovedAttribute("uses_params", "urlparse", "urllib.parse"),
+    MovedAttribute("uses_query", "urlparse", "urllib.parse"),
+    MovedAttribute("uses_relative", "urlparse", "urllib.parse"),
+]
+for attr in _urllib_parse_moved_attributes:
+    setattr(Module_six_moves_urllib_parse, attr.name, attr)
+del attr
+
+Module_six_moves_urllib_parse._moved_attributes = _urllib_parse_moved_attributes
+
+_importer._add_module(Module_six_moves_urllib_parse(__name__ + ".moves.urllib_parse"),
+                      "moves.urllib_parse", "moves.urllib.parse")
+
+
+class Module_six_moves_urllib_error(_LazyModule):
+
+    """Lazy loading of moved objects in six.moves.urllib_error"""
+
+
+_urllib_error_moved_attributes = [
+    MovedAttribute("URLError", "urllib2", "urllib.error"),
+    MovedAttribute("HTTPError", "urllib2", "urllib.error"),
+    MovedAttribute("ContentTooShortError", "urllib", "urllib.error"),
+]
+for attr in _urllib_error_moved_attributes:
+    setattr(Module_six_moves_urllib_error, attr.name, attr)
+del attr
+
+Module_six_moves_urllib_error._moved_attributes = _urllib_error_moved_attributes
+
+_importer._add_module(Module_six_moves_urllib_error(__name__ + ".moves.urllib.error"),
+                      "moves.urllib_error", "moves.urllib.error")
+
+
+class Module_six_moves_urllib_request(_LazyModule):
+
+    """Lazy loading of moved objects in six.moves.urllib_request"""
+
+
+_urllib_request_moved_attributes = [
+    MovedAttribute("urlopen", "urllib2", "urllib.request"),
+    MovedAttribute("install_opener", "urllib2", "urllib.request"),
+    MovedAttribute("build_opener", "urllib2", "urllib.request"),
+    MovedAttribute("pathname2url", "urllib", "urllib.request"),
+    MovedAttribute("url2pathname", "urllib", "urllib.request"),
+    MovedAttribute("getproxies", "urllib", "urllib.request"),
+    MovedAttribute("Request", "urllib2", "urllib.request"),
+    MovedAttribute("OpenerDirector", "urllib2", "urllib.request"),
+    MovedAttribute("HTTPDefaultErrorHandler", "urllib2", "urllib.request"),
+    MovedAttribute("HTTPRedirectHandler", "urllib2", "urllib.request"),
+    MovedAttribute("HTTPCookieProcessor", "urllib2", "urllib.request"),
+    MovedAttribute("ProxyHandler", "urllib2", "urllib.request"),
+    MovedAttribute("BaseHandler", "urllib2", "urllib.request"),
+    MovedAttribute("HTTPPasswordMgr", "urllib2", "urllib.request"),
+    MovedAttribute("HTTPPasswordMgrWithDefaultRealm", "urllib2", "urllib.request"),
+    MovedAttribute("AbstractBasicAuthHandler", "urllib2", "urllib.request"),
+    MovedAttribute("HTTPBasicAuthHandler", "urllib2", "urllib.request"),
+    MovedAttribute("ProxyBasicAuthHandler", "urllib2", "urllib.request"),
+    MovedAttribute("AbstractDigestAuthHandler", "urllib2", "urllib.request"),
+    MovedAttribute("HTTPDigestAuthHandler", "urllib2", "urllib.request"),
+    MovedAttribute("ProxyDigestAuthHandler", "urllib2", "urllib.request"),
+    MovedAttribute("HTTPHandler", "urllib2", "urllib.request"),
+    MovedAttribute("HTTPSHandler", "urllib2", "urllib.request"),
+    MovedAttribute("FileHandler", "urllib2", "urllib.request"),
+    MovedAttribute("FTPHandler", "urllib2", "urllib.request"),
+    MovedAttribute("CacheFTPHandler", "urllib2", "urllib.request"),
+    MovedAttribute("UnknownHandler", "urllib2", "urllib.request"),
+    MovedAttribute("HTTPErrorProcessor", "urllib2", "urllib.request"),
+    MovedAttribute("urlretrieve", "urllib", "urllib.request"),
+    MovedAttribute("urlcleanup", "urllib", "urllib.request"),
+    MovedAttribute("URLopener", "urllib", "urllib.request"),
+    MovedAttribute("FancyURLopener", "urllib", "urllib.request"),
+    MovedAttribute("proxy_bypass", "urllib", "urllib.request"),
+    MovedAttribute("parse_http_list", "urllib2", "urllib.request"),
+    MovedAttribute("parse_keqv_list", "urllib2", "urllib.request"),
+]
+for attr in _urllib_request_moved_attributes:
+    setattr(Module_six_moves_urllib_request, attr.name, attr)
+del attr
+
+Module_six_moves_urllib_request._moved_attributes = _urllib_request_moved_attributes
+
+_importer._add_module(Module_six_moves_urllib_request(__name__ + ".moves.urllib.request"),
+                      "moves.urllib_request", "moves.urllib.request")
+
+
+class Module_six_moves_urllib_response(_LazyModule):
+
+    """Lazy loading of moved objects in six.moves.urllib_response"""
+
+
+_urllib_response_moved_attributes = [
+    MovedAttribute("addbase", "urllib", "urllib.response"),
+    MovedAttribute("addclosehook", "urllib", "urllib.response"),
+    MovedAttribute("addinfo", "urllib", "urllib.response"),
+    MovedAttribute("addinfourl", "urllib", "urllib.response"),
+]
+for attr in _urllib_response_moved_attributes:
+    setattr(Module_six_moves_urllib_response, attr.name, attr)
+del attr
+
+Module_six_moves_urllib_response._moved_attributes = _urllib_response_moved_attributes
+
+_importer._add_module(Module_six_moves_urllib_response(__name__ + ".moves.urllib.response"),
+                      "moves.urllib_response", "moves.urllib.response")
+
+
+class Module_six_moves_urllib_robotparser(_LazyModule):
+
+    """Lazy loading of moved objects in six.moves.urllib_robotparser"""
+
+
+_urllib_robotparser_moved_attributes = [
+    MovedAttribute("RobotFileParser", "robotparser", "urllib.robotparser"),
+]
+for attr in _urllib_robotparser_moved_attributes:
+    setattr(Module_six_moves_urllib_robotparser, attr.name, attr)
+del attr
+
+Module_six_moves_urllib_robotparser._moved_attributes = _urllib_robotparser_moved_attributes
+
+_importer._add_module(Module_six_moves_urllib_robotparser(__name__ + ".moves.urllib.robotparser"),
+                      "moves.urllib_robotparser", "moves.urllib.robotparser")
+
+
+class Module_six_moves_urllib(types.ModuleType):
+
+    """Create a six.moves.urllib namespace that resembles the Python 3 namespace"""
+    __path__ = []  # mark as package
+    parse = _importer._get_module("moves.urllib_parse")
+    error = _importer._get_module("moves.urllib_error")
+    request = _importer._get_module("moves.urllib_request")
+    response = _importer._get_module("moves.urllib_response")
+    robotparser = _importer._get_module("moves.urllib_robotparser")
+
+    def __dir__(self):
+        return ['parse', 'error', 'request', 'response', 'robotparser']
+
+_importer._add_module(Module_six_moves_urllib(__name__ + ".moves.urllib"),
+                      "moves.urllib")
+
+
+def add_move(move):
+    """Add an item to six.moves."""
+    setattr(_MovedItems, move.name, move)
+
+
+def remove_move(name):
+    """Remove item from six.moves."""
+    try:
+        delattr(_MovedItems, name)
+    except AttributeError:
+        try:
+            del moves.__dict__[name]
+        except KeyError:
+            raise AttributeError("no such move, %r" % (name,))
+
+
+if PY3:
+    _meth_func = "__func__"
+    _meth_self = "__self__"
+
+    _func_closure = "__closure__"
+    _func_code = "__code__"
+    _func_defaults = "__defaults__"
+    _func_globals = "__globals__"
+else:
+    _meth_func = "im_func"
+    _meth_self = "im_self"
+
+    _func_closure = "func_closure"
+    _func_code = "func_code"
+    _func_defaults = "func_defaults"
+    _func_globals = "func_globals"
+
+
+try:
+    advance_iterator = next
+except NameError:
+    def advance_iterator(it):
+        return it.next()
+next = advance_iterator
+
+
+try:
+    callable = callable
+except NameError:
+    def callable(obj):
+        return any("__call__" in klass.__dict__ for klass in type(obj).__mro__)
+
+
+if PY3:
+    def get_unbound_function(unbound):
+        return unbound
+
+    create_bound_method = types.MethodType
+
+    def create_unbound_method(func, cls):
+        return func
+
+    Iterator = object
+else:
+    def get_unbound_function(unbound):
+        return unbound.im_func
+
+    def create_bound_method(func, obj):
+        return types.MethodType(func, obj, obj.__class__)
+
+    def create_unbound_method(func, cls):
+        return types.MethodType(func, None, cls)
+
+    class Iterator(object):
+
+        def next(self):
+            return type(self).__next__(self)
+
+    callable = callable
+_add_doc(get_unbound_function,
+         """Get the function out of a possibly unbound function""")
+
+
+get_method_function = operator.attrgetter(_meth_func)
+get_method_self = operator.attrgetter(_meth_self)
+get_function_closure = operator.attrgetter(_func_closure)
+get_function_code = operator.attrgetter(_func_code)
+get_function_defaults = operator.attrgetter(_func_defaults)
+get_function_globals = operator.attrgetter(_func_globals)
+
+
+if PY3:
+    def iterkeys(d, **kw):
+        return iter(d.keys(**kw))
+
+    def itervalues(d, **kw):
+        return iter(d.values(**kw))
+
+    def iteritems(d, **kw):
+        return iter(d.items(**kw))
+
+    def iterlists(d, **kw):
+        return iter(d.lists(**kw))
+
+    viewkeys = operator.methodcaller("keys")
+
+    viewvalues = operator.methodcaller("values")
+
+    viewitems = operator.methodcaller("items")
+else:
+    def iterkeys(d, **kw):
+        return d.iterkeys(**kw)
+
+    def itervalues(d, **kw):
+        return d.itervalues(**kw)
+
+    def iteritems(d, **kw):
+        return d.iteritems(**kw)
+
+    def iterlists(d, **kw):
+        return d.iterlists(**kw)
+
+    viewkeys = operator.methodcaller("viewkeys")
+
+    viewvalues = operator.methodcaller("viewvalues")
+
+    viewitems = operator.methodcaller("viewitems")
+
+_add_doc(iterkeys, "Return an iterator over the keys of a dictionary.")
+_add_doc(itervalues, "Return an iterator over the values of a dictionary.")
+_add_doc(iteritems,
+         "Return an iterator over the (key, value) pairs of a dictionary.")
+_add_doc(iterlists,
+         "Return an iterator over the (key, [values]) pairs of a dictionary.")
+
+
+if PY3:
+    def b(s):
+        return s.encode("latin-1")
+
+    def u(s):
+        return s
+    unichr = chr
+    import struct
+    int2byte = struct.Struct(">B").pack
+    del struct
+    byte2int = operator.itemgetter(0)
+    indexbytes = operator.getitem
+    iterbytes = iter
+    import io
+    StringIO = io.StringIO
+    BytesIO = io.BytesIO
+    del io
+    _assertCountEqual = "assertCountEqual"
+    if sys.version_info[1] <= 1:
+        _assertRaisesRegex = "assertRaisesRegexp"
+        _assertRegex = "assertRegexpMatches"
+        _assertNotRegex = "assertNotRegexpMatches"
+    else:
+        _assertRaisesRegex = "assertRaisesRegex"
+        _assertRegex = "assertRegex"
+        _assertNotRegex = "assertNotRegex"
+else:
+    def b(s):
+        return s
+    # Workaround for standalone backslash
+
+    def u(s):
+        return unicode(s.replace(r'\\', r'\\\\'), "unicode_escape")
+    unichr = unichr
+    int2byte = chr
+
+    def byte2int(bs):
+        return ord(bs[0])
+
+    def indexbytes(buf, i):
+        return ord(buf[i])
+    iterbytes = functools.partial(itertools.imap, ord)
+    import StringIO
+    StringIO = BytesIO = StringIO.StringIO
+    _assertCountEqual = "assertItemsEqual"
+    _assertRaisesRegex = "assertRaisesRegexp"
+    _assertRegex = "assertRegexpMatches"
+    _assertNotRegex = "assertNotRegexpMatches"
+_add_doc(b, """Byte literal""")
+_add_doc(u, """Text literal""")
+
+
+def assertCountEqual(self, *args, **kwargs):
+    return getattr(self, _assertCountEqual)(*args, **kwargs)
+
+
+def assertRaisesRegex(self, *args, **kwargs):
+    return getattr(self, _assertRaisesRegex)(*args, **kwargs)
+
+
+def assertRegex(self, *args, **kwargs):
+    return getattr(self, _assertRegex)(*args, **kwargs)
+
+
+def assertNotRegex(self, *args, **kwargs):
+    return getattr(self, _assertNotRegex)(*args, **kwargs)
+
+
+if PY3:
+    exec_ = getattr(moves.builtins, "exec")
+
+    def reraise(tp, value, tb=None):
+        try:
+            if value is None:
+                value = tp()
+            if value.__traceback__ is not tb:
+                raise value.with_traceback(tb)
+            raise value
+        finally:
+            value = None
+            tb = None
+
+else:
+    def exec_(_code_, _globs_=None, _locs_=None):
+        """Execute code in a namespace."""
+        if _globs_ is None:
+            frame = sys._getframe(1)
+            _globs_ = frame.f_globals
+            if _locs_ is None:
+                _locs_ = frame.f_locals
+            del frame
+        elif _locs_ is None:
+            _locs_ = _globs_
+        exec("""exec _code_ in _globs_, _locs_""")
+
+    exec_("""def reraise(tp, value, tb=None):
+    try:
+        raise tp, value, tb
+    finally:
+        tb = None
+""")
+
+
+if sys.version_info[:2] > (3,):
+    exec_("""def raise_from(value, from_value):
+    try:
+        raise value from from_value
+    finally:
+        value = None
+""")
+else:
+    def raise_from(value, from_value):
+        raise value
+
+
+print_ = getattr(moves.builtins, "print", None)
+if print_ is None:
+    def print_(*args, **kwargs):
+        """The new-style print function for Python 2.4 and 2.5."""
+        fp = kwargs.pop("file", sys.stdout)
+        if fp is None:
+            return
+
+        def write(data):
+            if not isinstance(data, basestring):
+                data = str(data)
+            # If the file has an encoding, encode unicode with it.
+            if (isinstance(fp, file) and
+                    isinstance(data, unicode) and
+                    fp.encoding is not None):
+                errors = getattr(fp, "errors", None)
+                if errors is None:
+                    errors = "strict"
+                data = data.encode(fp.encoding, errors)
+            fp.write(data)
+        want_unicode = False
+        sep = kwargs.pop("sep", None)
+        if sep is not None:
+            if isinstance(sep, unicode):
+                want_unicode = True
+            elif not isinstance(sep, str):
+                raise TypeError("sep must be None or a string")
+        end = kwargs.pop("end", None)
+        if end is not None:
+            if isinstance(end, unicode):
+                want_unicode = True
+            elif not isinstance(end, str):
+                raise TypeError("end must be None or a string")
+        if kwargs:
+            raise TypeError("invalid keyword arguments to print()")
+        if not want_unicode:
+            for arg in args:
+                if isinstance(arg, unicode):
+                    want_unicode = True
+                    break
+        if want_unicode:
+            newline = unicode("\n")
+            space = unicode(" ")
+        else:
+            newline = "\n"
+            space = " "
+        if sep is None:
+            sep = space
+        if end is None:
+            end = newline
+        for i, arg in enumerate(args):
+            if i:
+                write(sep)
+            write(arg)
+        write(end)
+if sys.version_info[:2] < (3, 3):
+    _print = print_
+
+    def print_(*args, **kwargs):
+        fp = kwargs.get("file", sys.stdout)
+        flush = kwargs.pop("flush", False)
+        _print(*args, **kwargs)
+        if flush and fp is not None:
+            fp.flush()
+
+_add_doc(reraise, """Reraise an exception.""")
+
+if sys.version_info[0:2] < (3, 4):
+    # This does exactly the same what the :func:`py3:functools.update_wrapper`
+    # function does on Python versions after 3.2. It sets the ``__wrapped__``
+    # attribute on ``wrapper`` object and it doesn't raise an error if any of
+    # the attributes mentioned in ``assigned`` and ``updated`` are missing on
+    # ``wrapped`` object.
+    def _update_wrapper(wrapper, wrapped,
+                        assigned=functools.WRAPPER_ASSIGNMENTS,
+                        updated=functools.WRAPPER_UPDATES):
+        for attr in assigned:
+            try:
+                value = getattr(wrapped, attr)
+            except AttributeError:
+                continue
+            else:
+                setattr(wrapper, attr, value)
+        for attr in updated:
+            getattr(wrapper, attr).update(getattr(wrapped, attr, {}))
+        wrapper.__wrapped__ = wrapped
+        return wrapper
+    _update_wrapper.__doc__ = functools.update_wrapper.__doc__
+
+    def wraps(wrapped, assigned=functools.WRAPPER_ASSIGNMENTS,
+              updated=functools.WRAPPER_UPDATES):
+        return functools.partial(_update_wrapper, wrapped=wrapped,
+                                 assigned=assigned, updated=updated)
+    wraps.__doc__ = functools.wraps.__doc__
+
+else:
+    wraps = functools.wraps
+
+
+def with_metaclass(meta, *bases):
+    """Create a base class with a metaclass."""
+    # This requires a bit of explanation: the basic idea is to make a dummy
+    # metaclass for one level of class instantiation that replaces itself with
+    # the actual metaclass.
+    class metaclass(type):
+
+        def __new__(cls, name, this_bases, d):
+            if sys.version_info[:2] >= (3, 7):
+                # This version introduced PEP 560 that requires a bit
+                # of extra care (we mimic what is done by __build_class__).
+                resolved_bases = types.resolve_bases(bases)
+                if resolved_bases is not bases:
+                    d['__orig_bases__'] = bases
+            else:
+                resolved_bases = bases
+            return meta(name, resolved_bases, d)
+
+        @classmethod
+        def __prepare__(cls, name, this_bases):
+            return meta.__prepare__(name, bases)
+    return type.__new__(metaclass, 'temporary_class', (), {})
+
+
+def add_metaclass(metaclass):
+    """Class decorator for creating a class with a metaclass."""
+    def wrapper(cls):
+        orig_vars = cls.__dict__.copy()
+        slots = orig_vars.get('__slots__')
+        if slots is not None:
+            if isinstance(slots, str):
+                slots = [slots]
+            for slots_var in slots:
+                orig_vars.pop(slots_var)
+        orig_vars.pop('__dict__', None)
+        orig_vars.pop('__weakref__', None)
+        if hasattr(cls, '__qualname__'):
+            orig_vars['__qualname__'] = cls.__qualname__
+        return metaclass(cls.__name__, cls.__bases__, orig_vars)
+    return wrapper
+
+
+def ensure_binary(s, encoding='utf-8', errors='strict'):
+    """Coerce **s** to six.binary_type.
+
+    For Python 2:
+      - `unicode` -> encoded to `str`
+      - `str` -> `str`
+
+    For Python 3:
+      - `str` -> encoded to `bytes`
+      - `bytes` -> `bytes`
+    """
+    if isinstance(s, binary_type):
+        return s
+    if isinstance(s, text_type):
+        return s.encode(encoding, errors)
+    raise TypeError("not expecting type '%s'" % type(s))
+
+
+def ensure_str(s, encoding='utf-8', errors='strict'):
+    """Coerce *s* to `str`.
+
+    For Python 2:
+      - `unicode` -> encoded to `str`
+      - `str` -> `str`
+
+    For Python 3:
+      - `str` -> `str`
+      - `bytes` -> decoded to `str`
+    """
+    # Optimization: Fast return for the common case.
+    if type(s) is str:
+        return s
+    if PY2 and isinstance(s, text_type):
+        return s.encode(encoding, errors)
+    elif PY3 and isinstance(s, binary_type):
+        return s.decode(encoding, errors)
+    elif not isinstance(s, (text_type, binary_type)):
+        raise TypeError("not expecting type '%s'" % type(s))
+    return s
+
+
+def ensure_text(s, encoding='utf-8', errors='strict'):
+    """Coerce *s* to six.text_type.
+
+    For Python 2:
+      - `unicode` -> `unicode`
+      - `str` -> `unicode`
+
+    For Python 3:
+      - `str` -> `str`
+      - `bytes` -> decoded to `str`
+    """
+    if isinstance(s, binary_type):
+        return s.decode(encoding, errors)
+    elif isinstance(s, text_type):
+        return s
+    else:
+        raise TypeError("not expecting type '%s'" % type(s))
+
+
+def python_2_unicode_compatible(klass):
+    """
+    A class decorator that defines __unicode__ and __str__ methods under Python 2.
+    Under Python 3 it does nothing.
+
+    To support Python 2 and 3 with a single code base, define a __str__ method
+    returning text and apply this decorator to the class.
+    """
+    if PY2:
+        if '__str__' not in klass.__dict__:
+            raise ValueError("@python_2_unicode_compatible cannot be applied "
+                             "to %s because it doesn't define __str__()." %
+                             klass.__name__)
+        klass.__unicode__ = klass.__str__
+        klass.__str__ = lambda self: self.__unicode__().encode('utf-8')
+    return klass
+
+
+# Complete the moves implementation.
+# This code is at the end of this module to speed up module loading.
+# Turn this module into a package.
+__path__ = []  # required for PEP 302 and PEP 451
+__package__ = __name__  # see PEP 366 @ReservedAssignment
+if globals().get("__spec__") is not None:
+    __spec__.submodule_search_locations = []  # PEP 451 @UndefinedVariable
+# Remove other six meta path importers, since they cause problems. This can
+# happen if six is removed from sys.modules and then reloaded. (Setuptools does
+# this for some reason.)
+if sys.meta_path:
+    for i, importer in enumerate(sys.meta_path):
+        # Here's some real nastiness: Another "instance" of the six module might
+        # be floating around. Therefore, we can't use isinstance() to check for
+        # the six meta path importer, since the other six instance will have
+        # inserted an importer with different class.
+        if (type(importer).__name__ == "_SixMetaPathImporter" and
+                importer.name == __name__):
+            del sys.meta_path[i]
+            break
+    del i, importer
+# Finally, add the importer to the meta path import hook.
+sys.meta_path.append(_importer)
-- 
2.40.1.windows.1

